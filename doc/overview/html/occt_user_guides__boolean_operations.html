<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Open CASCADE Technology: Boolean Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="occ_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('occt_user_guides__boolean_operations.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Boolean Operations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#occt_algorithms_1">Introduction</a></li>
<li class="level1"><a href="#occt_algorithms_2">Overview</a><ul><li class="level2"><a href="#occt_algorithms_2_1">Operators</a><ul><li class="level3"><a href="#occt_algorithms_2_1_1">Boolean operator</a></li>
<li class="level3"><a href="#occt_algorithms_2_1_2">General Fuse operator</a></li>
<li class="level3"><a href="#occt_algorithms_2_1_3">Partition operator</a></li>
<li class="level3"><a href="#occt_algorithms_2_1_4">Section operator</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_2_2">Parts of algorithms</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_3">Terms and Definitions</a><ul><li class="level2"><a href="#occt_algorithms_3_1">Interferences</a><ul><li class="level3"><a href="#occt_algorithms_3_1_1">Vertex/Vertex interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_2">Vertex/Edge interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_3">Vertex/Face interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_4">Edge/Edge interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_5">Edge/Face interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_6">Face/Face Interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_7">Vertex/Solid Interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_8">Edge/Soild Interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_9">Face/Soild Interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_10">Solid/Soild Interference</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_11">Computation Order</a></li>
<li class="level3"><a href="#occt_algorithms_3_1_12">Results</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_3_2">Paves</a></li>
<li class="level2"><a href="#occt_algorithms_3_3">Pave Blocks</a></li>
<li class="level2"><a href="#occt_algorithms_3_4">Shrunk Range</a></li>
<li class="level2"><a href="#occt_algorithms_3_5">Common Blocks</a></li>
<li class="level2"><a href="#occt_algorithms_3_6">FaceInfo</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_4">Data Structure</a><ul><li class="level2"><a href="#occt_algorithms_4_1">Arguments</a></li>
<li class="level2"><a href="#occt_algorithms_4_2">Shapes</a></li>
<li class="level2"><a href="#occt_algorithms_4_3">Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a></li>
<li class="level2"><a href="#occt_algorithms_4_5">Points and Curves</a></li>
<li class="level2"><a href="#occt_algorithms_4_6">FaceInfo</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_5">Intersection Part</a><ul><li class="level2"><a href="#occt_algorithms_5_1a">Class BOPAlgo_Algo</a></li>
<li class="level2"><a href="#occt_algorithms_5_1">Initialization</a></li>
<li class="level2"><a href="#occt_algorithms_5_2">Compute Vertex/Vertex Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_3">Compute Vertex/Edge Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_4">Update Pave Blocks</a></li>
<li class="level2"><a href="#occt_algorithms_5_5">Compute Edge/Edge Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_6">Compute Vertex/Face Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_7">Compute Edge/Face Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_8">Build Split Edges</a></li>
<li class="level2"><a href="#occt_algorithms_5_9">Compute Face/Face Interferences</a></li>
<li class="level2"><a href="#occt_algorithms_5_10">Build Section Edges</a></li>
<li class="level2"><a href="#occt_algorithms_5_11">Build P-Curves</a></li>
<li class="level2"><a href="#occt_algorithms_5_12">Process Degenerated Edges</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_6">General description of the Building Part</a></li>
<li class="level1"><a href="#occt_algorithms_7">General Fuse Algorithm</a><ul><li class="level2"><a href="#occt_algorithms_7_1">Arguments</a></li>
<li class="level2"><a href="#occt_algorithms_7_2">Results</a></li>
<li class="level2"><a href="#occt_algorithms_7_3">Examples</a><ul><li class="level3"><a href="#occt_algorithms_7_3_1">Case 1: Three edges intersecting at a point</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_2">Case 2: Two wires and an edge</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_3">Case 3: An edge intersecting with a face</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_4">Case 4: An edge lying on a face</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_5">Case 5: An edge and a shell</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_6">Case 6: A wire and a shell</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_7">Case 7: Three faces</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_8">Case 8: A face and a shell</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_9">Case 9: A shell and a solid</a></li>
<li class="level3"><a href="#occt_algorithms_7_3_10">Case 10: A compound and a solid</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_7_4">Class BOPAlgo_Builder</a><ul><li class="level3"><a href="#occt_algorithms_7_4_1">Fields</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_2">Initialization</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_3">Build Images for Vertices</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_4">Build Result of Type Vertex</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_5">Build Images for Edges</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_6">Build Result of Type Edge</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_7">Build Images for Wires</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_8">Build Result of Type Wire</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_9">Build Images for Faces</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_10">Build Result of Type Face</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_11">Build Images for Shells</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_12">Build Result of Type Shell</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_13">Build Images for Solids</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_14">Build Result of Type Solid</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_15">Build Images for Type CompSolid</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_16">Build Result of Type Compsolid</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_17">Build Images for Compounds</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_18">Build Result of Type Compound</a></li>
<li class="level3"><a href="#occt_algorithms_7_4_19">Post-Processing</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_9">Boolean Operations Algorithm</a><ul><li class="level2"><a href="#occt_algorithms_9_1">Arguments</a></li>
<li class="level2"><a href="#occt_algorithms_9_3">Results. General Rules</a></li>
<li class="level2"><a href="#occt_algorithms_9_4">Examples</a><ul><li class="level3"><a href="#occt_algorithms_9_4_1">Case 1: Two Vertices</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_2">Case 2: A Vertex and an Edge</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_3">Case 3: A Vertex and a Face</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_4">Case 4: A Vertex and a Solid</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_5">Case 5: Two edges intersecting at one point</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_6">Case 6: Two edges having a common block</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_7">Case 7: An Edge and a Face intersecting at a point</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_8">Case 8: A Face and an Edge that have a common block</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_9">Case 9: An Edge and a Solid intersecting at a point</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_10">Case 10: An Edge and a Solid that have a common block</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_11">Case 11: Two intersecting faces</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_12">Case 12: Two faces that have a common part</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_13">Case 13: Two faces that have a common edge</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_14">Case 14: Two faces that have a common vertex</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_15">Case 15: A Face and a Solid that have an intersection curve.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_16">Case 16: A Face and a Solid that have overlapping faces.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_17">Case 17: A Face and a Solid that have overlapping edges.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_18">Case 18: A Face and a Solid that have overlapping vertices.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_19">Case 19: Two intersecting Solids.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_20">Case 20: Two Solids that have overlapping faces.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_21">Case 21: Two Solids that have overlapping edges.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_22">Case 22: Two Solids that have overlapping vertices.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_23">Case 23: A Shell and a Wire cut by a Solid.</a></li>
<li class="level3"><a href="#occt_algorithms_9_4_24">Case 24: Two Wires that have overlapping edges.</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_9_5">Class BOPAlgo_BOP</a></li>
<li class="level2"><a href="#occt_algorithms_9_6">Building Draft Result</a></li>
<li class="level2"><a href="#occt_algorithms_9_7">Building the Result</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_10a">Section Algorithm</a><ul><li class="level2"><a href="#occt_algorithms_10a_1">Arguments</a></li>
<li class="level2"><a href="#occt_algorithms_10a_2">Results and general rules</a></li>
<li class="level2"><a href="#occt_algorithms_10a_3">Examples</a><ul><li class="level3"><a href="#occt_algorithms_10a_3_1">Case 1: Two Vertices</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_2">Case 1: Case 2: A Vertex and an Edge</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_3">Case 1: Case 2: A Vertex and a Face</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_4">Case 4: A Vertex and a Solid</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_5">Case 5: Two edges intersecting at one point</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_6">Case 6: Two edges having a common block</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_7">Case 7: An Edge and a Face intersecting at a point</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_8">Case 8: A Face and an Edge that have a common block</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_9">Case 9: An Edge and a Solid intersecting at a point</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_10">Case 10: An Edge and a Solid that have a common block</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_11">Case 11: Two intersecting faces</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_12">Case 12: Two faces that have a common part</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_13">Case 13: Two faces that have overlapping edges</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_14">Case 14: Two faces that have overlapping vertices</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_15">Case 15: A Face and a Solid that have an intersection curve</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_16">Case 16: A Face and a Solid that have overlapping faces.</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_17">Case 17: A Face and a Solid that have overlapping edges.</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_18">Case 18: A Face and a Solid that have overlapping vertices.</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_19">Case 19: Two intersecting Solids</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_20">Case 20: Two Solids that have overlapping faces</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_21">Case 21: Two Solids that have overlapping edges</a></li>
<li class="level3"><a href="#occt_algorithms_10a_3_22">Case 22: Two Solids that have overlapping vertices</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_10a_4">Class BOPAlgo_Section</a></li>
<li class="level2"><a href="#occt_algorithms_10a_5">Building the Result</a></li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_10">Algorithm Limitations</a><ul><li class="level2"><a href="#occt_algorithms_10_1">Arguments</a><ul><li class="level3"><a href="#occt_algorithms_10_1_1">Common requirements</a></li>
<li class="level3"><a href="#occt_algorithms_10_1_3">Pure self-interference</a></li>
<li class="level3"><a href="#occt_algorithms_10_1_4">Self-interferences due to tolerances</a></li>
<li class="level3"><a href="#occt_algorithms_10_1_5">Parametric representation</a></li>
<li class="level3"><a href="#occt_algorithms_10_1_6">Using tolerances of vertices to fix gaps</a></li>
</ul>
</li>
<li class="level2"><a href="#occt_algorithms_11_1">Intersection problems</a><ul><li class="level3"><a href="#occt_algorithms_11_1_1">Pure intersections and common zones</a></li>
<li class="level3"><a href="#occt_algorithms_11_2_2">Tolerances and inaccuracies</a></li>
<li class="level3"><a href="#occt_algorithms_11_2_3">Acquired Self-interferences</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_11a">Advanced Options</a><ul><li class="level2"><a href="#occt_algorithms_11a_1">Fuzzy Boolean Operation</a></li>
<li class="level2"><a href="#occt_algorithms_11a_2">Examples</a><ul><li class="level3"><a href="#occt_algorithms_11a_1_1">Case 1</a></li>
<li class="level3"><a href="#occt_algorithms_11a_1_2">Case 2</a></li>
<li class="level3"><a href="#occt_algorithms_11a_1_3">Case 3</a></li>
<li class="level3"><a href="#occt_algorithms_11a_1_4">Case 4</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#occt_algorithms_11b">Usage</a><ul><li class="level2"><a href="#occt_algorithms_11b_1">Package BRepAlgoAPI</a></li>
<li class="level2"><a href="#occt_algorithms_11b_2">Package BOPTest</a><ul><li class="level3"><a href="#occt_algorithms_11b_2_1">Case 1 General Fuse operation</a></li>
<li class="level3"><a href="#occt_algorithms_11b_2_2">Case 2. Common operation</a></li>
<li class="level3"><a href="#occt_algorithms_11b_2_3">Case 3. Fuse operation</a></li>
<li class="level3"><a href="#occt_algorithms_11b_2_4">Case 4. Cut operation</a></li>
<li class="level3"><a href="#occt_algorithms_11b_2_5">Case 5. Section operation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="occt_algorithms_1"></a>
Introduction</h1>
<p>This document provides a comprehensive description of the Boolean Operation Algorithm (BOA) as it is implemented in Open CASCADE Technology. The Boolean Component contains:</p>
<ul>
<li>General Fuse Operator (GFA),</li>
<li>Boolean Operator (BOA),</li>
<li>Section Operator (SA),</li>
<li>Partition Operator (PA).</li>
</ul>
<p>GFA is the base algorithm for BOA, PA, SA.</p>
<p>GFA has a history-based architecture designed to allow using OCAF naming functionality. The architecture of GFA is expandable, that allows creating new algorithms basing on it.</p>
<h1><a class="anchor" id="occt_algorithms_2"></a>
Overview</h1>
<h2><a class="anchor" id="occt_algorithms_2_1"></a>
Operators</h2>
<h3><a class="anchor" id="occt_algorithms_2_1_1"></a>
Boolean operator</h3>
<p>The Boolean operator provides the operations (Common, Fuse, Cut) between two groups: <em>Objects</em> and <em>Tools</em>. Each group consists of an arbitrary number of arguments in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>.</p>
<p>The operator can be represented as:</p>
<p><em>R<sub>B</sub>=B<sub>j</sub> (G<sub>1</sub>, G<sub>2</sub>),</em></p>
<p>where:</p><ul>
<li><em>R<sub>B</sub></em> &ndash; result of the operation;</li>
<li><em>B<sub>j</sub></em> &ndash; operation of type <em>j</em> (Common, Fuse, Cut);</li>
<li><em>G<sub>1</sub>={S<sub>11</sub>, S<sub>12</sub> ... S<sub>1n1</sub>}</em> group of arguments (Objects);</li>
<li><em>G<sub>2</sub>={S<sub>21</sub>, S<sub>22</sub> ... S<sub>2n2</sub>}</em> group of arguments (Tools);</li>
<li><em>n<sub>1</sub></em> &ndash; Number of arguments in <em>Objects</em> group;</li>
<li><em>n<sub>2</sub></em> &ndash; Number of arguments in <em>Tools</em> group.</li>
</ul>
<p><b>Note</b> There is an operation <em>Cut21</em>, which is an extension for forward Cut operation, i.e <em>Cut21=Cut(G2, G1)</em>.</p>
<h3><a class="anchor" id="occt_algorithms_2_1_2"></a>
General Fuse operator</h3>
<p>The General fuse operator can be applied to an arbitrary number of arguments in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>.</p>
<p>The GFA operator can be represented as:</p>
<p><em>R<sub>GF</sub> = GF (S<sub>1</sub>, S<sub>2</sub> ... S<sub>n</sub>), </em></p>
<p>where</p><ul>
<li><em>R<sub>GF</sub></em> &ndash; result of the operation,</li>
<li><em>S<sub>1</sub>, S<sub>2</sub> ... S<sub>n</sub></em> &ndash; arguments of the operation,</li>
<li><em>n</em> &ndash; number of arguments.</li>
</ul>
<p>The result of the Boolean operator, <em>R<sub>B</sub></em>, can be obtained from <em>R<sub>GF</sub></em>.</p>
<p>For example, for two arguments <em>S<sub>1</sub></em> and <em>S<sub>2</sub></em> the result <em>R<sub>GF</sub></em> is</p>
<p><em>R<sub>GF</sub> = GF (S<sub>1</sub>, S<sub>2</sub>) = S<sub>p1</sub> + S<sub>p2</sub> + S<sub>p12</sub></em></p>
<div class="image">
<img src="operations_image001.svg" alt="operations_image001.svg"/>
<div class="caption">
Operators</div></div>
<p>This Figure shows that</p><ul>
<li><em>B<sub>common</sub> (S<sub>1</sub>, S<sub>2</sub>) = S<sub>p12</sub>;</em></li>
<li><em>B<sub>cut12</sub> (S<sub>1</sub>, S<sub>2</sub>) = S<sub>p1</sub>;</em></li>
<li><em>B<sub>cut21</sub> (S<sub>1</sub>, S<sub>2</sub>) = S<sub>p2</sub>;</em></li>
<li><em>B<sub>fuse</sub> (S<sub>1</sub>, S<sub>2</sub>) = S<sub>p1</sub>+S<sub>p2</sub>+S<sub>p12</sub></em></li>
</ul>
<p><em>R<sub>GF</sub>=GF (S<sub>1</sub>, S<sub>2</sub>) = B<sub>fuse</sub> = B<sub>common</sub>+ B<sub>cut12</sub>+ B<sub>cut21</sub>.</em></p>
<p>The fact that <em>R<sub>GF</sub></em> contains the components of <em>R<sub>B</sub></em> allows considering GFA as the general case of BOA. So it is possible to implement BOA as a subclass of GFA.</p>
<h3><a class="anchor" id="occt_algorithms_2_1_3"></a>
Partition operator</h3>
<p>The Partition operator can be applied to an arbitrary number of arguments in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>. The arguments are divided on two groups: Objects, Tools. The result of PA contains all parts belonging to the Objects but does not contain the parts that belongs to the Tools only.</p>
<p>The PA operator can be represented as follows:</p>
<p><em>R<sub>PA</sub>=PA (G<sub>1</sub>, G<sub>2</sub>),</em> where:</p><ul>
<li><em>R<sub>PA</sub></em> &ndash; is the result of the operation;</li>
<li><em>G<sub>1</sub>={S<sub>11</sub>, S<sub>12</sub> ... S<sub>1n1</sub>}</em> group of arguments (Objects);</li>
<li><em>G<sub>2</sub>={S<sub>21</sub>, S<sub>22</sub> ... S<sub>2n2</sub>}</em> group of arguments (Tools);</li>
<li><em>n<sub>1</sub></em> &ndash; Number of arguments in <em>Objects</em> group;</li>
<li><em>n<sub>2</sub></em> &ndash; Number of arguments in <em>Tools</em> group.</li>
</ul>
<p>The result <em>R<sub>PA</sub></em> can be obtained from <em>R<sub>GF</sub></em> .</p>
<p>For example, for two arguments <em>S<sub>1</sub></em> and <em>S<sub>2</sub></em> the result <em>R<sub>PA</sub></em> is</p>
<p><em>R<sub>PA</sub>=PA(S<sub>1</sub>,S<sub>2</sub>)=S<sub>p1</sub>+S<sub>p12</sub>.</em></p>
<p>In case when all arguments of the PA are Objects (no Tools), the result of PA is equivalent to the result of GFA.</p>
<p>For example, when <em>G<sub>1</sub></em> consists of shapes <em>S<sub>1</sub></em> and <em>S<sub>2</sub></em> the result of <em>R<sub>PA</sub></em> is</p>
<p><em>R<sub>PA</sub>=PA(S<sub>1</sub>, S<sub>2</sub>) = S<sub>p1</sub> + S<sub>p2</sub> + S<sub>p12</sub> = GF (S<sub>1</sub>, S<sub>2</sub>)</em></p>
<p>The fact that the <em>R<sub>GF</sub></em> contains the components of <em>R<sub>PA</sub></em> allows considering GFA as the general case of PA. Thus, it is possible to implement PA as a subclass of GFA.</p>
<h3><a class="anchor" id="occt_algorithms_2_1_4"></a>
Section operator</h3>
<p>The Section operator <em>SA</em> can be applied to arbitrary number of arguments in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>. The result of <em>SA</em> contains vertices and edges in accordance with interferences between the arguments The SA operator can be represented as follows: <em>R<sub>SA</sub>=SA(S1, S2… Sn)</em>, where</p><ul>
<li><em>R<sub>SA</sub></em> &ndash; the operation result;</li>
<li><em>S1, S2 ... Sn</em> &ndash; the operation arguments;</li>
<li><em>n</em> &ndash; the number of arguments.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_2_2"></a>
Parts of algorithms</h2>
<p>GFA, BOA, PA and SA have the same Data Structure (DS). The main goal of the Data Structure is to store all necessary information for input data and intermediate results.</p>
<p>The operators consist of two main parts:</p><ul>
<li>Intersection Part (IP). The main goal of IP is to compute the interferences between sub-shapes of arguments. The IP uses DS to retrieve input data and store the results of intersections.</li>
<li>Building Part (BP). The main goal of BP is to build required result of an operation. This part also uses DS to retrieve data and store the results.</li>
</ul>
<p>As it follows from the definition of operator results, the main differences between GFA, BOA, PA and SA are in the Building Part. The Intersection Part is the same for the algorithms.</p>
<h1><a class="anchor" id="occt_algorithms_3"></a>
Terms and Definitions</h1>
<p>This chapter provides the background terms and definitions that are necessary to understand how the algorithms work.</p>
<h2><a class="anchor" id="occt_algorithms_3_1"></a>
Interferences</h2>
<p>There are two groups of interferences.</p>
<p>At first, each shape having a boundary representation (vertex, edge, face) has an internal value of geometrical tolerance. The shapes interfere with each other in terms of their tolerances. The shapes that have a boundary representation interfere when there is a part of 3D space where the distance between the underlying geometry of shapes is less or equal to the sum of tolerances of the shapes. Three types of shapes: vertex, edge and face &ndash; produce six types of <b>BRep interferences:</b></p><ul>
<li>Vertex/Vertex,</li>
<li>Vertex/Edge,</li>
<li>Vertex/Face,</li>
<li>Edge/Edge,</li>
<li>Edge/Face and</li>
<li>Face/Face.</li>
</ul>
<p>At second, there are interferences that occur between a solid <em>Z1</em> and a shape <em>S2</em> when <em>Z1</em> and <em>S2</em> have no BRep interferences but <em>S2</em> is completely inside of <em>Z1</em>. These interferences are <b>Non-BRep interferences</b>. There are four possible cases:</p><ul>
<li>Vertex/Solid,</li>
<li>Edge/Solid,</li>
<li>Face/Solid and</li>
<li>Solid/Solid.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_3_1_1"></a>
Vertex/Vertex interference</h3>
<p>For two vertices <em>Vi</em> and <em>Vj</em>, the distance between their corresponding 3D points is less than the sum of their tolerances <em>Tol(Vi)</em> and <em>Tol(Vj)</em>.</p>
<div class="image">
<img src="operations_image002.svg" alt="operations_image002.svg"/>
<div class="caption">
Vertex/vertex interference</div></div>
<p>The result is a new vertex <em>Vn</em> with 3D point <em>Pn</em> and tolerance value <em>Tol(Vn)</em>.</p>
<p>The coordinates of <em>Pn</em> and the value <em>Tol(Vn)</em> are computed as the center and the radius of the sphere enclosing the tolerance spheres of the source vertices <em>(V1, V2)</em>.</p>
<h3><a class="anchor" id="occt_algorithms_3_1_2"></a>
Vertex/Edge interference</h3>
<p>For a vertex <em>Vi</em> and an edge <em>Ej</em>, the distance <em>D</em> between 3D point of the vertex and its projection on the 3D curve of edge <em>Ej</em> is less or equal than sum of tolerances of vertex <em>Tol(Vi)</em> and edge <em>Tol(Ej)</em>.</p>
<div class="image">
<img src="operations_image003.svg" alt="operations_image003.svg"/>
<div class="caption">
Vertex/edge interference</div></div>
<p>The result is vertex <em>Vi</em> with the corresponding tolerance value <em>Tol(Vi)=Max(Tol(Vi), D+Tol(Ej))</em>, where <em>D = distance (Pi, PPi)</em>;</p>
<p>and parameter <em>t<sub>i</sub></em> of the projected point <em>PPi</em> on 3D curve <em>Cj</em> of edge <em>Ej</em>.</p>
<h3><a class="anchor" id="occt_algorithms_3_1_3"></a>
Vertex/Face interference</h3>
<p>For a vertex <em>Vi</em> and a face <em>Fj</em> the distance <em>D</em> between 3D point of the vertex and its projection on the surface of the face is less or equal than sum of tolerances of the vertex <em>Tol(Vi)</em> and the face <em>Tol(Fj)</em>.</p>
<div class="image">
<img src="operations_image004.svg" alt="operations_image004.svg"/>
<div class="caption">
Vertex/face interference</div></div>
<p>The result is vertex <em>Vi</em> with the corresponding tolerance value <em>Tol(Vi)=Max(Tol(Vi), D+Tol(Fj))</em>, where <em>D = distance (Pi, PPi)</em></p>
<p>and parameters <em>u<sub>i</sub>, v<sub>i</sub></em> of the projected point <em>PPi</em> on surface <em>Sj</em> of face <em>Fj</em>.</p>
<h3><a class="anchor" id="occt_algorithms_3_1_4"></a>
Edge/Edge interference</h3>
<p>For two edges <em>Ei</em> and <em>Ej</em> (with the corresponding 3D curves <em>Ci</em> and <em>Cj</em>) there are some places where the distance between the curves is less than (or equal to) sum of tolerances of the edges.</p>
<p>Let us examine two cases:</p>
<p>In the first case two edges have one or several common parts of 3D curves in terms of tolerance.</p>
<div class="image">
<img src="operations_image005.svg" alt="operations_image005.svg"/>
<div class="caption">
Edge/edge interference: common parts</div></div>
<p>The results are:</p><ul>
<li>Parametric range <em>[t<sub>i1</sub>, t<sub>i2</sub> ]</em> for 3D curve <em>Ci</em> of edge <em>Ei</em>.</li>
<li>Parametric range <em>[t<sub>j1</sub>, t<sub>j2</sub> ]</em> for 3D curve <em>Cj</em> of edge <em>Ej</em>.</li>
</ul>
<p>In the second case two edges have one or several common points in terms of tolerance.</p>
<div class="image">
<img src="operations_image006.svg" alt="operations_image006.svg"/>
<div class="caption">
Edge/edge interference: common points</div></div>
 The result is a new vertex <em>Vn</em> with 3D point <em>Pn</em> and tolerance value <em>Tol(Vn)</em>.</p>
<p>The coordinates of <em>Pn</em> and the value <em>Tol(Vn)</em> are computed as the center and the radius of the sphere enclosing the tolerance spheres of the corresponding nearest points <em>Pi</em>, <em>Pj</em> of 3D curves <em>Ci</em>, <em>Cj</em> of source edges <em>Ei</em>, <em>Ej</em>.</p>
<ul>
<li>Parameter <em>t<sub>i</sub></em> of <em>Pi</em> for the 3D curve <em>Ci</em>.</li>
<li>Parameter <em>t<sub>j</sub></em> of <em>Pj</em> for the 3D curve <em>Cj</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_3_1_5"></a>
Edge/Face interference</h3>
<p>For an edge <em>Ei</em> (with the corresponding 3D curve <em>Ci</em>) and a face <em>Fj</em> (with the corresponding 3D surface <em>Sj</em>) there are some places in 3D space, where the distance between <em>Ci</em> and surface <em>Sj</em> is less than (or equal to) the sum of tolerances of edge <em>Ei</em> and face <em>Fj</em>.</p>
<p>Let us examine two cases:</p>
<p>In the first case Edge <em>Ei</em> and Face <em>Fj</em> have one or several common parts in terms of tolerance.</p>
<div class="image">
<img src="operations_image007.svg" alt="operations_image007.svg"/>
<div class="caption">
Edge/face interference: common parts</div></div>
<p>The result is a parametric range <em>[t<sub>i1</sub>, t<sub>i2</sub>]</em> for the 3D curve <em>Ci</em> of the edge <em>Ei</em>.</p>
<p>In the second case Edge <em>Ei</em> and Face <em>Fj</em> have one or several common points in terms of tolerance.</p>
<div class="image">
<img src="operations_image008.svg" alt="operations_image008.svg"/>
<div class="caption">
Edge/face interference: common points</div></div>
<p>The result is a new vertex <em>Vn</em> with 3D point <em>Pn</em> and tolerance value <em>Tol(Vn)</em>.</p>
<p>The coordinates of <em>Pn</em> and the value <em>Tol(Vn)</em> are computed as the center and the radius of the sphere enclosing the tolerance spheres of the corresponding nearest points <em>Pi</em>, <em>Pj</em> of 3D curve <em>Ci</em> and surface <em>Sj</em> of source edges <em>Ei</em>, <em>Fj</em>.</p>
<ul>
<li>Parameter <em>t<sub>i</sub></em> of <em>Pi</em> for the 3D curve <em>Ci</em>.</li>
<li>Parameters <em>u<sub>i</sub></em> and <em>v<sub>i</sub></em> of the projected point <em>PPi</em> on the surface <em>Sj</em> of the face <em>Fj</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_3_1_6"></a>
Face/Face Interference</h3>
<p>For a face <em>Fi</em> and a face <em>Fj</em> (with the corresponding surfaces <em>Si</em> and <em>Sj</em>) there are some places in 3D space, where the distance between the surfaces is less than (or equal to) sum of tolerances of the faces.</p>
<div class="image">
<img src="operations_image009.svg" alt="operations_image009.svg"/>
<div class="caption">
Face/face interference: common curves</div></div>
<p>In the first case the result contains intersection curves <em>C<sub>ijk</sub> (k = 0, 1, 2…k<sub>N</sub>,</em> where <em>k<sub>N</sub></em> is the number of intersection curves with corresponding values of tolerances <em>Tol(C<sub>ijk</sub>)</em>.</p>
<div class="image">
<img src="operations_image010.svg" alt="operations_image010.svg"/>
<div class="caption">
Face/face interference: common points</div></div>
<p>In the second case Face <em>Fi</em> and face <em>Fj</em> have one or several new vertices <em>V<sub>ijm</sub></em>, where <em>m=0,1,2, ... mN, mN </em> is the number of intersection points.</p>
<p>The coordinates of a 3D point <em>P<sub>ijm</sub></em> and the value <em>Tol(V<sub>ijm</sub>)</em> are computed as the center and the radius of the sphere enclosing the tolerance spheres of the corresponding nearest points <em>Pi</em>, <em>Pj</em> of the surface <em>Si</em>, <em>Sj</em> of source shapes <em>Fi</em>, <em>Fj</em>.</p>
<ul>
<li>Parameters <em>u<sub>j</sub></em>, <em>v<sub>j</sub></em> belong to point <em>PPj</em> projected on surface <em>Sj</em> of face <em>Fj</em>.</li>
<li>Parameters <em>u<sub>i</sub></em> and <em>v<sub>i</sub></em> belong to point <em>PPi</em> projected on surface <em>Si</em> of face <em>Fi</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_3_1_7"></a>
Vertex/Solid Interference</h3>
<p>For a vertex <em>Vi</em> and a solid <em>Zj</em> there is Vertex/Solid interference if the vertex <em>Vi</em> has no BRep interferences with any sub-shape of <em>Zj</em> and <em>Vi</em> is completely inside the solid <em>Zj</em>.</p>
<div class="image">
<img src="operations_image060.png" alt="operations_image060.png"/>
<div class="caption">
Vertex/Solid Interference</div></div>
<h3><a class="anchor" id="occt_algorithms_3_1_8"></a>
Edge/Soild Interference</h3>
<p>For an edge <em>Ei</em> and a solid <em>Zj</em> there is Edge/Solid interference if the edge <em>Ei</em> and its sub-shapes have no BRep interferences with any sub-shape of <em>Zj</em> and <em>Ei</em> is completely inside the solid <em>Zj</em>.</p>
<div class="image">
<img src="operations_image061.png" alt="operations_image061.png"/>
<div class="caption">
Edge/Solid Interference</div></div>
<h3><a class="anchor" id="occt_algorithms_3_1_9"></a>
Face/Soild Interference</h3>
<p>For a face <em>Fi</em> and a solid <em>Zj</em> there is Face/Solid interference if the face <em>Fi</em> and its sub-shapes have no BRep interferences with any sub-shape of <em>Zj</em> and <em>Fi</em> is completely inside the solid <em>Zj</em>.</p>
<div class="image">
<img src="operations_image062.png" alt="operations_image062.png"/>
<div class="caption">
Face/Solid Interference</div></div>
<h3><a class="anchor" id="occt_algorithms_3_1_10"></a>
Solid/Soild Interference</h3>
<p>For a solid <em>Zi</em> and a solid <em>Zj</em> there is Solid/Solid interference if the solid <em>Zi</em> and its sub-shapes have no BRep interferences with any sub-shape of <em>Zj</em> and <em>Zi</em> is completely inside the solid <em>Zj</em>.</p>
<div class="image">
<img src="operations_image063.png" alt="operations_image063.png"/>
<div class="caption">
Solid/Solid Interference</div></div>
<h3><a class="anchor" id="occt_algorithms_3_1_11"></a>
Computation Order</h3>
<p>The interferences between shapes are computed on the basis of increasing of the dimension value of the shape in the following order:</p><ul>
<li>Vertex/Vertex,</li>
<li>Vertex/Edge,</li>
<li>Edge/Edge,</li>
<li>Vertex/Face,</li>
<li>Edge/Face,</li>
<li>Face/Face,</li>
<li>Vertex/Solid,</li>
<li>Edge/Solid,</li>
<li>Face/Solid,</li>
<li>Solid/Solid.</li>
</ul>
<p>This order allows avoiding the computation of redundant interferences between upper-level shapes <em>Si</em> and <em>Sj</em> when there are interferences between lower sub-shapes <em>Sik</em> and <em>Sjm</em>.</p>
<h3><a class="anchor" id="occt_algorithms_3_1_12"></a>
Results</h3>
<ul>
<li>The result of the interference is a shape that can be either interfered shape itself (or its part) or a new shape.</li>
<li>The result of the interference is a shape with the dimension value that is less or equal to the minimal dimension value of interfered shapes. For example, the result of Vertex/Edge interference is a vertex, but not an edge.</li>
<li>The result of the interference splits the source shapes on the parts each time as it can do that.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_3_2"></a>
Paves</h2>
<p>The result of interferences of the type Vertex/Edge, Edge/Edge and Edge/Face in most cases is a vertex (new or old) lying on an edge.</p>
<p>The result of interferences of the type Face/Face in most cases is intersection curves, which go through some vertices lying on the faces.</p>
<p>The position of vertex <em>Vi</em> on curve <em>C</em> can be defined by a value of parameter <em>t<sub>i</sub></em> of the 3D point of the vertex on the curve. Pave <em>PVi</em> on curve <em>C</em> is a structure containing the vertex <em>Vi</em> and correspondent value of the parameter <em>t<sub>i</sub></em> of the 3D point of the vertex on the curve. Curve <em>C</em> can be a 3D or a 2D curve.</p>
<div class="image">
<img src="operations_image011.svg" alt="operations_image011.svg"/>
<div class="caption">
Paves</div></div>
<p>Two paves <em>PV1</em> and <em>PV2</em> on the same curve <em>C</em> can be compared using the parameter value</p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;PV1 &gt; PV2 if t1 &gt; t2 </div>
</div><!-- fragment --><p>The usage of paves allows binding of the vertex to the curve (or any structure that contains a curve: edge, intersection curve).</p>
<h2><a class="anchor" id="occt_algorithms_3_3"></a>
Pave Blocks</h2>
<p>A set of paves <em>PVi (i=1, 2...nPV)</em>, where <em>nPV</em> is the number of paves] of curve <em>C</em> can be sorted in the increasing order using the value of parameter <em>t</em> on curve <em>C</em>.</p>
<p>A pave block <em>PBi</em> is a part of the object (edge, intersection curve) between neighboring paves.</p>
<div class="image">
<img src="operations_image012.svg" alt="operations_image012.svg"/>
<div class="caption">
Pave Blocks</div></div>
<p>Any finite source edge <em>E</em> has at least one pave block that contains two paves <em>PVb</em> and <em>PVe</em>:</p><ul>
<li>Pave <em>PVb</em> corresponds to the vertex <em>Vb</em> with minimal parameter <em>t<sub>b</sub></em> on the curve of the edge.</li>
<li>Pave <em>PVe</em> corresponds to the vertex <em>Ve</em> with maximal parameter <em>t<sub>e</sub></em> on the curve of the edge.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_3_4"></a>
Shrunk Range</h2>
<p>Pave block <em>PV</em> of curve <em>C</em> is bounded by vertices <em>V1</em> and <em>V2</em> with tolerance values <em>Tol(V1)</em> and <em>Tol(V2)</em>. Curve <em>C</em> has its own tolerance value <em>Tol(C)</em>:</p><ul>
<li>In case of edge, the tolerance value is the tolerance of the edge.</li>
<li>In case of intersection curve, the tolerance value is obtained from an intersection algorithm.</li>
</ul>
<div class="image">
<img src="operations_image013.svg" alt="operations_image013.svg"/>
<div class="caption">
Shrunk Range</div></div>
<p>The theoretical parametric range of the pave block is <em>[t1C, t2C]</em>.</p>
<p>The positions of the vertices <em>V1</em> and <em>V2</em> of the pave block can be different. The positions are determined by the following conditions: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Distance (P1, P1c) is equal or less than Tol(V1) + Tol(C)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Distance (P2, P2c) is equal or less than Tol(V2) + Tol(C)</div>
</div><!-- fragment --><p> The Figure shows that each tolerance sphere of a vertex can reduce the parametric range of the pave block to a range <em>[t1S, t2S]</em>. The range <em>[t1S, t2S]</em> is the shrunk range of the pave block.</p>
<p>The shrunk range of the pave block is the part of 3D curve that can interfere with other shapes.</p>
<h2><a class="anchor" id="occt_algorithms_3_5"></a>
Common Blocks</h2>
<p>The interferences of the type Edge/Edge, Edge/Face produce results as common parts.</p>
<p>In case of Edge/Edge interference the common parts are pave blocks that have different base edges.</p>
<div class="image">
<img src="operations_image014.svg" alt="operations_image014.svg"/>
<div class="caption">
Common Blocks: Edge/Edge interference</div></div>
<p>If the pave blocks <em>PB<sub>1</sub>, PB<sub>2</sub>…PB<sub>NbPB</sub></em> , where <em>NbPB</em> is the number of pave blocks have the same bounding vertices and geometrically coincide, the pave blocks form common block <em>CB</em>.</p>
<p>In case of Edge/Face interference the common parts are pave blocks lying on a face(s).</p>
<div class="image">
<img src="operations_image015.svg" alt="operations_image015.svg"/>
<div class="caption">
Common Blocks: Edge/Face interference</div></div>
<p>If the pave blocks <em>PBi</em> geometrically coincide with a face <em>Fj</em>, the pave blocks form common block <em>CB</em>.</p>
<p>In general case a common block <em>CB</em> contains:</p><ul>
<li>Pave blocks <em>PBi (i=0,1,2, 3… NbPB)</em>.</li>
<li>A set of faces <em>Fj (j=0,1... NbF), NbF</em> &ndash; number of faces.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_3_6"></a>
FaceInfo</h2>
<p>The structure <em>FaceInfo</em> contains the following information:</p><ul>
<li>Pave blocks that have state <b>In</b> for the face;</li>
<li>Vertices that have state <b>In</b> for the face;</li>
<li>Pave blocks that have state <b>On</b> for the face;</li>
<li>Vertices that have state <b>On</b> for the face;</li>
<li>Pave blocks built up from intersection curves for the face;</li>
<li>Vertices built up from intersection points for the face.</li>
</ul>
<div class="image">
<img src="operations_image016.svg" alt="operations_image016.svg"/>
<div class="caption">
Face Info</div></div>
<p>In the figure, for face <em>F1</em>:</p><ul>
<li>Pave blocks that have state <b>In</b> for the face: <em>PB<sub>in1</sub></em>.</li>
<li>Vertices that have state <b>In</b> for the face: <em>V<sub>in1</sub></em>.</li>
<li>Pave blocks that have state <b>On</b> for the face: <em>PB<sub>on11</sub></em>, <em>PB<sub>on12</sub></em>, <em>PB<sub>on2</sub></em>, <em>PB<sub>on31</sub></em>, <em>PB<sub>on32</sub></em>, <em>PB<sub>on4</sub></em>.</li>
<li>Vertices that have state <b>On</b> for the face: <em>V1, V2, V3, V4, V5, V6</em>.</li>
<li>Pave blocks built up from intersection curves for the face: <em>PB<sub>sc1</sub></em>.</li>
<li>Vertices built up from intersection points for the face: none</li>
</ul>
<h1><a class="anchor" id="occt_algorithms_4"></a>
Data Structure</h1>
<p>Data Structure (DS) is used to:</p><ul>
<li>Store information about input data and intermediate results;</li>
<li>Provide the access to the information;</li>
<li>Provide the links between the chunks of information.</li>
</ul>
<p>This information includes:</p><ul>
<li>Arguments;</li>
<li>Shapes;</li>
<li>Interferences;</li>
<li>Pave Blocks;</li>
<li>Common Blocks.</li>
</ul>
<p>Data Structure is implemented in the class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a></em>.</p>
<h2><a class="anchor" id="occt_algorithms_4_1"></a>
Arguments</h2>
<p>The arguments are shapes (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>):</p><ul>
<li>Number of arguments is unlimited.</li>
<li>Each argument is a valid shape (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>).</li>
<li>Each argument can be of one of the following types (see the Table):</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Type </th><th align="left">Index of Type  </th></tr>
<tr>
<td align="left">1 </td><td align="left">COMPOUND </td><td align="left">0 </td></tr>
<tr>
<td align="left">2 </td><td align="left">COMPSOLID </td><td align="left">1 </td></tr>
<tr>
<td align="left">3 </td><td align="left">SOLID </td><td align="left">2 </td></tr>
<tr>
<td align="left">4 </td><td align="left">SHELL </td><td align="left">3 </td></tr>
<tr>
<td align="left">5 </td><td align="left">FACE </td><td align="left">4 </td></tr>
<tr>
<td align="left">6 </td><td align="left">WIRE </td><td align="left">5 </td></tr>
<tr>
<td align="left">7 </td><td align="left">EDGE </td><td align="left">6 </td></tr>
<tr>
<td align="left">8 </td><td align="left">VERTEX </td><td align="left">7 </td></tr>
</table>
<ul>
<li>The argument of type <em>0 (COMPOUND)</em> can include any number of shapes of an arbitrary type (0, 1…7).</li>
<li>The argument should not be self-interfered, i.e. all sub-shapes of the argument that have geometrical coincidence through any topological entities (vertices, edges, faces) must share these entities.</li>
<li>There are no restrictions on the type of underlying geometry of the shapes. The faces or edges of arguments <em>S<sub>i</sub></em> can have underlying geometry of any type supported by Open CASCADE Technology modeling algorithms (in terms of <em>GeomAbs_CurveType</em> and <em>GeomAbs_SurfaceType</em>).</li>
<li>The faces or edges of the arguments should have underlying geometry with continuity that is not less than C1.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_4_2"></a>
Shapes</h2>
<p>The information about Shapes is stored in structure <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___shape_info.html">BOPDS_ShapeInfo</a></em>. The objects of type <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___shape_info.html">BOPDS_ShapeInfo</a></em> are stored in the container of array type. The array allows getting the access to the information by an index (DS index). The structure <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___shape_info.html">BOPDS_ShapeInfo</a></em> has the following contents:</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em>myShape</em> </td><td align="left">Shape itself </td></tr>
<tr>
<td align="left"><em>myType</em> </td><td align="left">Type of shape </td></tr>
<tr>
<td align="left"><em>myBox</em> </td><td align="left">3D bounding box of the shape </td></tr>
<tr>
<td align="left"><em>mySubShapes</em> </td><td align="left">List of DS indices of sub-shapes </td></tr>
<tr>
<td align="left"><em>myReference</em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for some auxiliary information </td></tr>
<tr>
<td align="left"><em>myFlag</em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for some auxiliary information </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_4_3"></a>
Interferences</h2>
<p>The information about interferences is stored in the instances of classes that are inherited from class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf.html">BOPDS_Interf</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf.html">BOPDS_Interf</a></em> </td><td align="left">Root class for interference </td></tr>
<tr>
<td align="left"><em>Index1</em> </td><td align="left">DS index of the shape 1 </td></tr>
<tr>
<td align="left"><em>Index2</em> </td><td align="left">DS index of the shape 2 </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_v_v.html">BOPDS_InterfVV</a></em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Vertex/Vertex interference </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_v_e.html">BOPDS_InterfVE</a></em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Vertex/Edge interference </td></tr>
<tr>
<td align="left"><em>myParam</em> </td><td align="left">The value of parameter of the point of the vertex on the curve of the edge </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_v_f.html">BOPDS_InterfVF</a></em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Vertex/Face interference </td></tr>
<tr>
<td align="left"><em>myU, myV</em> </td><td align="left">The value of parameters of the point of the vertex on the surface of the face </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_e_e.html">BOPDS_InterfEE</a></em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Edge/Edge interference </td></tr>
<tr>
<td align="left"><em>myCommonPart</em> </td><td align="left">Common part (in terms of <em>IntTools_CommonPart</em> ) </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_e_f.html">BOPDS_InterfEF</a></em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Edge/Face interference </td></tr>
<tr>
<td align="left"><em>myCommonPart</em> </td><td align="left">Common part (in terms of <em>IntTools_CommonPart</em> ) </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_f_f.html">BOPDS_InterfFF</a></em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Face/Face interference </td></tr>
<tr>
<td align="left"><em>myTolR3D, myTolR2D</em> </td><td align="left">The value of tolerances of curves (points) reached in 3D and 2D </td></tr>
<tr>
<td align="left"><em>myCurves</em> </td><td align="left">Intersection Curves (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___curve.html">BOPDS_Curve</a></em>) </td></tr>
<tr>
<td align="left"><em>myPoints</em> </td><td align="left">Intersection Points (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___point.html">BOPDS_Point</a></em>) </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_v_z.html">BOPDS_InterfVZ</a></em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Vertex/Solid interference </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_e_z.html">BOPDS_InterfEZ</a></em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Edge/Solid interference </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_f_z.html">BOPDS_InterfFZ</a></em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Face/Solid interference </td></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf_z_z.html">BOPDS_InterfZZ</a></em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_storage.html">Storage</a> for Solid/Solid interference </td></tr>
</table>
<p>The Figure shows inheritance diagram for <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___interf.html">BOPDS_Interf</a></em> classes.</p>
<div class="image">
<img src="operations_image017.svg" alt="operations_image017.svg"/>
<div class="caption">
BOPDS_Interf classes</div></div>
<h2><a class="anchor" id="occt_algorithms_4_4"></a>
Pave, PaveBlock and CommonBlock</h2>
<p>The information about the pave is stored in objects of type <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave.html">BOPDS_Pave</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave.html">BOPDS_Pave</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myIndex</em> </td><td align="left">DS index of the vertex </td></tr>
<tr>
<td align="left"><em>myParam</em> </td><td align="left">Value of the parameter of the 3D point of vertex on curve. </td></tr>
</table>
<p>The information about pave blocks is stored in objects of type <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myEdge</em> </td><td align="left">DS index of the edge produced from the pave block </td></tr>
<tr>
<td align="left"><em>myOriginalEdge</em> </td><td align="left">DS index of the source edge </td></tr>
<tr>
<td align="left"><em>myPave1</em> </td><td align="left">Pave 1 (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave.html">BOPDS_Pave</a></em>) </td></tr>
<tr>
<td align="left"><em>myPave2</em> </td><td align="left">Pave 2 (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave.html">BOPDS_Pave</a></em>) </td></tr>
<tr>
<td align="left"><em>myExtPaves</em> </td><td align="left">The list of paves (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave.html">BOPDS_Pave</a></em>) that is used to store paves lying inside the pave block during intersection process </td></tr>
<tr>
<td align="left"><em>myCommonBlock</em> </td><td align="left">The reference to common block (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___common_block.html">BOPDS_CommonBlock</a></em>) if the pave block is a common block </td></tr>
<tr>
<td align="left"><em>myShrunkData</em> </td><td align="left">The shrunk range of the pave block </td></tr>
</table>
<ul>
<li>To be bound to an edge (or intersection curve) the structures of type <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a></em> are stored in one container of list type <em>(BOPDS_ListOfPaveBlock)</em>.</li>
<li>In case of edge, all the lists of pave blocks above are stored in one container of array type. The array allows getting the access to the information by index of the list of pave blocks for the edge. This index (if exists) is stored in the field <em>myReference</em>.</li>
</ul>
<p>The information about common block is stored in objects of type <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___common_block.html">BOPDS_CommonBlock</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___common_block.html">BOPDS_CommonBlock</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myPaveBlocks</em> </td><td align="left">The list of pave blocks that are common in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_5">Common Blocks</a> </td></tr>
<tr>
<td align="left"><em>myFaces</em> </td><td align="left">The list of DS indices of the faces, on which the pave blocks lie. </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_4_5"></a>
Points and Curves</h2>
<p>The information about intersection point is stored in objects of type <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___point.html">BOPDS_Point</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___point.html">BOPDS_Point</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myPnt</em> </td><td align="left">3D point </td></tr>
<tr>
<td align="left"><em>myPnt2D1</em> </td><td align="left">2D point on the face1 </td></tr>
<tr>
<td align="left"><em>myPnt2D2</em> </td><td align="left">2D point on the face2 </td></tr>
</table>
<p>The information about intersection curve is stored in objects of type <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___curve.html">BOPDS_Curve</a></em>.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___curve.html">BOPDS_Curve</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myCurve</em> </td><td align="left">The intersection curve (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___curve.html">IntTools_Curve</a></em> ) </td></tr>
<tr>
<td align="left"><em>myPaveBlocks</em> </td><td align="left">The list of pave blocks that belong to the curve </td></tr>
<tr>
<td align="left"><em>myBox</em> </td><td align="left">The bounding box of the curve (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_bnd___box.html">Bnd_Box</a></em> ) </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_4_6"></a>
FaceInfo</h2>
<p>The information about <em>FaceInfo</em> is stored in a structure <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___face_info.html">BOPDS_FaceInfo</a></em>. The structure <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___face_info.html">BOPDS_FaceInfo</a></em> has the following contents.</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___face_info.html">BOPDS_FaceInfo</a></em> </td><td align="left"></td></tr>
<tr>
<td align="left"><em>myPaveBlocksIn</em> </td><td align="left">Pave blocks that have state In for the face </td></tr>
<tr>
<td align="left"><em>myVerticesIn</em> </td><td align="left">Vertices that have state In for the face </td></tr>
<tr>
<td align="left"><em>myPaveBlocksOn</em> </td><td align="left">Pave blocks that have state On for the face </td></tr>
<tr>
<td align="left"><em>myVerticesOn</em> </td><td align="left">Vertices that have state On for the face </td></tr>
<tr>
<td align="left"><em>myPaveBlocksSc</em> </td><td align="left">Pave blocks built up from intersection curves for the face </td></tr>
<tr>
<td align="left"><em>myVerticesSc</em> </td><td align="left">Vertices built up from intersection points for the face + </td></tr>
</table>
<p>The objects of type <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___face_info.html">BOPDS_FaceInfo</a></em> are stored in one container of array type. The array allows getting the access to the information by index. This index (if exists) is stored in the field <em>myReference</em>.</p>
<h1><a class="anchor" id="occt_algorithms_5"></a>
Intersection Part</h1>
<p>Intersection Part (IP) is used to</p><ul>
<li>Initialize the Data Structure;</li>
<li>Compute interferences between the arguments (or their sub-shapes);</li>
<li>Compute same domain vertices, edges;</li>
<li>Build split edges;</li>
<li>Build section edges;</li>
<li>Build p-curves;</li>
<li>Store all obtained information in DS.</li>
</ul>
<p>IP is implemented in the class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em>.</p>
<div class="image">
<img src="operations_image064.svg" alt="operations_image064.svg"/>
<div class="caption">
Diagram for Class BOPAlgo_PaveFiller</div></div>
<h2><a class="anchor" id="occt_algorithms_5_1a"></a>
Class BOPAlgo_Algo</h2>
<p>The class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___algo.html">BOPAlgo_Algo</a></em> provides the base interface for all algorithms to provide the possibility to:</p><ul>
<li>Get Error status;</li>
<li>Get Warning status;</li>
<li>Turn on/off the parallel processing</li>
<li>Break the operations by user request</li>
<li>Check data;</li>
<li>Check the result;</li>
<li>Set the appropriate memory allocator.</li>
</ul>
<p>The description provided in the next paragraphs is coherent with the implementation of the method <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a66f2b0461686e1439fc962ce593f8f1b">BOPAlgo_PaveFiller::Perform()</a></em>.</p>
<h2><a class="anchor" id="occt_algorithms_5_1"></a>
Initialization</h2>
<p>The input data for the step is the Arguments. The description of initialization step is shown in the Table.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialization the array of shapes (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_2">Shapes</a>). Filling the array of shapes. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#ad6a933a71ade2619f1eb08e602eddef0">BOPDS_DS::Init()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Initialization the array pave blocks (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock, CommonBlock</a>) </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#ad6a933a71ade2619f1eb08e602eddef0">BOPDS_DS::Init()</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Initialization of intersection Iterator. The intersection Iterator is the object that computes intersections between sub-shapes of the arguments in terms of bounding boxes. The intersection Iterator provides approximate number of the interferences for given type (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_1">Interferences</a>) </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Initialization of intersection Context. The intersection Context is an object that contains geometrical and topological toolkit (classifiers, projectors, etc). The intersection Context is used to cache the tools to increase the algorithm performance. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___context.html">IntTools_Context</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_2"></a>
Compute Vertex/Vertex Interferences</h2>
<p>The input data for this step is the DS after the <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_5_1">Initialization</a>. The description of this step is shown in the table :</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Vertex/Vertex interferences. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a95775245febed762df2be259dbafd780">BOPAlgo_PaveFiller::PerformVV()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nVi, nVj)k, k=0, 1…nk,</em> where <em>nVi</em> and <em>nVj</em> are DS indices of vertices <em>Vi</em> and <em>Vj</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Compute the connexity chains of interfered vertices <em>nV1C, nV2C… nVnC)k, C=0, 1…nCs</em>, where <em>nCs</em> is the number of the connexity chains </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#a5b762f243c1b4e4fb8a3b8d1af0fdabc">BOPAlgo_Tools::MakeBlocksCnx()</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Build new vertices from the chains <em>VNc. C=0, 1…nCs.</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a95775245febed762df2be259dbafd780">BOPAlgo_PaveFiller::PerformVV()</a></em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Append new vertices in DS. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#ade9d7e48618c8abcf9f5af5038b3ed41">BOPDS_DS::Append()</a></em> </td></tr>
<tr>
<td align="left">6 </td><td align="left">Append same domain vertices in DS. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a4d807c65203d618e28ae4a8984357fb5">BOPDS_DS::AddShapeSD()</a></em> </td></tr>
<tr>
<td align="left">7 </td><td align="left">Append Vertex/Vertex interferences in DS. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a0500181cdbb04d3cd769c1c4823e64d8">BOPDS_DS::AddInterf()</a></em> </td></tr>
</table>
<ul>
<li>The pairs of interfered vertices are: <em>(nV11, nV12), (nV11, nV13), (nV12, nV13), (nV13, nV15), (nV13, nV14), (nV14, nV15), (nV21, nV22), (nV21, nV23), (nV22, nV23);</em></li>
<li>These pairs produce two chains: <em>(nV11, nV12, nV13, nV14, nV15)</em> and <em>(nV21, nV22, nV23);</em></li>
<li>Each chain is used to create a new vertex, <em>VN1</em> and <em>VN2</em>, correspondingly.</li>
</ul>
<p>The example of connexity chains of interfered vertices is given in the image:</p>
<div class="image">
<img src="operations_image018.svg" alt="operations_image018.svg"/>
<div class="caption">
Connexity chains of interfered vertices</div></div>
<h2><a class="anchor" id="occt_algorithms_5_3"></a>
Compute Vertex/Edge Interferences</h2>
<p>The input data for this step is the DS after computing Vertex/Vertex interferences.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Vertex/Edge interferences </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a63ed697a5245779f3bc9d47d272b4dff">BOPAlgo_PaveFiller::PerformVE()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nVi, nEj)k k=0, 1…nk,</em> where <em>nVi</em> is DS index of vertex <em>Vi</em>, <em>nEj</em> is DS index of edge <em>Ej</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Compute paves. See <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_1_2">Vertex/Edge Interference</a> </td><td align="left"><em>BOPInt_Context::ComputeVE()</em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Initialize pave blocks for the edges <em>Ej</em> involved in the interference </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: ChangePaveBlocks()</em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Append the paves into the pave blocks in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a>:: AppendExtPave()</em> </td></tr>
<tr>
<td align="left">6 </td><td align="left">Append Vertex/Edge interferences in DS </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a0500181cdbb04d3cd769c1c4823e64d8">BOPDS_DS::AddInterf()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_4"></a>
Update Pave Blocks</h2>
<p>The input data for this step is the DS after computing Vertex/Edge Interferences.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Each pave block PB containing internal paves is split by internal paves into new pave blocks <em>PBN1, PBN2… PBNn</em>. PB is replaced by new pave blocks <em>PBN1, PBN2… PBNn</em> in the DS. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: UpdatePaveBlocks()</em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_5"></a>
Compute Edge/Edge Interferences</h2>
<p>The input data for this step is the DS after updating Pave Blocks.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Edge/Edge interferences </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a90d5d76118f0bf78dda22e36940d999d">BOPAlgo_PaveFiller::PerformEE()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nEi, nEj)k, k=0, 1…nk,</em> where <em>nEi</em> is DS index of the edge <em>Ei</em>, <em>nEj</em> is DS index of the edge <em>Ej</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Initialize pave blocks for the edges involved in the interference, if it is necessary. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: ChangePaveBlocks()</em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Access to the pave blocks of interfered shapes: <em>(PBi1, PBi2…PBiNi)</em> for edge <em>Ei</em> and <em>(PBj1, PBj2…PBjNj)</em> for edge <em>Ej</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a90d5d76118f0bf78dda22e36940d999d">BOPAlgo_PaveFiller::PerformEE()</a></em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Compute shrunk data for pave blocks in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a>, if it is necessary. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#abbe351dbd04cf236c2ac9577bf9a8935">BOPAlgo_PaveFiller::FillShrunkData()</a></em> </td></tr>
<tr>
<td align="left">6 </td><td align="left">Compute Edge/Edge interference for pave blocks <em>PBix</em> and <em>PBiy</em>. The result of the computation is a set of objects of type <em>IntTools_CommonPart</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___edge_edge.html">IntTools_EdgeEdge</a></em> </td></tr>
<tr>
<td align="left">7.1 </td><td align="left">For each <em>CommonPart</em> of type <em>VERTEX:</em> Create new vertices <em>VNi (i =1, 2…,NbVN),</em> where <em>NbVN</em> is the number of new vertices. Intersect the vertices <em>VNi</em> using the steps Initialization and compute Vertex/Vertex interferences as follows: a) create a new object <em>PFn</em> of type <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> with its own DS; b) use new vertices <em>VNi (i=1, 2…,NbVN), NbVN</em> as arguments (in terms of <em>TopoDs_Shape</em>) of <em>PFn</em>; c) invoke method <em>Perform()</em> for <em>PFn</em>. The resulting vertices <em>VNXi (i=1, 2…,NbVNX)</em>, where <em>NbVNX</em> is the number of vertices, are obtained via mapping between <em>VNi</em> and the results of <em>PVn</em>. </td><td align="left"><em>BOPTools_Tools::MakeNewVertex()</em> </td></tr>
<tr>
<td align="left">7.2 </td><td align="left">For each <em>CommonPart</em> of type <em>EDGE:</em> Compute the coinciding connexity chains of pave blocks <em>(PB1C, PB2C… PNnC)k, C=0, 1…nCs,</em> where <em>nCs</em> is the number of the connexity chains. Create common blocks <em>(CBc. C=0, 1…nCs)</em> from the chains. Attach the common blocks to the pave blocks. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#a44feae937896a9b01d2c9d4dd094f6d2">BOPAlgo_Tools::PerformCommonBlocks()</a></em> </td></tr>
<tr>
<td align="left">8 </td><td align="left">Post-processing. Append the paves of <em>VNXi</em> into the corresponding pave blocks in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a>:: AppendExtPave()</em> </td></tr>
<tr>
<td align="left">9 </td><td align="left">Split common blocks CBc by the paves. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: UpdateCommonBlock()</em> </td></tr>
<tr>
<td align="left">10 </td><td align="left">Append Edge/Edge interferences in the DS. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a0500181cdbb04d3cd769c1c4823e64d8">BOPDS_DS::AddInterf()</a></em> </td></tr>
</table>
<p>The example of coinciding chains of pave blocks is given in the image:</p>
<div class="image">
<img src="operations_image019.png" alt="operations_image019.png"/>
<div class="caption">
Coinciding chains of pave blocks</div></div>
<ul>
<li>The pairs of coincided pave blocks are: <em>(PB11, PB12), (PB11, PB13), (PB12, PB13), (PB21, PB22), (PB21, PB23), (PB22, PB23).</em></li>
<li>The pairs produce two chains: <em>(PB11, PB12, PB13)</em> and <em>(PB21, PB22, PB23).</em></li>
</ul>
<h2><a class="anchor" id="occt_algorithms_5_6"></a>
Compute Vertex/Face Interferences</h2>
<p>The input data for this step is the DS after computing Edge/Edge interferences.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Vertex/Face interferences </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a0049cfb42c99121aea8210aca7b56d4a">BOPAlgo_PaveFiller::PerformVF()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nVi, nFj)k, k=0, 1…nk,</em> where <em>nVi</em> is DS index of the vertex <em>Vi</em>, <em>nFj</em> is DS index of the edge <em>Fj</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Compute interference See <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_1_3">Vertex/Face Interference</a> </td><td align="left"><em>BOPInt_Context::ComputeVF()</em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Append Vertex/Face interferences in the DS </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a0500181cdbb04d3cd769c1c4823e64d8">BOPDS_DS::AddInterf()</a></em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Repeat steps 2-4 for each new vertex <em>VNXi (i=1, 2…,NbVNX),</em> where <em>NbVNX</em> is the number of vertices. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a0b7b989548e66b8652e0722b174cbfc2">BOPAlgo_PaveFiller::TreatVerticesEE()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_7"></a>
Compute Edge/Face Interferences</h2>
<p>The input data for this step is the DS after computing Vertex/Face Interferences.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Edge/Face interferences </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a5b4b627143139e1919913b4e4c529c65">BOPAlgo_PaveFiller::PerformEF()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nEi, nFj)k, k=0, 1…nk,</em> where <em>nEi</em> is DS index of edge <em>Ei</em>, <em>nFj</em> is DS index of face <em>Fj</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Initialize pave blocks for the edges involved in the interference, if it is necessary. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a9c95db5ed7debabb761f2fa3051bfbd8">BOPDS_DS::ChangePaveBlocks()</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Access to the pave blocks of interfered edge <em>(PBi1, PBi2…PBiNi)</em> for edge <em>Ei</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a5b4b627143139e1919913b4e4c529c65">BOPAlgo_PaveFiller::PerformEF()</a></em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Compute shrunk data for pave blocks (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a>) if it is necessary. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#abbe351dbd04cf236c2ac9577bf9a8935">BOPAlgo_PaveFiller::FillShrunkData()</a></em> </td></tr>
<tr>
<td align="left">6 </td><td align="left">Compute Edge/Face interference for pave block <em>PBix</em>, and face <em>nFj</em>. The result of the computation is a set of objects of type <em>IntTools_CommonPart</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___edge_face.html">IntTools_EdgeFace</a></em> </td></tr>
<tr>
<td align="left">7.1 </td><td align="left">For each <em>CommonPart</em> of type <em>VERTEX:</em> Create new vertices <em>VNi (i=1, 2…,NbVN),</em> where <em>NbVN</em> is the number of new vertices. Merge vertices <em>VNi</em> as follows: a) create new object <em>PFn</em> of type <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> with its own DS; b) use new vertices <em>VNi (i=1, 2…,NbVN), NbVN</em> as arguments (in terms of <em>TopoDs_Shape</em>) of <em>PFn</em>; c) invoke method <em>Perform()</em> for <em>PFn</em>. The resulting vertices <em>VNXi (i=1, 2…,NbVNX)</em>, where <em>NbVNX</em> is the number of vertices, are obtained via mapping between <em>VNi</em> and the results of <em>PVn</em>. </td><td align="left"><em>BOPTools_Tools::MakeNewVertex()</em> and <em>BOPAlgo_PaveFiller::PerformVertices1()</em> </td></tr>
<tr>
<td align="left">7.2 </td><td align="left">For each <em>CommonPart</em> of type <em>EDGE:</em> Create common blocks <em>(CBc. C=0, 1…nCs)</em> from pave blocks that lie on the faces. Attach the common blocks to the pave blocks. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___tools.html#a44feae937896a9b01d2c9d4dd094f6d2">BOPAlgo_Tools::PerformCommonBlocks()</a></em> </td></tr>
<tr>
<td align="left">8 </td><td align="left">Post-processing. Append the paves of <em>VNXi</em> into the corresponding pave blocks in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html">BOPDS_PaveBlock</a>:: AppendExtPave()</em> </td></tr>
<tr>
<td align="left">9 </td><td align="left">Split pave blocks and common blocks <em>CBc</em> by the paves. </td><td align="left"><em>BOPAlgo_PaveFiller::PerformVertices1()</em>, <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: UpdatePaveBlock()</em> and <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: UpdateCommonBlock()</em> </td></tr>
<tr>
<td align="left">10 </td><td align="left">Append Edge/Face interferences in the DS </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a0500181cdbb04d3cd769c1c4823e64d8">BOPDS_DS::AddInterf()</a></em> </td></tr>
<tr>
<td align="left">11 </td><td align="left">Update <em>FaceInfo</em> for all faces having EF common parts. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a>:: UpdateFaceInfoIn()</em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_8"></a>
Build Split Edges</h2>
<p>The input data for this step is the DS after computing Edge/Face Interferences.</p>
<p>For each pave block <em>PB</em> take the following steps:</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Get the real pave block <em>PBR</em>, which is equal to <em>PB</em> if <em>PB</em> is not a common block and to <em>PB<sub>1</sub></em> if <em>PB</em> is a common block. <em>PB<sub>1</sub></em> is the first pave block in the pave blocks list of the common block. See <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_4">Pave, PaveBlock and CommonBlock</a>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#ab9015dbaf4de8632ac8bb9b019f0b53c">BOPAlgo_PaveFiller::MakeSplitEdges()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Build the split edge <em>Esp</em> using the information from <em>DS</em> and <em>PBR</em>. </td><td align="left"><em>BOPTools_Tools::MakeSplitEdge()</em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Compute <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___shape_info.html">BOPDS_ShapeInfo</a></em> contents for Esp </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#ab9015dbaf4de8632ac8bb9b019f0b53c">BOPAlgo_PaveFiller::MakeSplitEdges()</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Append <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___shape_info.html">BOPDS_ShapeInfo</a></em> contents to the DS </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#ade9d7e48618c8abcf9f5af5038b3ed41">BOPDS_DS::Append()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_9"></a>
Compute Face/Face Interferences</h2>
<p>The input data for this step is DS after building Split Edges.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Initialize array of Face/Face interferences </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a5a78c6c9eb221d7364688a5a4e9e41c4">BOPAlgo_PaveFiller::PerformFF()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Access to the pairs of interfered shapes <em>(nFi, nFj)k, k=0, 1…nk,</em> where <em>nFi</em> is DS index of edge <em>Fi</em>, <em>nFj</em> is DS index of face <em>Fj</em> and <em>nk</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___iterator.html">BOPDS_Iterator</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Compute Face/Face interference </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_tools___face_face.html">IntTools_FaceFace</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Append Face/Face interferences in the DS. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html#a0500181cdbb04d3cd769c1c4823e64d8">BOPDS_DS::AddInterf()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_10"></a>
Build Section Edges</h2>
<p>The input data for this step is the DS after computing Face/Face interferences.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For each Face/Face interference <em>nFi, nFj</em>, retrieve <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_6">FaceInfo</a>. Create draft vertices from intersection points <em>VPk (k=1, 2…, NbVP)</em>, where <em>NbVP</em> is the number of new vertices, and the draft vertex <em>VPk</em> is created from an intersection point if <em>VPk ≠ Vm (m = 0, 1, 2… NbVm)</em>, where <em>Vm</em> is an existing vertex for the faces <em>nFi</em> and <em>nF,j</em> (<em>On</em> or <em>In</em> in terms of <em>TopoDs_Shape</em>), <em>NbVm</em> is the number of vertices existing on faces <em>nFi</em> and <em>nF,j</em> and ≠ &ndash; means non-coincidence in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_1_1">Vertex/Vertex interference</a>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#ae437042368bb06c5270e2c42be349dc4">BOPAlgo_PaveFiller::MakeBlocks()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">For each intersection curve <em>Cijk</em> </td><td align="left"></td></tr>
<tr>
<td align="left">2.1 </td><td align="left">Create paves PVc for the curve using existing vertices, i.e. vertices On or In (in terms of <em>FaceInfo</em>) for faces <em>nFi</em> and <em>nFj</em>. Append the paves <em>PVc</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a902115f00695017538131bec58953c9e">BOPAlgo_PaveFiller::PutPaveOnCurve()</a></em> and <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___pave_block.html#a7881c79ee0554ed227b103f860c4661e">BOPDS_PaveBlock::AppendExtPave()</a></em> </td></tr>
<tr>
<td align="left">2.2 </td><td align="left">Create technological vertices <em>Vt</em>, which are the bounding points of an intersection curve (with the value of tolerance <em>Tol(Cijk)</em>). Each vertex <em>Vt</em> with parameter <em>Tt</em> on curve <em>Cijk</em> forms pave <em>PVt</em> on curve <em>Cijk</em>. Append technological paves. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#ab73e223604ba7e19c7885a5c3fa64f43">BOPAlgo_PaveFiller::PutBoundPaveOnCurve()</a></em> </td></tr>
<tr>
<td align="left">2.3 </td><td align="left">Create pave blocks <em>PBk</em> for the curve using paves <em>(k=1, 2…, NbPB)</em>, where <em>NbPB</em> is the number of pave blocks </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#ae437042368bb06c5270e2c42be349dc4">BOPAlgo_PaveFiller::MakeBlocks()</a></em> </td></tr>
<tr>
<td align="left">2.4 </td><td align="left">Build draft section edges <em>ESk</em> using the pave blocks <em>(k=1, 2…, NbES)</em>, where <em>NbES</em> is the number of draft section edges The draft section edge is created from a pave block <em>PBk</em> if <em>PBk</em> has state <em>In</em> or <em>On</em> for both faces <em>nFi</em> and <em>nF,j</em> and <em>PBk ≠ PBm (m=0, 1, 2… NbPBm)</em>, where <em>PBm</em> is an existing pave block for faces <em>nFi</em> and <em>nF,j</em> (<em>On</em> or <em>In</em> in terms of <em>FaceInfo</em>), <em>NbVm</em> is the number of existing pave blocks for faces <em>nFi</em> and <em>nF,j</em> and ≠ &ndash; means non-coincidence (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_3_1_3">Vertex/Face interference</a>). </td><td align="left"><em>BOPTools_Tools::MakeEdge()</em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Intersect the draft vertices <em>VPk (k=1, 2…, NbVP)</em> and the draft section edges <em>ESk (k=1, 2…, NbES)</em>. For this: a) create new object <em>PFn</em> of type <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> with its own DS; b) use vertices <em>VPk</em> and edges <em>ESk</em> as arguments (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4_1">Arguments</a>) of <em>PFn</em>; c) invoke method <em>Perform()</em> for <em>PFn</em>. Resulting vertices <em>VPXk (k=1, 2… NbVPX)</em> and edges <em>ESXk (k=1, 2… NbESX)</em> are obtained via mapping between <em>VPk, ESk</em> and the results of <em>PVn</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a7f472f0ae7a58e0c2549419007325410">BOPAlgo_PaveFiller::PostTreatFF()</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Update face info (sections about pave blocks and vertices) </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a5a78c6c9eb221d7364688a5a4e9e41c4">BOPAlgo_PaveFiller::PerformFF()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_11"></a>
Build P-Curves</h2>
<p>The input data for this step is the DS after building section edges.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For each Face/Face interference <em>nFi</em> and <em>nFj</em> build p-Curves on <em>nFi</em> and <em>nFj</em> for each section edge <em>ESXk</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a7266445de539b14948858de09164d4cc">BOPAlgo_PaveFiller::MakePCurves()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">For each pave block that is common for faces <em>nFi</em> and <em>nFj</em> build p-Curves on <em>nFi</em> and <em>nFj</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a7266445de539b14948858de09164d4cc">BOPAlgo_PaveFiller::MakePCurves()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_5_12"></a>
Process Degenerated Edges</h2>
<p>The input data for this step is the DS after building P-curves.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left"></td><td align="left">For each degenerated edge <em>ED</em> having vertex <em>VD</em> </td><td align="left"><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#acd3898a140a2d24f4e46d7cdda808080">BOPAlgo_PaveFiller::ProcessDE()</a> </td></tr>
<tr>
<td align="left">1 </td><td align="left">Find pave blocks <em>PBi (i=1,2… NbPB)</em>, where <em>NbPB</em> is the number of pave blocks, that go through vertex <em>VD</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#acd188295f84cd75343734591171ebfce">BOPAlgo_PaveFiller::FindPaveBlocks()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Compute paves for the degenerated edge <em>ED</em> using a 2D curve of <em>ED</em> and a 2D curve of <em>PBi</em>. Form pave blocks <em>PBDi (i=1,2… NbPBD)</em>, where <em>NbPBD</em> is the number of the pave blocks for the degenerated edge <em>ED</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html#a71e42c2f47f024ca885ae09151645ba5">BOPAlgo_PaveFiller::FillPaves()</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Build split edges <em>ESDi (i=1,2…NbESD)</em>, where <em>ESD</em> is the number of split edges, using the pave blocks <em>PBDi</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a>:: MakeSplitEdge()</em> </td></tr>
</table>
<h1><a class="anchor" id="occt_algorithms_6"></a>
General description of the Building Part</h1>
<p>Building Part (BP) is used to</p><ul>
<li>Build the result of the operation</li>
<li>Provide history information (in terms of <em>::Generated(), ::Modified()</em> and <em>::IsDeleted()</em>) BP uses the DS prepared by <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> described at chapter 5 as input data. BP is implemented in the following classes:</li>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> &ndash; for the General Fuse operator (GFA).</li>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a></em> &ndash; for the Boolean Operation operator (BOA).</li>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___section.html">BOPAlgo_Section</a></em> &ndash; for the Section operator (SA).</li>
</ul>
<div class="image">
<img src="operations_image020.svg" alt="operations_image020.svg"/>
<div class="caption">
Diagram for BP classes</div></div>
<p>The class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder_shape.html">BOPAlgo_BuilderShape</a></em> provides the interface for algorithms that have:</p><ul>
<li>A Shape as the result;</li>
<li>History information (in terms of <em>::Generated(), ::Modified()</em> and <em>::IsDeleted()).</em></li>
</ul>
<h1><a class="anchor" id="occt_algorithms_7"></a>
General Fuse Algorithm</h1>
<h2><a class="anchor" id="occt_algorithms_7_1"></a>
Arguments</h2>
<p>The arguments of the algorithm are shapes (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>). The main requirements for the arguments are described in <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4">Data Structure</a> chapter.</p>
<h2><a class="anchor" id="occt_algorithms_7_2"></a>
Results</h2>
<p>During the operation argument <em>Si</em> can be split into several parts <em>Si1, Si2… Si1NbSp</em>, where <em>NbSp</em> is the number of parts. The set <em>(Si1, Si2… Si1NbSp)</em> is an image of argument <em>Si</em>.</p><ul>
<li>The result of the General Fuse operation is a compound. Each sub-shape of the compound corresponds to the certain argument shape S1, S2…Sn and has shared sub-shapes in accordance with interferences between the arguments.</li>
<li>For the arguments of the type EDGE, FACE, SOLID the result contains split parts of the argument.</li>
<li>For the arguments of the type WIRE, SHELL, COMPSOLID, COMPOUND the result contains the image of the shape of the corresponding type (i.e. WIRE, SHELL, COMPSOLID or COMPOUND). The types of resulting shapes depend on the type of the corresponding argument participating in the operation. See the table below:</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Type of argument </th><th align="left">Type of resulting shape </th><th align="left">Comments  </th></tr>
<tr>
<td align="left">1 </td><td align="left">COMPOUND </td><td align="left">COMPOUND </td><td align="left">The resulting COMPOUND is built from images of sub-shapes of type COMPOUND COMPSOLID, SHELL, WIRE and VERTEX. Sets of split sub-shapes of type SOLID, FACE, EDGE. </td></tr>
<tr>
<td align="left">2 </td><td align="left">COMPSOLID </td><td align="left">COMPSOLID </td><td align="left">The resulting COMPSOLID is built from split SOLIDs. </td></tr>
<tr>
<td align="left">3 </td><td align="left">SOLID </td><td align="left">Set of split SOLIDs </td><td align="left"></td></tr>
<tr>
<td align="left">4 </td><td align="left">SHELL </td><td align="left">SHELL </td><td align="left">The resulting SHELL is built from split FACEs </td></tr>
<tr>
<td align="left">5 </td><td align="left">FACE </td><td align="left">Set of split FACEs </td><td align="left"></td></tr>
<tr>
<td align="left">6 </td><td align="left">WIRE </td><td align="left">WIRE </td><td align="left">The resulting WIRE is built from split EDGEs </td></tr>
<tr>
<td align="left">7 </td><td align="left">EDGE </td><td align="left">Set of split EDGEs </td><td align="left"></td></tr>
<tr>
<td align="left">8 </td><td align="left">VERTEX </td><td align="left">VERTEX </td><td align="left"></td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_7_3"></a>
Examples</h2>
<p>Please, have a look at the examples, which can help to better understand the definitions.</p>
<h3><a class="anchor" id="occt_algorithms_7_3_1"></a>
Case 1: Three edges intersecting at a point</h3>
<p>Let us consider three edges: <em>E1, E2</em> and <em>E3</em> that intersect in one 3D point.</p>
<div class="image">
<img src="operations_image021.svg" alt="operations_image021.svg"/>
<div class="caption">
Three Intersecting Edges</div></div>
<p>The result of the GFA operation is a compound containing 6 new edges: <em>E11, E12, E21, E22, E31</em>, and <em>E32</em>. These edges have one shared vertex <em>Vn1</em>.</p>
<p>In this case:</p><ul>
<li>The argument edge <em>E1</em> has resulting split edges <em>E11</em> and <em>E12</em> (image of <em>E1</em>).</li>
<li>The argument edge <em>E2</em> has resulting split edges <em>E21</em> and <em>E22</em> (image of <em>E2</em>).</li>
<li>The argument edge <em>E3</em> has resulting split edges <em>E31</em> and <em>E32</em> (image of <em>E3</em>).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_2"></a>
Case 2: Two wires and an edge</h3>
<p>Let us consider two wires <em>W1 (Ew11, Ew12, Ew13)</em> and <em>W2 (Ew21, Ew22, Ew23)</em> and edge <em>E1</em>.</p>
<div class="image">
<img src="operations_image022.svg" alt="operations_image022.svg"/>
<div class="caption">
Two wires and an edge</div></div>
<p>The result of the GF operation is a compound consisting of 2 wires: <em>Wn1 (Ew11, En1, En2, En3, Ew13)</em> and <em>Wn2 (Ew21, En2, En3, En4, Ew23)</em> and two edges: <em>E11</em> and <em>E12</em>.</p>
<p>In this case :</p><ul>
<li>The argument <em>W1</em> has image <em>Wn1</em>.</li>
<li>The argument <em>W2</em> has image <em>Wn2</em>.</li>
<li>The argument edge <em>E1</em> has split edges <em>E11</em> and <em>E12</em>. (image of <em>E1</em>). The edges <em>En1, En2, En3, En4</em> and vertex <em>Vn1</em> are new shapes created during the operation. Edge <em>Ew12</em> has split edges <em>En1, En2</em> and <em>En3</em> and edge <em>Ew22</em> has split edges <em>En2, En3</em> and <em>En4</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_3"></a>
Case 3: An edge intersecting with a face</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em>:</p>
<div class="image">
<img src="operations_image023.svg" alt="operations_image023.svg"/>
<div class="caption">
An edge intersecting with a face</div></div>
<p>The result of the GF operation is a compound consisting of 3 shapes:</p><ul>
<li>Split edge parts <em>E11</em> and <em>E12</em> (image of <em>E1</em>).</li>
<li>New face <em>F21</em> with internal edge <em>E12</em> (image of <em>F2</em>).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_4"></a>
Case 4: An edge lying on a face</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em>:</p>
<div class="image">
<img src="operations_image024.svg" alt="operations_image024.svg"/>
<div class="caption">
An edge lying on a face</div></div>
<p>The result of the GF operation is a compound consisting of 5 shapes:</p><ul>
<li>Split edge parts <em>E11, E12</em> and <em>E13</em> (image of <em>E1</em>).</li>
<li>Split face parts <em>F21</em> and <em>F22</em> (image of <em>F2</em>).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_5"></a>
Case 5: An edge and a shell</h3>
<p>Let us consider edge <em>E1</em> and shell <em>Sh2</em> that consists of 2 faces: <em>F21</em> and <em>F22</em></p>
<div class="image">
<img src="operations_image025.svg" alt="operations_image025.svg"/>
<div class="caption">
An edge and a shell</div></div>
<p>The result of the GF operation is a compound consisting of 5 shapes:</p><ul>
<li>Split edge parts <em>E11, E12 , E13</em> and <em>E14</em> (image of <em>E1</em>).</li>
<li>Image shell <em>Sh21</em> (that contains split face parts <em>F211, F212, F221</em> and <em>F222</em>).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_6"></a>
Case 6: A wire and a shell</h3>
<p>Let us consider wire <em>W1 (E1, E2, E3, E4)</em> and shell <em>Sh2 (F21, F22)</em>. </p><div class="image">
<img src="operations_image026.svg" alt="operations_image026.svg"/>
<div class="caption">
A wire and a shell</div></div>
<p>The result of the GF operation is a compound consisting of 2 shapes:</p>
<ul>
<li>Image wire <em>W11</em> that consists of split edge parts from wire <em>W1: E11, E12, E13</em> and <em>E14</em>.</li>
<li>Image shell <em>Sh21</em> that contains split face parts: <em>F211, F212, F213, F221, F222</em> and <em>F223</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_7"></a>
Case 7: Three faces</h3>
<p>Let us consider 3 faces: <em>F1, F2</em> and <em>F3</em>. </p><div class="image">
<img src="operations_image027.png" alt="operations_image027.png"/>
<div class="caption">
Three faces</div></div>
<p>The result of the GF operation is a compound consisting of 7 shapes:</p><ul>
<li>Split face parts: <em>Fn1, Fn2, Fn3, Fn4, Fn5, Fn6</em> and <em>Fn7</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_8"></a>
Case 8: A face and a shell</h3>
<p>Let us consider shell <em>Sh1 (F11, F12, F13)</em> and face <em>F2</em>. </p><div class="image">
<img src="operations_image028.png" alt="operations_image028.png"/>
<div class="caption">
A face and a shell</div></div>
<p>The result of the GF operation is a compound consisting of 4 shapes:</p><ul>
<li>Image shell <em>Sh11</em> that consists of split face parts from shell <em>Sh1: Fn1, Fn2, Fn3, Fn4, Fn5</em> and <em>Fn6</em>.</li>
<li>Split parts of face <em>F2: Fn3, Fn6</em> and <em>Fn7</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_9"></a>
Case 9: A shell and a solid</h3>
<p>Let us consider shell <em>Sh1 (F11, F12…F16)</em> and solid <em>So2</em>. </p><div class="image">
<img src="operations_image029.png" alt="operations_image029.png"/>
<div class="caption">
A shell and a solid: arguments</div></div>
<p>The result of the GF operation is a compound consisting of 2 shapes:</p><ul>
<li>Image shell <em>Sh11</em> consisting of split face parts of <em>Sh1: Fn1, Fn2 ... Fn8.</em></li>
<li>Solid <em>So21</em> with internal shell. (image of <em>So2</em>). <div class="image">
<img src="operations_image030.png" alt="operations_image030.png"/>
<div class="caption">
A shell and a solid: results</div></div>
</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_3_10"></a>
Case 10: A compound and a solid</h3>
<p>Let us consider compound <em>Cm1</em> consisting of 2 solids <em>So11</em> and <em>So12</em>) and solid <em>So2</em>. </p><div class="image">
<img src="operations_image031.png" alt="operations_image031.png"/>
<div class="caption">
A compound and a solid: arguments</div></div>
<p>The result of the GF operation is a compound consisting of 4 shapes:</p><ul>
<li>Image compound <em>Cm11</em> consisting of split solid parts from <em>So11</em> and <em>So12 (Sn1, Sn2, Sn3, Sn4)</em>.</li>
<li>Split parts of solid <em>So2 (Sn2, Sn3, Sn5)</em>.</li>
</ul>
<div class="image">
<img src="operations_image032.png" alt="operations_image032.png"/>
<div class="caption">
A compound and a solid: results</div></div>
<h2><a class="anchor" id="occt_algorithms_7_4"></a>
Class BOPAlgo_Builder</h2>
<p>GFA is implemented in the class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em>.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_1"></a>
Fields</h3>
<p>The main fields of the class are described in the Table:</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em>myPaveFiller</em> </td><td align="left">Pointer to the <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> object </td></tr>
<tr>
<td align="left"><em>myDS</em> </td><td align="left">Pointer to the <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_d_s___d_s.html">BOPDS_DS</a></em> object </td></tr>
<tr>
<td align="left"><em>myContext</em> </td><td align="left">Pointer to the intersection Context </td></tr>
<tr>
<td align="left"><em>myImages</em> </td><td align="left">The Map between the source shape and its images </td></tr>
<tr>
<td align="left"><em>myShapesSD</em> </td><td align="left">The Map between the source shape (or split part of source shape) and the shape (or part of shape) that will be used in result due to same domain property. </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_2"></a>
Initialization</h3>
<p>The input data for this step is a <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em> object (in terms of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_5">Intersection</a>) at the state after <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_5_12">Processing of degenerated edges</a> with the corresponding DS.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Check the readiness of the DS and <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a367b325c4291426a548b6241e12ffa72">BOPAlgo_Builder::CheckData()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Build an empty result of type Compound. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#ad05584aee958fac60be8f4b46c52b9c6">BOPAlgo_Builder::Prepare()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_3"></a>
Build Images for Vertices</h3>
<p>The input data for this step is <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after Initialisation.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Fill <em>myShapesSD</em> by SD vertices using the information from the DS. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a610c88dc6d7e6d033f33d666c225cd6e">BOPAlgo_Builder::FillImagesVertices()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_4"></a>
Build Result of Type Vertex</h3>
<p>The input data for this step is <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building images for vertices and <em>Type</em>, which is the shape type (<em>TopAbs_VERTEX</em>).</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For the arguments of type <em>Type</em>. If there is an image for the argument: add the image to the result. If there is no image for the argument: add the argument to the result. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a35e7b66b12c814dc8ba59cd5ea020cae">BOPAlgo_Builder::BuildResult()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_5"></a>
Build Images for Edges</h3>
<p>The input data for this step is <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a> object</em> after building result of type vertex.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For all pave blocks in the DS. Fill <em>myImages</em> for the original edge <em>E</em> by split edges <em>ESPi</em> from pave blocks. In case of common blocks on edges, use edge <em>ESPSDj</em> that corresponds to the leading pave block and fill <em>myShapesSD</em> by the pairs <em>ESPi/ESPSDj</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a6032601163af5e2effd59a4e6987fc40">BOPAlgo_Builder::FillImagesEdges()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_6"></a>
Build Result of Type Edge</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a>, but for the type <em>Edge</em>.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_7"></a>
Build Images for Wires</h3>
<p>The input data for this step is:</p><ul>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type <em>Edge</em>;</li>
<li>Original Shape &ndash; Wire</li>
<li><em>Type</em> &ndash; the shape type <em>(TopAbs_WIRE).</em></li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For all arguments of the type <em>Type</em>. Create a container C of the type <em>Type</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#ac36f1bd699637355305a62a0d4d0cf0f">BOPAlgo_Builder::FillImagesContainers()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Add to C the images or non-split parts of the <em>Original Shape</em>, taking into account its orientation. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#ac36f1bd699637355305a62a0d4d0cf0f">BOPAlgo_Builder::FillImagesContainers()</a></em> <em>BOPTools_Tools::IsSplitToReverse()</em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Fill <em>myImages</em> for the <em>Original Shape</em> by the information above. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#ac36f1bd699637355305a62a0d4d0cf0f">BOPAlgo_Builder::FillImagesContainers()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_8"></a>
Build Result of Type Wire</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a> but for the type <em>Wire</em>.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_9"></a>
Build Images for Faces</h3>
<p>The input data for this step is <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type <em>Wire</em>.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Build Split Faces for all interfered DS shapes <em>Fi</em> of type <em>FACE</em>. </td><td align="left"></td></tr>
<tr>
<td align="left">1.1 </td><td align="left">Collect all edges or their images of <em>Fi(ESPij)</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#adad51fcad401f405a2db97d6a7bdd7cb">BOPAlgo_Builder::BuildSplitFaces()</a></em> </td></tr>
<tr>
<td align="left">1.2 </td><td align="left">Impart to ESPij the orientation to be coherent with the original one. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#adad51fcad401f405a2db97d6a7bdd7cb">BOPAlgo_Builder::BuildSplitFaces()</a></em> </td></tr>
<tr>
<td align="left">1.3 </td><td align="left">Collect all section edges <em>SEk</em> for <em>Fi</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#adad51fcad401f405a2db97d6a7bdd7cb">BOPAlgo_Builder::BuildSplitFaces()</a></em> </td></tr>
<tr>
<td align="left">1.4 </td><td align="left">Build split faces for <em>Fi (Fi1, Fi2…FiNbSp)</em>, where <em>NbSp</em> is the number of split parts (see <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_2">Building faces from a set of edges</a> for more details). </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder_face.html">BOPAlgo_BuilderFace</a></em> </td></tr>
<tr>
<td align="left">1.5 </td><td align="left">Impart to <em>(Fi1, Fi2…FiNbSp)</em> the orientation coherent with the original face <em>Fi</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#adad51fcad401f405a2db97d6a7bdd7cb">BOPAlgo_Builder::BuildSplitFaces()</a></em> </td></tr>
<tr>
<td align="left">1.6 </td><td align="left">Fill the map mySplits with <em>Fi/(Fi1, Fi2…FiNbSp)</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#adad51fcad401f405a2db97d6a7bdd7cb">BOPAlgo_Builder::BuildSplitFaces()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Fill Same Domain faces </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces</a></em> </td></tr>
<tr>
<td align="left">2.1 </td><td align="left">Find and collect in the contents of <em>mySplits</em> the pairs of same domain split faces <em>(Fij, Fkl)m</em>, where <em>m</em> is the number of pairs. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces</a></em> <em>BOPTools_Tools::AreFacesSameDomain()</em> </td></tr>
<tr>
<td align="left">2.2 </td><td align="left">Compute the connexity chains 1) of same domain faces <em>(F1C, F2C… FnC)k, C=0, 1…nCs,</em> where <em>nCs</em> is the number of connexity chains. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces()</a></em> </td></tr>
<tr>
<td align="left">2.3 </td><td align="left">Fill <em>myShapesSD</em> using the chains <em>(F1C, F2C… FnC)k</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces()</a></em> </td></tr>
<tr>
<td align="left">2.4 </td><td align="left">Add internal vertices to split faces. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces()</a></em> </td></tr>
<tr>
<td align="left">2.5 </td><td align="left">Fill <em>myImages</em> using <em>myShapesSD</em> and <em>mySplits</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a5b1a2604b2b4c38e4f1a26f9f8b6fb46">BOPAlgo_Builder::FillSameDomainFaces()</a></em> </td></tr>
</table>
<p>The example of chains of same domain faces is given in the image:</p>
<div class="image">
<img src="operations_image033.svg" alt="operations_image033.svg"/>
<div class="caption">
Chains of same domain faces</div></div>
<ul>
<li>The pairs of same domain faces are: <em>(F11, F21), (F22, F31), (F41, F51) , (F41, F6)</em> and <em>(F51, F6)</em>.</li>
<li>The pairs produce the three chains: <em>(F11, F21), (F22, F31)</em> and <em>(F41, F51, F6)</em>.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_7_4_10"></a>
Build Result of Type Face</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a> but for the type <em>Face</em>.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_11"></a>
Build Images for Shells</h3>
<p>The input data for this step is:</p><ul>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type face;</li>
<li><em>Original Shape</em> &ndash; a Shell;</li>
<li><em>Type</em> &ndash; the type of the shape <em>(TopAbs_SHELL)</em>.</li>
</ul>
<p>The procedure is the same as for building images for wires.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_12"></a>
Build Result of Type Shell</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a> but for the type <em>Shell</em>.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_13"></a>
Build Images for Solids</h3>
<p>The input data for this step is <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type <em>Shell</em>.</p>
<p>The following procedure is executed for all interfered DS shapes <em>Si</em> of type <em>SOLID</em>.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Collect all images or non-split parts for all faces <em>(FSPij)</em> that have 3D state <em>In Si</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a05520cca1eae9118325b4d1bcee56941">BOPAlgo_Builder::FillIn3DParts</a> ()</em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Collect all images or non-split parts for all faces of <em>Si</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#af1cc7589a891986d115b93aecb2eb95d">BOPAlgo_Builder::BuildSplitSolids()</a></em> </td></tr>
<tr>
<td align="left">3 </td><td align="left">Build split solids for <em>Si -&gt; (Si1, Si2…SiNbSp)</em>, where <em>NbSp</em> is the number of split parts (see <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_2">Building faces from a set of edges</a> for more details) </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder_solid.html">BOPAlgo_BuilderSolid</a></em> </td></tr>
<tr>
<td align="left">4 </td><td align="left">Fill the map Same Domain solids <em>myShapesSD</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#af1cc7589a891986d115b93aecb2eb95d">BOPAlgo_Builder::BuildSplitSolids()</a></em> </td></tr>
<tr>
<td align="left">5 </td><td align="left">Fill the map <em>myImages</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#af1cc7589a891986d115b93aecb2eb95d">BOPAlgo_Builder::BuildSplitSolids()</a></em> </td></tr>
<tr>
<td align="left">6 </td><td align="left">Add internal vertices to split solids </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html#a7b2ef635a9f9c95222c7cae0e6b17ed4">BOPAlgo_Builder::FillInternalShapes()</a></em> </td></tr>
</table>
<h3><a class="anchor" id="occt_algorithms_7_4_14"></a>
Build Result of Type Solid</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a>, but for the type Solid.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_15"></a>
Build Images for Type CompSolid</h3>
<p>The input data for this step is:</p><ul>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type solid;</li>
<li><em>Original Shape</em> &ndash; a Compsolid;</li>
<li><em>Type</em> &ndash; the type of the shape <em>(TopAbs_COMPSOLID)</em>.</li>
</ul>
<p>The procedure is the same as for building images for wires.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_16"></a>
Build Result of Type Compsolid</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a>, but for the type Compsolid.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_17"></a>
Build Images for Compounds</h3>
<p>The input data for this step is as follows:</p><ul>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building results of type <em>compsolid</em>;</li>
<li><em>Original Shape</em> &ndash; a Compound;</li>
<li><em>Type</em> &ndash; the type of the shape <em>(TopAbs_COMPOUND)</em>.</li>
</ul>
<p>The procedure is the same as for building images for wires.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_18"></a>
Build Result of Type Compound</h3>
<p>This step is the same as <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4_4">Building Result of Type Vertex</a>, but for the type Compound.</p>
<h3><a class="anchor" id="occt_algorithms_7_4_19"></a>
Post-Processing</h3>
<p>The purpose of the step is to correct tolerances of the result to provide its validity in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a>.</em></p>
<p>The input data for this step is a <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> object after building result of type compound.</p>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Correct tolerances of vertices on curves </td><td align="left"><em>BOPTools_Tools::CorrectPointOnCurve()</em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">Correct tolerances of edges on faces </td><td align="left"><em>BOPTools_Tools::CorrectCurveOnSurface()</em> </td></tr>
</table>
<h1><a class="anchor" id="occt_algorithms_9"></a>
Boolean Operations Algorithm</h1>
<h2><a class="anchor" id="occt_algorithms_9_1"></a>
Arguments</h2>
<ul>
<li>The arguments of BOA are shapes in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>. The main requirements for the arguments are described in the <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_4">Data Structure</a></li>
<li>There are two groups of arguments in BOA:<ul>
<li>Objects <em>(S1=S11, S12, ...)</em>;</li>
<li>Tools <em>(S2=S21, S22, ...)</em>.</li>
</ul>
</li>
<li>The following table contains the values of dimension for different types of arguments:</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Type of Argument </th><th align="left">Index of Type </th><th align="left">Dimension  </th></tr>
<tr>
<td align="left">1 </td><td align="left">COMPOUND </td><td align="left">0 </td><td align="left">One of 0, 1, 2, 3 </td></tr>
<tr>
<td align="left">2 </td><td align="left">COMPSOLID </td><td align="left">1 </td><td align="left">3 </td></tr>
<tr>
<td align="left">3 </td><td align="left">SOLID </td><td align="left">2 </td><td align="left">3 </td></tr>
<tr>
<td align="left">4 </td><td align="left">SHELL </td><td align="left">3 </td><td align="left">2 </td></tr>
<tr>
<td align="left">5 </td><td align="left">FACE </td><td align="left">4 </td><td align="left">2 </td></tr>
<tr>
<td align="left">6 </td><td align="left">WIRE </td><td align="left">5 </td><td align="left">1 </td></tr>
<tr>
<td align="left">7 </td><td align="left">EDGE </td><td align="left">6 </td><td align="left">1 </td></tr>
<tr>
<td align="left">8 </td><td align="left">VERTEX </td><td align="left">7 </td><td align="left">0 </td></tr>
</table>
<ul>
<li>For Boolean operation Fuse all arguments should have equal dimensions.</li>
<li>For Boolean operation Cut the minimal dimension of <em>S2</em> should not be less than the maximal dimension of <em>S1</em>.</li>
<li>For Boolean operation Common the arguments can have any dimension.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_9_3"></a>
Results. General Rules</h2>
<ul>
<li>The result of the Boolean operation is a compound (if defined). Each sub-shape of the compound has shared sub-shapes in accordance with interferences between the arguments.</li>
<li>The content of the result depends on the type of the operation (Common, Fuse, Cut12, Cut21) and the dimensions of the arguments.</li>
<li>The result of the operation Fuse is defined for arguments <em>S1</em> and <em>S2</em> that have the same dimension value : <em>Dim(S1)=Dim(S2)</em>. If the arguments have different dimension values the result of the operation Fuse is not defined. The dimension of the result is equal to the dimension of the arguments. For example, it is impossible to fuse an edge and a face.</li>
<li>The result of the operation Fuse for arguments <em>S1</em> and <em>S2</em> contains the parts of arguments that have states <b>OUT</b> relative to the opposite arguments.</li>
<li>The result of the operation Fuse for arguments <em>S1</em> and <em>S2</em> having dimension value 3 (Solids) is refined by removing all possible internal faces to provide minimal number of solids.</li>
<li>The result of the operation Common for arguments <em>S1</em> and <em>S2</em> is defined for all values of the dimensions of the arguments. The result can contain shapes of different dimensions, but the minimal dimension of the result will be equal to the minimal dimension of the arguments. For example, the result of the operation Common between edges cannot be a vertex.</li>
<li>The result of the operation Common for the arguments <em>S1</em> and <em>S2</em> contains the parts of the argument that have states <b>IN</b> and <b>ON</b> relative to the opposite argument.</li>
<li>The result of the operation Cut is defined for arguments <em>S1</em> and <em>S2</em> that have values of dimensions <em>Dim(S2)</em> that should not be less than <em>Dim(S1)</em>. The result can contain shapes of different dimensions, but the minimal dimension of the result will be equal to the minimal dimension of the objects <em>Dim(S1)</em>. The result of the operation <em>Cut12</em> is not defined for other cases. For example, it is impossible to cut an edge from a solid, because a solid without an edge is not defined.</li>
<li>The result of the operation <em>Cut12</em> for arguments <em>S1</em> and <em>S2</em> contains the parts of argument <em>S1</em> that have state <b>OUT</b> relative to the opposite argument <em>S2</em>.</li>
<li>The result of the operation <em>Cut21</em> for arguments <em>S1</em> and <em>S2</em> contains the parts of argument <em>S2</em> that have state <b>OUT</b> relative to the opposite argument <em>S1</em>.</li>
<li>For the arguments of collection type (WIRE, SHELL, COMPSOLID) the type will be passed in the result. For example, the result of Common operation between Shell and Wire will be a compound containing Wire.</li>
<li>For the arguments of collection type (WIRE, SHELL, COMPSOLID) containing overlapping parts the overlapping parts passed into result will be repeated for each container from the input shapes containing such parts.</li>
<li>The result of the operation Fuse for the arguments of collection type (WIRE, SHELL, COMPSOLID) will contain the same number of containers as the arguments. The overlapping parts (EDGES/FACES/SOLIDS) will be shared among them. For example, the result of Fuse operation between two wires will be two wires sharing coinciding edges if any.</li>
<li>The result of the operation Common for the arguments of collection type (WIRE, SHELL, COMPSOLID) will consist of the containers containing the same overlapping parts. For example, the result of Common operation between two fully/partially overlapping wires will be two wires containing the same edges.</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_9_4"></a>
Examples</h2>
<h3><a class="anchor" id="occt_algorithms_9_4_1"></a>
Case 1: Two Vertices</h3>
<p>Let us consider two interfering vertices <em>V1</em> and <em>V2</em>:</p>
<div class="image">
<img src="boolean_image001.svg" alt="boolean_image001.svg"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is the compound that contains new vertex <em>V</em>.</li>
</ul>
<div class="image">
<img src="boolean_image002.svg" alt="boolean_image002.svg"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is a compound containing new vertex <em>V</em>.</li>
<li>The result of <em>Cut12</em> operation is an empty compound.</li>
<li>The result of <em>Cut21</em> operation is an empty compound.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_2"></a>
Case 2: A Vertex and an Edge</h3>
<p>Let us consider vertex <em>V1</em> and the edge <em>E2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image004.png" alt="boolean_image004.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is result is not defined because the dimension of the vertex (0) is not equal to the dimension of the edge (1).</li>
<li>The result of <em>Common</em> operation is a compound containing vertex <em>V<sub>1</sub></em> as the argument <em>V<sub>1</sub></em> has a common part with edge <em>E2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image005.png" alt="boolean_image005.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is an empty compound.</li>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the vertex (0) is less than the dimension of the edge (1).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_3"></a>
Case 3: A Vertex and a Face</h3>
<p>Let us consider vertex <em>V1</em> and face <em>F2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image006.png" alt="boolean_image006.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the vertex (0) is not equal to the dimension of the face (2).</li>
<li>The result of <em>Common</em> operation is a compound containing vertex <em>V<sub>1</sub></em> as the argument <em>V<sub>1</sub></em> has a common part with face <em>F2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image007.png" alt="boolean_image007.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is an empty compound.</li>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the vertex (0) is less than the dimension of the face (2).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_4"></a>
Case 4: A Vertex and a Solid</h3>
<p>Let us consider vertex <em>V1</em> and solid <em>S2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image008.png" alt="boolean_image008.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the vertex (0) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is a compound containing vertex <em>V<sub>1</sub></em> as the argument <em>V<sub>1</sub></em> has a common part with solid <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image009.png" alt="boolean_image009.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is an empty compound.</li>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the vertex (0) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_5"></a>
Case 5: Two edges intersecting at one point</h3>
<p>Let us consider edges <em>E1</em> and <em>E2</em> that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image010.svg" alt="boolean_image010.svg"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments i.e. 4 new edges <em>E11, E12, E21</em>, and <em>E22</em>. These edges have one shared vertex <em>Vn1</em>. In this case:<ul>
<li>argument edge <em>E1</em> has resulting split edges <em>E11</em> and <em>E12</em> (image of <em>E1</em>);</li>
<li>argument edge <em>E2</em> has resulting split edges <em>E21</em> and <em>E22</em> (image of <em>E2</em>).</li>
</ul>
</li>
</ul>
<div class="image">
<img src="boolean_image011.svg" alt="boolean_image011.svg"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (0) of the common part between the edges (vertex) is less than the dimension of the arguments (1).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split parts of the argument <em>E1</em>, i.e. 2 new edges <em>E11</em> and <em>E12</em>. These edges have one shared vertex <em>Vn1</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has resulting split edges <em>E11</em> and <em>E12</em> (image of <em>E1</em>).</p>
<div class="image">
<img src="boolean_image012.svg" alt="boolean_image012.svg"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split parts of the argument <em>E2</em>, i.e. 2 new edges <em>E21</em> and <em>E12</em>. These edges have one shared vertex <em>Vn1</em>.</li>
</ul>
<p>In this case the argument edge <em>E2</em> has resulting split edges <em>E21</em> and <em>E22</em> (image of <em>E2</em>).</p>
<div class="image">
<img src="boolean_image013.svg" alt="boolean_image013.svg"/>
</div>
<h3><a class="anchor" id="occt_algorithms_9_4_6"></a>
Case 6: Two edges having a common block</h3>
<p>Let us consider edges <em>E1</em> and <em>E2</em> that have a common block:</p>
<div class="image">
<img src="boolean_image014.svg" alt="boolean_image014.svg"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments i.e. 3 new edges <em>E11</em>, <em>E12</em> and <em>E22</em>. These edges have two shared vertices. In this case:<ul>
<li>argument edge <em>E1</em> has resulting split edges <em>E11</em> and <em>E12</em> (image of <em>E1</em>);</li>
<li>argument edge <em>E2</em> has resulting split edges <em>E21</em> and <em>E22</em> (image of <em>E2</em>);</li>
<li>edge <em>E12</em> is common for the images of <em>E1</em> and <em>E2</em>.</li>
</ul>
</li>
</ul>
<div class="image">
<img src="boolean_image015.svg" alt="boolean_image015.svg"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is a compound containing split parts of arguments i.e. 1 new edge <em>E12</em>. In this case edge <em>E12</em> is common for the images of <em>E1</em> and <em>E2</em>. The common part between the edges (edge) has the same dimension (1) as the dimension of the arguments (1).</li>
</ul>
<div class="image">
<img src="boolean_image016.svg" alt="boolean_image016.svg"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing a split part of argument <em>E1</em>, i.e. new edge <em>E11</em>.</li>
</ul>
<div class="image">
<img src="boolean_image017.svg" alt="boolean_image017.svg"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing a split part of argument <em>E2</em>, i.e. new edge <em>E22</em>.</li>
</ul>
<div class="image">
<img src="boolean_image018.svg" alt="boolean_image018.svg"/>
</div>
<h3><a class="anchor" id="occt_algorithms_9_4_7"></a>
Case 7: An Edge and a Face intersecting at a point</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em> that intersect at a 3D point:</p>
<div class="image">
<img src="boolean_image019.png" alt="boolean_image019.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the edge (1) is not equal to the dimension of the face (2).</li>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (0) of the common part between the edge and face (vertex) is less than the dimension of the arguments (1).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split parts of the argument <em>E1</em>, i.e. 2 new edges <em>E11</em> and <em>E12</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has no common parts with the face <em>F2</em> so the whole image of <em>E1</em> is in the result.</p>
<div class="image">
<img src="boolean_image020.png" alt="boolean_image020.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the edge (1) is less than the dimension of the face (2).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_8"></a>
Case 8: A Face and an Edge that have a common block</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em> that have a common block:</p>
<div class="image">
<img src="boolean_image021.png" alt="boolean_image021.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the edge (1) is not equal to the dimension of the face (2).</li>
<li>The result of <em>Common</em> operation is a compound containing a split part of the argument <em>E1</em>, i.e. new edge <em>E12</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with face <em>F2</em> so the corresponding part of the image of <em>E1</em> is in the result. The yellow square is not a part of the result. It only shows the place of <em>F2</em>.</p>
<div class="image">
<img src="boolean_image022.png" alt="boolean_image022.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>E1</em>, i.e. new edge <em>E11</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with face <em>F2</em> so the corresponding part is not included into the result. The yellow square is not a part of the result. It only shows the place of F2.</p>
<div class="image">
<img src="boolean_image023.png" alt="boolean_image023.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the edge (1) is less than the dimension of the face (2).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_9"></a>
Case 9: An Edge and a Solid intersecting at a point</h3>
<p>Let us consider edge <em>E1</em> and solid <em>S2</em> that intersect at a point:</p>
<div class="image">
<img src="boolean_image024.png" alt="boolean_image024.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the edge (1) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is a compound containing a split part of the argument <em>E1</em>, i.e. new edge <em>E12</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with solid <em>S2</em> so the corresponding part of the image of <em>E1</em> is in the result. The yellow square is not a part of the result. It only shows the place of <em>S2</em>.</p>
<div class="image">
<img src="boolean_image025.png" alt="boolean_image025.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>E1</em>, i.e. new edge <em>E11</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow square is not a part of the result. It only shows the place of <em>S2</em>.</p>
<div class="image">
<img src="boolean_image071.png" alt="boolean_image071.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the edge (1) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_10"></a>
Case 10: An Edge and a Solid that have a common block</h3>
<p>Let us consider edge <em>E1</em> and solid <em>S2</em> that have a common block:</p>
<div class="image">
<img src="boolean_image072.png" alt="boolean_image072.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the edge (1) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is a compound containing a split part of the argument <em>E1</em>, i.e. new edge <em>E12</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with solid <em>S2</em> so the corresponding part of the image of <em>E1</em> is in the result. The yellow square is not a part of the result. It only shows the place of <em>S2</em>.</p>
<div class="image">
<img src="boolean_image073.png" alt="boolean_image073.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>E1</em>, i.e. new edge <em>E11</em>.</li>
</ul>
<p>In this case the argument edge <em>E1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow square is not a part of the result. It only shows the place of <em>S2</em>.</p>
<div class="image">
<img src="boolean_image026.png" alt="boolean_image026.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is not defined because the dimension of the edge (1) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_11"></a>
Case 11: Two intersecting faces</h3>
<p>Let us consider two intersecting faces <em>F1</em> and <em>F2</em>:</p>
<div class="image">
<img src="boolean_image027.png" alt="boolean_image027.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments i.e. 2 new faces <em>F11</em> and <em>F21</em>. These faces have one shared edge <em>En1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image028.png" alt="boolean_image028.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (1) of the common part between <em>F1</em> and <em>F2</em> (edge) is less than the dimension of arguments (2).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>, i.e. new face <em>F11</em>.</li>
</ul>
<div class="image">
<img src="boolean_image029.png" alt="boolean_image029.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split parts of the argument <em>F2</em>, i.e. 1 new face <em>F21</em>.</li>
</ul>
<div class="image">
<img src="boolean_image030.png" alt="boolean_image030.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_9_4_12"></a>
Case 12: Two faces that have a common part</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have a common part:</p>
<div class="image">
<img src="boolean_image031.png" alt="boolean_image031.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments, i.e. 3 new faces: <em>F11</em>, <em>F12</em> and <em>F22</em>. These faces are shared through edges In this case:<ul>
<li>the argument edge <em>F1</em> has resulting split faces <em>F11</em> and <em>F12</em> (image of <em>F1</em>)</li>
<li>the argument face <em>F2</em> has resulting split faces <em>F12</em> and <em>F22</em> (image of <em>F2</em>)</li>
<li>the face <em>F12</em> is common for the images of <em>F1</em> and <em>F2</em>.</li>
</ul>
</li>
</ul>
<div class="image">
<img src="boolean_image032.png" alt="boolean_image032.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is a compound containing split parts of arguments i.e. 1 new face <em>F12</em>. In this case: face <em>F12</em> is common for the images of <em>F1</em> and <em>F2</em>. The common part between the faces (face) has the same dimension (2) as the dimension of the arguments (2).</li>
</ul>
<div class="image">
<img src="boolean_image033.png" alt="boolean_image033.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>, i.e. new face <em>F11</em>.</li>
</ul>
<div class="image">
<img src="boolean_image034.png" alt="boolean_image034.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split parts of the argument <em>F2</em>, i.e. 1 new face <em>F21</em>.</li>
</ul>
<div class="image">
<img src="boolean_image035.png" alt="boolean_image035.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_9_4_13"></a>
Case 13: Two faces that have a common edge</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have a common edge:</p>
<div class="image">
<img src="boolean_image036.png" alt="boolean_image036.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments, i.e. 2 new faces: <em>F11</em> and <em>F21</em>. These faces have one shared edge <em>En1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image037.png" alt="boolean_image037.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (1) of the common part between <em>F1</em> and <em>F2</em> (edge)is less than the dimension of the arguments (2)</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>, i.e. new face <em>F11</em>. The vertices are shown just to clarify the fact that the edges are spitted.</li>
</ul>
<div class="image">
<img src="boolean_image038.png" alt="boolean_image038.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split parts of the argument <em>F2</em>, i.e. 1 new face <em>F21</em>. The vertices are shown just to clarify the fact that the edges are spitted.</li>
</ul>
<div class="image">
<img src="boolean_image039.png" alt="boolean_image039.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_9_4_14"></a>
Case 14: Two faces that have a common vertex</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have a common vertex:</p>
<div class="image">
<img src="boolean_image040.png" alt="boolean_image040.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing split parts of arguments, i.e. 2 new faces: <em>F11</em> and <em>F21</em>. These faces have one shared vertex <em>Vn1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image041.png" alt="boolean_image041.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (0) of the common part between <em>F1</em> and <em>F2</em> (vertex) is less than the dimension of the arguments (2)</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>, i.e. new face <em>F11</em>.</li>
</ul>
<div class="image">
<img src="boolean_image042.png" alt="boolean_image042.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split parts of the argument <em>F2</em>, i.e. 1 new face <em>F21</em>.</li>
</ul>
<div class="image">
<img src="boolean_image043.png" alt="boolean_image043.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_9_4_15"></a>
Case 15: A Face and a Solid that have an intersection curve.</h3>
<p>Let us consider face <em>F1</em> and solid <em>S2</em> that have an intersection curve:</p>
<div class="image">
<img src="boolean_image044.png" alt="boolean_image044.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the face (2) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is a compound containing split part of the argument <em>F1</em>. In this case the argument face <em>F1</em> has a common part with solid <em>S2</em>, so the corresponding part of the image of <em>F1</em> is in the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image045.png" alt="boolean_image045.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>. In this case argument face <em>F1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image046.png" alt="boolean_image046.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is is not defined because the dimension of the face (2) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_16"></a>
Case 16: A Face and a Solid that have overlapping faces.</h3>
<p>Let us consider face <em>F1</em> and solid <em>S2</em> that have overlapping faces:</p>
<div class="image">
<img src="boolean_image047.png" alt="boolean_image047.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the face (2) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is a compound containing split part of the argument <em>F1</em>. In this case the argument face <em>F1</em> has a common part with solid <em>S2</em>, so the corresponding part of the image of <em>F1</em> is included in the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image048.png" alt="boolean_image048.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>. In this case argument face <em>F1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image049.png" alt="boolean_image049.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is is not defined because the dimension of the face (2) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_17"></a>
Case 17: A Face and a Solid that have overlapping edges.</h3>
<p>Let us consider face <em>F1</em> and solid <em>S2</em> that have overlapping edges:</p>
<div class="image">
<img src="boolean_image050.png" alt="boolean_image050.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the face (2) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (1) of the common part between <em>F1</em> and <em>S2</em> (edge) is less than the lower dimension of the arguments (2).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>. In this case argument face <em>F1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image051.png" alt="boolean_image051.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is is not defined because the dimension of the face (2) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_18"></a>
Case 18: A Face and a Solid that have overlapping vertices.</h3>
<p>Let us consider face <em>F1</em> and solid <em>S2</em> that have overlapping vertices:</p>
<div class="image">
<img src="boolean_image052.png" alt="boolean_image052.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined because the dimension of the face (2) is not equal to the dimension of the solid (3).</li>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (1) of the common part between <em>F1</em> and <em>S2</em> (vertex) is less than the lower dimension of the arguments (2).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>F1</em>. In this case argument face <em>F1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result. The yellow contour is not a part of the result. It only shows the place of <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image053.png" alt="boolean_image053.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is is not defined because the dimension of the face (2) is less than the dimension of the solid (3).</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_19"></a>
Case 19: Two intersecting Solids.</h3>
<p>Let us consider two intersecting solids <em>S1</em> and <em>S2</em>:</p>
<div class="image">
<img src="boolean_image054.png" alt="boolean_image054.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound composed from the split parts of arguments <em>S11, S12</em> and <em>S22</em> <em>(Cut12, Common, Cut21)</em>. All inner webs are removed, so the result is one new solid <em>R</em>.</li>
</ul>
<div class="image">
<img src="boolean_image055.png" alt="boolean_image055.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is a compound containing split parts of arguments i.e. one new solid <em>S12</em>. In this case solid <em>S12</em> is common for the images of <em>S1</em> and <em>S2</em>. The common part between the solids (solid) has the same dimension (3) as the dimension of the arguments (3). The yellow contour is not a part of the result. It only shows the place of <em>S1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image056.png" alt="boolean_image056.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>S1</em>, i.e. 1 new solid <em>S11</em>.</li>
</ul>
<div class="image">
<img src="boolean_image057.png" alt="boolean_image057.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split part of the argument <em>S2</em>, i.e. 1 new solid <em>S21</em>.</li>
</ul>
<div class="image">
<img src="boolean_image058.png" alt="boolean_image058.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_9_4_20"></a>
Case 20: Two Solids that have overlapping faces.</h3>
<p>Let us consider two solids <em>S1</em> and <em>S2</em> that have a common part on face:</p>
<div class="image">
<img src="boolean_image059.png" alt="boolean_image059.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound composed from the split parts of arguments <em>S11, S12</em> and <em>S22</em> <em>(Cut12, Common, Cut21)</em>. All inner webs are removed, so the result is one new solid <em>R</em>.</li>
</ul>
<div class="image">
<img src="boolean_image060.png" alt="boolean_image060.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (2) of the common part between <em>S1</em> and <em>S2</em> (face) is less than the lower dimension of the arguments (3).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>S1</em>, i.e. 1 new solid <em>S11</em>.</li>
</ul>
<div class="image">
<img src="boolean_image061.png" alt="boolean_image061.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split part of the argument <em>S2</em>, i.e. 1 new solid <em>S21</em>. <div class="image">
<img src="boolean_image062.png" alt="boolean_image062.png"/>
</div>
</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_21"></a>
Case 21: Two Solids that have overlapping edges.</h3>
<p>Let us consider two solids <em>S1</em> and <em>S2</em> that have overlapping edges:</p>
<div class="image">
<img src="boolean_image063.png" alt="boolean_image063.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound composed from the split parts of arguments i.e. 2 new solids <em>S11</em> and <em>S21</em>. These solids have one shared edge <em>En1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image064.png" alt="boolean_image064.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (1) of the common part between <em>S1</em> and <em>S2</em> (edge) is less than the lower dimension of the arguments (3).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>S1</em>. In this case argument <em>S1</em> has a common part with solid <em>S2</em> so the corresponding part is not included into the result.</li>
</ul>
<div class="image">
<img src="boolean_image065.png" alt="boolean_image065.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split part of the argument <em>S2</em>. In this case argument <em>S2</em> has a common part with solid <em>S1</em> so the corresponding part is not included into the result. <div class="image">
<img src="boolean_image066.png" alt="boolean_image066.png"/>
</div>
</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_22"></a>
Case 22: Two Solids that have overlapping vertices.</h3>
<p>Let us consider two solids <em>S1</em> and <em>S2</em> that have overlapping vertices:</p>
<div class="image">
<img src="boolean_image067.png" alt="boolean_image067.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound composed from the split parts of arguments i.e. 2 new solids <em>S11</em> and <em>S21</em>. These solids share <em>Vn1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image068.png" alt="boolean_image068.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is an empty compound because the dimension (0) of the common part between <em>S1</em> and <em>S2</em> (vertex) is less than the lower dimension of the arguments (3).</li>
<li>The result of <em>Cut12</em> operation is a compound containing split part of the argument <em>S1</em>.</li>
</ul>
<div class="image">
<img src="boolean_image069.png" alt="boolean_image069.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing split part of the argument <em>S2</em>.</li>
</ul>
<div class="image">
<img src="boolean_image070.png" alt="boolean_image070.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_9_4_23"></a>
Case 23: A Shell and a Wire cut by a Solid.</h3>
<p>Let us consider Shell <em>Sh</em> and Wire <em>W</em> as the objects and Solid <em>S</em> as the tool:</p>
<div class="image">
<img src="boolean_image136.png" alt="boolean_image136.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is not defined as the dimension of the arguments is not the same.</li>
<li>The result of <em>Common</em> operation is a compound containing the parts of the initial Shell and Wire common for the Solid. The new Shell and Wire are created from the objects.</li>
</ul>
<div class="image">
<img src="boolean_image137.png" alt="boolean_image137.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing new Shell and Wire split from the arguments <em>Sh</em> and <em>W</em>. In this case they have a common part with solid <em>S</em> so the corresponding part is not included into the result.</li>
</ul>
<div class="image">
<img src="boolean_image138.png" alt="boolean_image138.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is not defined as the objects have a lower dimension than the tool.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_9_4_24"></a>
Case 24: Two Wires that have overlapping edges.</h3>
<p>Let us consider two Wires that have overlapping edges, <em>W1</em> is the object and <em>W2</em> is the tool:</p>
<div class="image">
<img src="boolean_image139.png" alt="boolean_image139.png"/>
</div>
<ul>
<li>The result of <em>Fuse</em> operation is a compound containing two Wires, which share an overlapping edge. The new Wires are created from the objects:</li>
</ul>
<div class="image">
<img src="boolean_image140.png" alt="boolean_image140.png"/>
</div>
<ul>
<li>The result of <em>Common</em> operation is a compound containing two Wires both consisting of an overlapping edge. The new Wires are created from the objects:</li>
</ul>
<div class="image">
<img src="boolean_image141.png" alt="boolean_image141.png"/>
</div>
<ul>
<li>The result of <em>Cut12</em> operation is a compound containing a wire split from object <em>W1</em>. Its common part with <em>W2</em> is not included into the result.</li>
</ul>
<div class="image">
<img src="boolean_image142.png" alt="boolean_image142.png"/>
</div>
<ul>
<li>The result of <em>Cut21</em> operation is a compound containing a wire split from <em>W2</em>. Its common part with <em>W1</em> is not included into the result.</li>
</ul>
<div class="image">
<img src="boolean_image143.png" alt="boolean_image143.png"/>
</div>
<h2><a class="anchor" id="occt_algorithms_9_5"></a>
Class BOPAlgo_BOP</h2>
<p>BOA is implemented in the class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a></em>. The main fields of this class are described in the Table:</p>
<table class="doxtable">
<tr>
<th align="left">Name </th><th align="left">Contents  </th></tr>
<tr>
<td align="left"><em>myOperation</em> </td><td align="left">The type of the Boolean operation (Common, Fuse, Cut) </td></tr>
<tr>
<td align="left"><em>myTools</em> </td><td align="left">The tools </td></tr>
<tr>
<td align="left"><em>myDims[2]</em> </td><td align="left">The values of the dimensions of the arguments </td></tr>
<tr>
<td align="left"><em>myRC</em> </td><td align="left">The draft result (shape) </td></tr>
</table>
<p>The main steps of the <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a></em> are the same as of <a class="el" href="occt_user_guides__boolean_operations.html#occt_algorithms_7_4">BOPAlgo_Builder</a> except for some aspects described in the next paragraphs.</p>
<h2><a class="anchor" id="occt_algorithms_9_6"></a>
Building Draft Result</h2>
<p>The input data for this step is as follows:</p><ul>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a></em> object after building result of type <em>Compound</em>;</li>
<li><em>Type</em> of the Boolean operation.</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For the Boolean operation <em>Fuse</em> add to <em>myRC</em> all images of arguments. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html#a3001239a29dfb6095e1144e81fff3216">BOPAlgo_BOP::BuildRC()</a></em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">For the Boolean operation <em>Common</em> or <em>Cut</em> add to <em>myRC</em> all images of argument <em>S1</em> that are <em>Common</em> for the Common operation and are <em>Not Common</em> for the Cut operation </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html#a3001239a29dfb6095e1144e81fff3216">BOPAlgo_BOP::BuildRC()</a></em> </td></tr>
</table>
<h2><a class="anchor" id="occt_algorithms_9_7"></a>
Building the Result</h2>
<p>The input data for this step is as follows:</p><ul>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a></em> object the state after building draft result.</li>
</ul>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">For the Type of the Boolean operation Common, Cut with any dimension and operation Fuse with <em>myDim[0] &lt; 3</em> </td><td align="left"></td></tr>
<tr>
<td align="left">1.1 </td><td align="left">Find containers (WIRE, SHELL, COMPSOLID) in the arguments </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a>:: BuildShape()</em> </td></tr>
<tr>
<td align="left">1.2 </td><td align="left">Make connexity blocks from splits of each container that are in <em>myRC</em> </td><td align="left"><em>BOPTools_Tools::MakeConnexityBlocks()</em> </td></tr>
<tr>
<td align="left">1.3 </td><td align="left">Build the result from shapes made from the connexity blocks </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a>:: BuildShape()</em> </td></tr>
<tr>
<td align="left">1.4 </td><td align="left">Add the remaining shapes from <em>myRC</em> to the result </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html">BOPAlgo_BOP</a>:: BuildShape()</em> </td></tr>
<tr>
<td align="left">2 </td><td align="left">For the Type of the Boolean operation Fuse with <em>myDim[0] = 3</em> </td><td align="left"></td></tr>
<tr>
<td align="left">2.1 </td><td align="left">Find internal faces <em>(FWi)</em> in <em>myRC</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html#a2aef6284660d5e8b5c4a94505090d806">BOPAlgo_BOP::BuildSolid()</a></em> </td></tr>
<tr>
<td align="left">2.2 </td><td align="left">Collect all faces of <em>myRC</em> except for internal faces <em>(FWi) -&gt; SFS</em> </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___b_o_p.html#a2aef6284660d5e8b5c4a94505090d806">BOPAlgo_BOP::BuildSolid</a> ()</em> </td></tr>
<tr>
<td align="left">2.3 </td><td align="left">Build solids <em>(SDi)</em> from <em>SFS</em>. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder_solid.html">BOPAlgo_BuilderSolid</a></em> </td></tr>
<tr>
<td align="left">2.4 </td><td align="left">Add the solids <em>(SDi)</em> to the result </td><td align="left"></td></tr>
</table>
<h1><a class="anchor" id="occt_algorithms_10a"></a>
Section Algorithm</h1>
<h2><a class="anchor" id="occt_algorithms_10a_1"></a>
Arguments</h2>
<p>The arguments of BOA are shapes in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_topo_d_s___shape.html">TopoDS_Shape</a></em>. The main requirements for the arguments are described in the Algorithms.</p>
<h2><a class="anchor" id="occt_algorithms_10a_2"></a>
Results and general rules</h2>
<ul>
<li>The result of Section operation is a compound. Each sub-shape of the compound has shared sub-shapes in accordance with interferences between the arguments.</li>
<li>The result of Section operation contains shapes that have dimension that is less then 2 i.e. vertices and edges.</li>
<li>The result of Section operation contains standalone vertices if these vertices do not belong to the edges of the result.</li>
<li>The result of Section operation contains vertices and edges of the arguments (or images of the arguments) that belong to at least two arguments (or two images of the arguments).</li>
<li>The result of Section operation contains Section vertices and edges obtained from Face/Face interferences.</li>
<li>The result of Section operation contains vertices that are the result of interferences between vertices and faces.</li>
<li>The result of Section operation contains edges that are the result of interferences between edges and faces (Common Blocks),</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_10a_3"></a>
Examples</h2>
<h3><a class="anchor" id="occt_algorithms_10a_3_1"></a>
Case 1: Two Vertices</h3>
<p>Let us consider two interfering vertices: <em>V1</em> and <em>V2</em>.</p>
<div class="image">
<img src="boolean_image080.png" alt="boolean_image080.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new vertex <em>V</em>.</p>
<div class="image">
<img src="boolean_image081.png" alt="boolean_image081.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_2"></a>
Case 1: Case 2: A Vertex and an Edge</h3>
<p>Let us consider vertex <em>V1</em> and the edge <em>E2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image082.png" alt="boolean_image082.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains vertex <em>V1</em>.</p>
<div class="image">
<img src="boolean_image083.png" alt="boolean_image083.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_3"></a>
Case 1: Case 2: A Vertex and a Face</h3>
<p>Let us consider vertex <em>V1</em> and face <em>F2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image084.png" alt="boolean_image084.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains vertex <em>V1</em>.</p>
<div class="image">
<img src="boolean_image085.png" alt="boolean_image085.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_4"></a>
Case 4: A Vertex and a Solid</h3>
<p>Let us consider vertex <em>V1</em> and solid <em>Z2</em>. The vertex <em>V1</em> is inside the solid <em>Z2</em>.</p>
<div class="image">
<img src="boolean_image086.png" alt="boolean_image086.png"/>
</div>
<p>The result of <em>Section</em> operation is an empty compound.</p>
<h3><a class="anchor" id="occt_algorithms_10a_3_5"></a>
Case 5: Two edges intersecting at one point</h3>
<p>Let us consider edges <em>E1</em> and <em>E2</em>, that intersect in a 3D point:</p>
<div class="image">
<img src="boolean_image087.png" alt="boolean_image087.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>.</p>
<div class="image">
<img src="boolean_image088.png" alt="boolean_image088.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_6"></a>
Case 6: Two edges having a common block</h3>
<p>Let us consider edges <em>E1</em> and <em>E2</em>, that have a common block:</p>
<div class="image">
<img src="boolean_image089.png" alt="boolean_image089.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image090.png" alt="boolean_image090.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_7"></a>
Case 7: An Edge and a Face intersecting at a point</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em>, that intersect at a 3D point:</p>
<div class="image">
<img src="boolean_image091.png" alt="boolean_image091.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>.</p>
<div class="image">
<img src="boolean_image092.png" alt="boolean_image092.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_8"></a>
Case 8: A Face and an Edge that have a common block</h3>
<p>Let us consider edge <em>E1</em> and face <em>F2</em>, that have a common block:</p>
<div class="image">
<img src="boolean_image093.png" alt="boolean_image093.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image094.png" alt="boolean_image094.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_9"></a>
Case 9: An Edge and a Solid intersecting at a point</h3>
<p>Let us consider edge <em>E1</em> and solid <em>Z2</em>, that intersect at a point:</p>
<div class="image">
<img src="boolean_image095.png" alt="boolean_image095.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>.</p>
<div class="image">
<img src="boolean_image096.png" alt="boolean_image096.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_10"></a>
Case 10: An Edge and a Solid that have a common block</h3>
<p>Let us consider edge <em>E1</em> and solid <em>Z2</em>, that have a common block at a face:</p>
<div class="image">
<img src="boolean_image097.png" alt="boolean_image097.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image098.png" alt="boolean_image098.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_11"></a>
Case 11: Two intersecting faces</h3>
<p>Let us consider two intersecting faces <em>F1</em> and <em>F2</em>:</p>
<div class="image">
<img src="boolean_image099.png" alt="boolean_image099.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image100.png" alt="boolean_image100.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_12"></a>
Case 12: Two faces that have a common part</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have a common part:</p>
<div class="image">
<img src="boolean_image133.png" alt="boolean_image133.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains 4 new edges.</p>
<div class="image">
<img src="boolean_image134.png" alt="boolean_image134.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_13"></a>
Case 13: Two faces that have overlapping edges</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have a overlapping edges:</p>
<div class="image">
<img src="boolean_image101.png" alt="boolean_image101.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image102.png" alt="boolean_image102.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_14"></a>
Case 14: Two faces that have overlapping vertices</h3>
<p>Let us consider two faces <em>F1</em> and <em>F2</em> that have overlapping vertices:</p>
<div class="image">
<img src="boolean_image103.png" alt="boolean_image103.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>.</p>
<div class="image">
<img src="boolean_image104.png" alt="boolean_image104.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_15"></a>
Case 15: A Face and a Solid that have an intersection curve</h3>
<p>Let us consider face <em>F1</em> and solid <em>Z2</em> that have an intersection curve:</p>
<div class="image">
<img src="boolean_image105.png" alt="boolean_image105.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains new edges.</p>
<div class="image">
<img src="boolean_image106.png" alt="boolean_image106.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_16"></a>
Case 16: A Face and a Solid that have overlapping faces.</h3>
<p>Let us consider face <em>F1</em> and solid <em>Z2</em> that have overlapping faces:</p>
<div class="image">
<img src="boolean_image107.png" alt="boolean_image107.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains new edges</p>
<div class="image">
<img src="boolean_image108.png" alt="boolean_image108.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_17"></a>
Case 17: A Face and a Solid that have overlapping edges.</h3>
<p>Let us consider face <em>F1</em> and solid <em>Z2</em> that have a common part on edge:</p>
<div class="image">
<img src="boolean_image109.png" alt="boolean_image109.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>.</p>
<div class="image">
<img src="boolean_image110.png" alt="boolean_image110.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_18"></a>
Case 18: A Face and a Solid that have overlapping vertices.</h3>
<p>Let us consider face <em>F1</em> and solid <em>Z2</em> that have overlapping vertices:</p>
<div class="image">
<img src="boolean_image111.png" alt="boolean_image111.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>.</p>
<div class="image">
<img src="boolean_image112.png" alt="boolean_image112.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_19"></a>
Case 19: Two intersecting Solids</h3>
<p>Let us consider two intersecting solids <em>Z1</em> and <em>Z2</em>: </p><div class="image">
<img src="boolean_image113.png" alt="boolean_image113.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains new edges. </p><div class="image">
<img src="boolean_image114.png" alt="boolean_image114.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_20"></a>
Case 20: Two Solids that have overlapping faces</h3>
<p>Let us consider two solids <em>Z1</em> and <em>Z2</em> that have a common part on face: </p><div class="image">
<img src="boolean_image115.png" alt="boolean_image115.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains new edges. </p><div class="image">
<img src="boolean_image116.png" alt="boolean_image116.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_21"></a>
Case 21: Two Solids that have overlapping edges</h3>
<p>Let us consider two solids <em>Z1</em> and <em>Z2</em> that have overlapping edges: </p><div class="image">
<img src="boolean_image117.png" alt="boolean_image117.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new edge <em>Enew</em>. </p><div class="image">
<img src="boolean_image118.png" alt="boolean_image118.png"/>
</div>
<h3><a class="anchor" id="occt_algorithms_10a_3_22"></a>
Case 22: Two Solids that have overlapping vertices</h3>
<p>Let us consider two solids <em>Z1</em> and <em>Z2</em> that have overlapping vertices: </p><div class="image">
<img src="boolean_image119.png" alt="boolean_image119.png"/>
</div>
<p>The result of <em>Section</em> operation is the compound that contains a new vertex <em>Vnew</em>. </p><div class="image">
<img src="boolean_image120.png" alt="boolean_image120.png"/>
</div>
<h2><a class="anchor" id="occt_algorithms_10a_4"></a>
Class BOPAlgo_Section</h2>
<p>SA is implemented in the class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___section.html">BOPAlgo_Section</a></em>. The class has no specific fields. The main steps of the <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___section.html">BOPAlgo_Section</a></em> are the same as of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___builder.html">BOPAlgo_Builder</a></em> except for the following steps:</p>
<ul>
<li>Build Images for Wires;</li>
<li>Build Result of Type Wire;</li>
<li>Build Images for Faces;</li>
<li>Build Result of Type Face;</li>
<li>Build Images for Shells;</li>
<li>Build Result of Type Shell;</li>
<li>Build Images for Solids;</li>
<li>Build Result of Type Solid;</li>
<li>Build Images for Type CompSolid;</li>
<li>Build Result of Type CompSolid;</li>
<li>Build Images for Compounds; Some aspects of building the result are described in the next paragraph</li>
</ul>
<h2><a class="anchor" id="occt_algorithms_10a_5"></a>
Building the Result</h2>
<table class="doxtable">
<tr>
<th align="left">No </th><th align="left">Contents </th><th align="left">Implementation  </th></tr>
<tr>
<td align="left">1 </td><td align="left">Build the result of the operation using all information contained in <em>FaceInfo</em>, Common Block, Shared entities of the arguments, etc. </td><td align="left"><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___section.html">BOPAlgo_Section</a>:: BuildSection()</em> </td></tr>
</table>
<h1><a class="anchor" id="occt_algorithms_10"></a>
Algorithm Limitations</h1>
<p>The chapter describes the problems that are considered as Algorithm limitations. In most cases an Algorithm failure is caused by a combination of various factors, such as self-interfered arguments, inappropriate or ungrounded values of the argument tolerances, adverse mutual position of the arguments, tangency, etc.</p>
<p>A lot of failures of GFA algorithm can be caused by bugs in low-level algorithms: Intersection Algorithm, Projection Algorithm, Approximation Algorithm, Classification Algorithm, etc.</p><ul>
<li>The Intersection, Projection and Approximation Algorithms are mostly used at the Intersection step. Their bugs directly cause wrong section results (i.e. incorrect section edges, section points, missing section edges or micro edges). It is not possible to obtain a correct final result of the GFA if a section result is wrong.</li>
<li>The Projection Algorithm is used at the Intersection step. The purpose of Projection Algorithm is to compute 2D curves on surfaces. Wrong results here lead to incorrect or missing faces in the final GFA result.</li>
<li>The Classification Algorithm is used at the Building step. The bugs in the Classification Algorithm lead to errors in selecting shape parts (edges, faces, solids) and ultimately to a wrong final GFA result.</li>
</ul>
<p>The description below illustrates some known GFA limitations. It does not enumerate exhaustively all problems that can arise in practice. Please, address cases of Algorithm failure to the OCCT Maintenance Service.</p>
<h2><a class="anchor" id="occt_algorithms_10_1"></a>
Arguments</h2>
<h3><a class="anchor" id="occt_algorithms_10_1_1"></a>
Common requirements</h3>
<p>Each argument should be valid (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>), or conversely, if the argument is considered as non-valid (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>), it cannot be used as an argument of the algorithm.</p>
<p>The class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em> is used to check the overall validity of a shape. In OCCT a Shape (or its sub-shapes) is considered valid if it meets certain criteria. If the shape is found as invalid, it can be fixed by tools from <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_analysis.html">ShapeAnalysis</a>, <a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_upgrade.html">ShapeUpgrade</a></em> and <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_shape_fix.html">ShapeFix</a></em> packages.</p>
<p>However, it is important to note that class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em> is just a tool that can have its own problems; this means that due to a specific factor(s) this tool can sometimes provide a wrong result.</p>
<p>Let us consider the following example:</p>
<p>The Analyzer checks distances between couples of 3D check-points <em>(Pi, PSi)</em> of edge <em>E</em> on face <em>F</em>. Point <em>Pi</em> is obtained from the 3D curve (at the parameter <em>ti</em>) of the edge. <em>PSi</em> is obtained from 2D curve (at the parameter <em>ti</em>) of the edge on surface <em>S</em> of face <em>F</em>. To be valid the distance should be less than <em>Tol(E)</em> for all couples of check-points. The number of these check-points is a predefined value (e.g. 23).</p>
<p>Let us consider the case when edge <em>E</em> is recognized valid (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>).</p>
<p>Further, after some operation, edge <em>E</em> is split into two edges <em>E1</em> and <em>E2</em>. Each split edge has the same 3D curve and 2D curve as the original edge <em>E</em>.</p>
<p>Let us check <em>E1</em> (or E2). The Analyzer again checks the distances between the couples of check-points points <em>(Pi, PSi)</em>. The number of these check-points is the same constant value (23), but there is no guarantee that the distances will be less than <em>Tol(E)</em>, because the points chosen for <em>E1</em> are not the same as for <em>E</em>.</p>
<p>Thus, if <em>E1</em> is recognized by the Analyzer as non-valid, edge <em>E</em> should also be non-valid. However <em>E</em> has been recognized as valid. Thus the Analyzer gives a wrong result for <em>E</em>.</p>
<p>The fact that the argument is a valid shape (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>) is a necessary but insufficient requirement to produce a valid result of the Algorithms.</p>
<h3><a class="anchor" id="occt_algorithms_10_1_3"></a>
Pure self-interference</h3>
<p>The argument should not be self-interfered, i.e. all sub-shapes of the argument that have geometrical coincidence through any topological entities (vertices, edges, faces) should share these entities.</p>
<h4>Example 1: Compound of two edges</h4>
<p>The compound of two edges <em>E1</em> and <em>E2</em> is a self-interfered shape and cannot be used as the argument of the Algorithms.</p>
<div class="image">
<img src="operations_image036.svg" alt="operations_image036.svg"/>
<div class="caption">
Compound of two edges</div></div>
<h4>Example 2: Self-interfered Edge</h4>
<p>The edge <em>E</em> is a self-interfered shape and cannot be used as an argument of the Algorithms.</p>
<div class="image">
<img src="operations_image037.svg" alt="operations_image037.svg"/>
<div class="caption">
Self-interfered Edge</div></div>
<h4>Example 3: Self-interfered Face</h4>
<p>The face <em>F</em> is a self-interfered shape and cannot be used as an argument of the Algorithms.</p>
<div class="image">
<img src="operations_image038.svg" alt="operations_image038.svg"/>
<div class="caption">
Self-interfered Face</div></div>
<h4>Example 4: Face of Revolution</h4>
<p>The face <em>F</em> has been obtained by revolution of edge <em>E</em> around line <em>L</em>.</p>
<div class="image">
<img src="operations_image039a.png" alt="operations_image039a.png"/>
<div class="caption">
Face of Revolution: Arguments</div></div>
 <div class="image">
<img src="operations_image039b.png" alt="operations_image039b.png"/>
<div class="caption">
Face of Revolution: Result</div></div>
<p>In spite of the fact that face <em>F</em> is valid (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>) it is a self-interfered shape and cannot be used as the argument of the Algorithms.</p>
<h3><a class="anchor" id="occt_algorithms_10_1_4"></a>
Self-interferences due to tolerances</h3>
<h4>Example 1: Non-closed Edge</h4>
<p>Let us consider edge <em>E</em> based on a non-closed circle. </p><div class="image">
<img src="operations_image040.png" alt="operations_image040.png"/>
<div class="caption">
Edge based on a non-closed circle</div></div>
<p>The distance between the vertices of <em>E</em> is <em>D=0.69799</em>. The values of the tolerances <em>Tol(V1)=Tol(V2)=0.5</em>. </p><div class="image">
<img src="operations_image041.png" alt="operations_image041.png"/>
<div class="caption">
Distance and Tolerances</div></div>
<p>In spite of the fact that the edge <em>E</em> is valid in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>, it is a self-interfered shape because its vertices are interfered. Thus, edge <em>E</em> cannot be used as an argument of the Algorithms.</p>
<h4>Example 2: Solid containing an interfered vertex</h4>
<p>Let us consider solid <em>S</em> containing vertex V. </p><div class="image">
<img src="operations_image042.png" alt="operations_image042.png"/>
<div class="caption">
Solid containing an interfered vertex</div></div>
<p>The value of tolerance Tol(V)= 50.000075982061.</p>
<div class="image">
<img src="operations_image043.png" alt="operations_image043.png"/>
<div class="caption">
Tolerance</div></div>
<p>In spite of the fact that solid <em>S</em> is valid in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em> it is a self-interfered shape because vertex <em>V</em> is interfered with a lot of sub-shapes from <em>S</em> without any topological connection with them. Thus solid <em>S</em> cannot be used as an argument of the Algorithms.</p>
<h3><a class="anchor" id="occt_algorithms_10_1_5"></a>
Parametric representation</h3>
<p>The parameterization of some surfaces (cylinder, cone, surface of revolution) can be the cause of limitation.</p>
<h4>Example 1: Cylindrical surface</h4>
<p>The parameterization range for cylindrical surface is:</p>
<div class="image">
<img src="boolean_image135.png" alt="boolean_image135.png"/>
</div>
<p>The range of <em>U</em> coordinate is always restricted while the range of <em>V</em> coordinate is non-restricted.</p>
<p>Let us consider a cylinder-based <em>Face 1</em> with radii <em>R=3</em> and <em>H=6</em>.</p>
<div class="image">
<img src="operations_image044.png" alt="operations_image044.png"/>
<div class="caption">
Face 1</div></div>
<div class="image">
<img src="operations_image045.png" alt="operations_image045.png"/>
<div class="caption">
P-Curves for Face 1</div></div>
<p>Let us also consider a cylinder-based <em>Face 2</em> with radii <em>R=3000</em> and <em>H=6000</em> (resulting from scaling Face 1 with scale factor <em>ScF=1000</em>).</p>
<div class="image">
<img src="operations_image046.png" alt="operations_image046.png"/>
<div class="caption">
Face 2</div></div>
<div class="image">
<img src="operations_image047.png" alt="operations_image047.png"/>
<div class="caption">
P-Curves for Face 2</div></div>
<p>Please, pay attention to the Zoom value of the Figures.</p>
<p>It is obvious that starting with some value of <em>ScF</em>, e.g. <em>ScF&gt;1000000</em>, all sloped p-Curves on <em>Face 2</em> will be almost vertical. At least, there will be no difference between the values of angles computed by standard C Run-Time Library functions, such as <em>double acos(double x)</em>. The loss of accuracy in computation of angles can cause failure of some BP sub-algorithms, such as building faces from a set of edges or building solids from a set of faces.</p>
<h3><a class="anchor" id="occt_algorithms_10_1_6"></a>
Using tolerances of vertices to fix gaps</h3>
<p>It is possible to create shapes that use sub-shapes of lower order to avoid gaps in the tolerance-based data model.</p>
<p>Let us consider the following example:</p>
<div class="image">
<img src="operations_image048.png" alt="operations_image048.png"/>
<div class="caption">
Example</div></div>
<ul>
<li>Face <em>F</em> has two edges <em>E1</em> and <em>E2</em> and two vertices, the base plane is <em>{0,0,0, 0,0,1}</em>;</li>
<li>Edge <em>E1</em> is based on line <em>{0,0,0, 1,0,0}, Tol(E1) = 1.e-7; </em></li>
<li>Edge <em>E2</em> is based on line <em>{0,1,0, 1,0,0}, Tol(E2) = 1.e-7;</em></li>
<li>Vertex <em>V1</em>, point <em>{0,0.5,0}, Tol(V1) = 1;</em></li>
<li>Vertex <em>V2</em>, point <em>{10,0.5,0}, Tol(V2) = 1;</em></li>
<li>Face <em>F</em> is valid (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>).</li>
</ul>
<p>The values of tolerances <em>Tol(V1)</em> and <em>Tol(V2)</em> are big enough to fix the gaps between the ends of the edges, but the vertices <em>V1</em> and <em>V2</em> do not contain any information about the trajectories connecting the corresponding ends of the edges. Thus, the trajectories are undefined. This will cause failure of some sub-algorithms of BP. For example, the sub-algorithms for building faces from a set of edges use the information about all edges connected in a vertex. The situation when a vertex has several pairs of edges such as above will not be solved in a right way.</p>
<h2><a class="anchor" id="occt_algorithms_11_1"></a>
Intersection problems</h2>
<h3><a class="anchor" id="occt_algorithms_11_1_1"></a>
Pure intersections and common zones</h3>
<h4>Example: Intersecting Edges</h4>
<p>Let us consider the intersection between two edges:</p><ul>
<li><em>E1</em> is based on a line: <em>{0,-10,0, 1,0,0}, Tol(E1)=2.</em></li>
<li><em>E2</em> is based on a circle: <em>{0,0,0, 0,0,1}, R=10, Tol(E2)=2.</em></li>
</ul>
<div class="image">
<img src="operations_image049.png" alt="operations_image049.png"/>
<div class="caption">
Intersecting Edges</div></div>
<p>The result of pure intersection between <em>E1</em> and <em>E2</em> is vertex <em>Vx {0,-10,0}</em>.</p>
<p>The result of intersection taking into account tolerances is the common zone <em>CZ</em> (part of 3D-space where the distance between the curves is less than or equals to the sum of edge tolerances.</p>
<p>The Intersection Part of Algorithms uses the result of pure intersection <em>Vx</em> instead of <em>CZ</em> for the following reasons:</p><ul>
<li>The Algorithms do not produce Common Blocks between edges based on underlying curves of explicitly different type (e.g. Line / Circle). If the curves have different types, the rule of thumb is that the produced result is of type <b>vertex</b>. This rule does not work for non-analytic curves (Bezier, B-Spline) and their combinations with analytic curves.</li>
<li>The algorithm of intersection between two surfaces <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_int_patch___intersection.html">IntPatch_Intersection</a></em> does not compute <em>CZ</em> of the intersection between curves and points. So even if <em>CZ</em> were computed by Edge/Edge intersection algorithm, its result could not be treated by Face/Face intersection algorithm.</li>
</ul>
<h3><a class="anchor" id="occt_algorithms_11_2_2"></a>
Tolerances and inaccuracies</h3>
<p>The following limitations result from modeling errors or inaccuracies.</p>
<h4>Example: Intersection of planar faces</h4>
<p>Let us consider two planar rectangular faces <em>F1</em> and <em>F2</em>.</p>
<p>The intersection curve between the planes is curve <em>C12</em>. The curve produces a new intersection edge <em>EC12</em>. The edge goes through vertices <em>V1</em> and <em>V2</em> thanks to big tolerance values of vertices <em>Tol(V1)</em> and <em>Tol(V2)</em>. So, two straight edges <em>E12</em> and <em>EC12</em> go through two vertices, which is impossible in this case.</p>
<div class="image">
<img src="operations_image050.svg" alt="operations_image050.svg"/>
<div class="caption">
Intersecting Faces</div></div>
<p>The problem cannot be solved in general, because the length of <em>E12</em> can be infinite and the values of <em>Tol(V1)</em> and <em>Tol(V2)</em> theoretically can be infinite too.</p>
<p>In a particular case the problem can be solved in several ways:</p><ul>
<li>Reduce, if possible, the values of <em>Tol(V1)</em> and <em>Tol(V2)</em> (refinement of <em>F1</em>).</li>
<li>Analyze the value of <em>Tol(EC12)</em> and increase <em>Tol(EC12)</em> to get a common part between the edges <em>EC12</em> and <em>E12</em>. Then the common part will be rejected as there is an already existing edge <em>E12</em> for face <em>F1</em>.</li>
</ul>
<p>It is easy to see that if <em>C12</em> is slightly above the tolerance spheres of <em>V1</em> and <em>V2</em> the problem does not appear.</p>
<h4>Example: Intersection of two edges</h4>
<p>Let us consider two edges <em>E1</em> and <em>E2</em>, which have common vertices <em>V1</em> and <em>V2</em>. The edges <em>E1</em> and <em>E2</em> have 3D-curves <em>C1</em> and <em>C2. Tol(E1)=1.e<sup>-7</sup>, Tol(E2)=1.e<sup>-7</sup>.</em></p>
<p><em>C1</em> practically coincides in 3D with <em>C2</em>. The value of deflection is <em>Dmax</em> (e.g. <em>Dmax=1.e<sup>-6</sup></em>).</p>
<div class="image">
<img src="operations_image051.svg" alt="operations_image051.svg"/>
<div class="caption">
Intersecting Edges</div></div>
<p>The evident and prospective result should be the Common Block between <em>E1</em> and <em>E2</em>. However, the result of intersection differs.</p>
<div class="image">
<img src="operations_image052.svg" alt="operations_image052.svg"/>
<div class="caption">
Result of Intersection</div></div>
<p>The result contains three new vertices <em>Vx1, Vx2</em> and <em>Vx3</em>, 8 new edges <em>(V1, Vx1, Vx2, Vx3, V2)</em> and no Common Blocks. This is correct due to the source data: <em>Tol(E1)=1.e<sup>-7</sup>, Tol(E2)=1.e<sup>-7</sup></em> and <em>Dmax=1.e<sup>-6</sup></em>.</p>
<p>In this particular case the problem can be solved by several ways:</p><ul>
<li>Increase, if possible, the values <em>Tol(E1)</em> and <em>Tol(E2)</em> to get coincidence in 3D between <em>E1</em> and <em>E2</em> in terms of tolerance.</li>
<li>Replace <em>E1</em> by a more accurate model.</li>
</ul>
<p>The example can be extended from 1D (edges) to 2D (faces).</p>
<div class="image">
<img src="operations_image053.svg" alt="operations_image053.svg"/>
<div class="caption">
Intersecting Faces</div></div>
<p>The comments and recommendations are the same as for 1D case above.</p>
<h3><a class="anchor" id="occt_algorithms_11_2_3"></a>
Acquired Self-interferences</h3>
<h4>Example 1: Vertex and edge</h4>
<p>Let us consider vertex <em>V1</em> and edge <em>E2</em>.</p>
<div class="image">
<img src="operations_image054.svg" alt="operations_image054.svg"/>
<div class="caption">
Vertex and Edge</div></div>
<p>Vertex <em>V1</em> interferes with vertices <em>V12</em> and <em>V22</em>. So vertex <em>V21</em> should interfere with vertex <em>V22</em>, which is impossible because vertices <em>V21</em> and <em>V22</em> are the vertices of edge <em>E2</em>, thus <em>V21</em> is not equal to <em>V22</em>.</p>
<p>The problem cannot be solved in general, because the length can be as small as possible to provide validity of <em>E2</em> (in the extreme case: <em>Length (E2) = Tol(V21) + Tol(V22) + e,</em> where <em>e-&gt; 0</em>).</p>
<p>In a particular case the problem can be solved by refinement of arguments, i.e. by decreasing the values of <em>Tol(V21)</em>, <em>Tol(V22)</em> and <em>Tol(V1)</em>.</p>
<h4>Example 2: Vertex and wire</h4>
<p>Let us consider vertex <em>V2</em> and wire consisting of edges <em>E11</em> and <em>E12</em>.</p>
<div class="image">
<img src="operations_image055.svg" alt="operations_image055.svg"/>
<div class="caption">
Vertex and Wire</div></div>
<p>The arguments themselves are not self-intersected. Vertex <em>V2</em> interferes with edges <em>E11</em> and <em>E12</em>. Thus, edge <em>E11</em> should interfere with edge <em>E22</em>, but it is impossible because edges <em>E11</em> and <em>E12</em> cannot interfere by the condition.</p>
<p>The cases when a non-self-interfered argument (or its sub-shapes) become interfered due to the intersections with other arguments (or their sub-shapes) are considered as limitations for the Algorithms.</p>
<h1><a class="anchor" id="occt_algorithms_11a"></a>
Advanced Options</h1>
<p>The previous chapters describe so called Basic Operations. Most of tasks can be solved using Basic Operations. Nonetheless, there are cases that can not be solved straightforwardly by Basic Operations. The tasks are considered as limitations of Basic Operations.</p>
<p>The chapter is devoted to Advanced Options. In some cases the usage of Advanced Options allows overcoming the limitations, improving the quality of the result of operations, robustness and performance of the operators themselves.</p>
<h2><a class="anchor" id="occt_algorithms_11a_1"></a>
Fuzzy Boolean Operation</h2>
<p>Fuzzy Boolean operation is the option of Basic Operations (GFA, BOA, PA and SA), in which additional user-specified tolerance is used. This option allows operators to handle robustly cases of touching and near-coincident, misalignment entities of the arguments.</p>
<p>The Fuzzy option is useful on the shapes with gaps or embeddings between the entities of these shapes which are not covered by the tolerance values of these entities. Such shapes can be the result of modeling mistakes, or translating process, or import from other systems with loss of precision, or errors in some algorithms.</p>
<p>Most likely, the Basic Operations will give unsatisfactory results on such models. The result may contain unexpected and unwanted small entities, faulty entities (in terms of <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_check___analyzer.html">BRepCheck_Analyzer</a></em>), or there can be no result at all.</p>
<p>With the Fuzzy option it is possible to get the expected result &ndash; it is just necessary to define the appropriate value of fuzzy tolerance for the operation. To define that value it is necessary to measure the value of the gap (or the value of embedding depth) between the entities of the models, slightly increase it (to make the shifted entities coincident in terms of their tolerance plus the additional one) and pass it to the algorithm.</p>
<p>Fuzzy option is included in interface of Intersection Part (class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_algo___pave_filler.html">BOPAlgo_PaveFiller</a></em>) and application programming interface (class <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___boolean_operation.html">BRepAlgoAPI_BooleanOperation</a></em>)</p>
<h2><a class="anchor" id="occt_algorithms_11a_2"></a>
Examples</h2>
<p>The following examples demonstrate the advantages of usage Fuzzy option operations over the Basic Operations in typical situations.</p>
<h3><a class="anchor" id="occt_algorithms_11a_1_1"></a>
Case 1</h3>
<p>In this example the cylinder (shown in yellow and transparent) is subtracted from the box (shown in red). The cylinder is shifted by 5e<sup>-5</sup> relatively to the box along its axis (the distance between rear faces of the box and cylinder is 5e<sup>-5</sup>).</p>
<div class="image">
<img src="boolean_image121.png" alt="boolean_image121.png"/>
</div>
<p>The following results are obtained using Basic Operations and the Fuzzy ones with the fuzzy value 5e<sup>-5</sup>:</p>
<div class="image">
<img src="boolean_image122.png" alt="boolean_image122.png"/>
<div class="caption">
Result of CUT operation obtained with Basic Operations</div></div>
<div class="image">
<img src="boolean_image123.png" alt="boolean_image123.png"/>
<div class="caption">
Result of CUT operation obtained with Fuzzy Option</div></div>
<p>In this example Fuzzy option allows eliminating a very thin part of the result shape produced by Basic algorithm due to misalignment of rear faces of the box and the cylinder.</p>
<h3><a class="anchor" id="occt_algorithms_11a_1_2"></a>
Case 2</h3>
<p>In this example two boxes are fused. One of them has dimensions 10*10*10, and the other is 10*10.000001*10.000001 and adjacent to the first one. There is no gap in this case as the surfaces of the neighboring faces coincide, but one box is slightly greater than the other.</p>
<div class="image">
<img src="boolean_image124.png" alt="boolean_image124.png"/>
</div>
<p>The following results are obtained using Basic Operations and the Fuzzy ones with the fuzzy value 1e<sup>-6</sup>:</p>
<div class="image">
<img src="boolean_image125.png" alt="boolean_image125.png"/>
<div class="caption">
Result of CUT operation obtained with Basic Operations</div></div>
<div class="image">
<img src="boolean_image126.png" alt="boolean_image126.png"/>
<div class="caption">
Result of CUT operation obtained with Fuzzy Option</div></div>
<p>In this example Fuzzy option allows eliminating an extremely narrow face in the result produced by Basic operation.</p>
<h3><a class="anchor" id="occt_algorithms_11a_1_3"></a>
Case 3</h3>
<p>In this example the small planar face (shown in orange) is subtracted from the big one (shown in yellow). There is a gap 1e<sup>-5</sup> between the edges of these faces.</p>
<div class="image">
<img src="boolean_image127.png" alt="boolean_image127.png"/>
</div>
<p>The following results are obtained using Basic Operations and the Fuzzy ones with the fuzzy value 1e<sup>-5</sup>:</p>
<div class="image">
<img src="boolean_image128.png" alt="boolean_image128.png"/>
<div class="caption">
Result of CUT operation obtained with Basic Operations</div></div>
<div class="image">
<img src="boolean_image129.png" alt="boolean_image129.png"/>
<div class="caption">
Result of CUT operation obtained with Fuzzy Option</div></div>
<p>In this example Fuzzy options eliminated a pin-like protrusion resulting from the gap between edges of the argument faces.</p>
<h3><a class="anchor" id="occt_algorithms_11a_1_4"></a>
Case 4</h3>
<p>In this example the small edge is subtracted from the big one. The edges are overlapping not precisely, with max deviation between them equal to 5.28004e<sup>-5</sup>. We will use 6e<sup>-5</sup> value for Fuzzy option.</p>
<div class="image">
<img src="boolean_image130.png" alt="boolean_image130.png"/>
</div>
<p>The following results are obtained using Basic Operations and the Fuzzy ones with the fuzzy value 6e<sup>-5</sup>:</p>
<div class="image">
<img src="boolean_image131.png" alt="boolean_image131.png"/>
<div class="caption">
Result of CUT operation obtained with Basic Operations</div></div>
<div class="image">
<img src="boolean_image132.png" alt="boolean_image132.png"/>
<div class="caption">
Result of CUT operation obtained with Fuzzy Option</div></div>
<p>This example stresses not only the validity, but also the performance issue. The usage of Fuzzy option with the appropriate value allows processing the case much faster than with the pure Basic operation. The performance gain for the case is 45 (Processor: Intel(R) Core(TM) i5-3450 CPU @ 3.10 GHz).</p>
<h1><a class="anchor" id="occt_algorithms_11b"></a>
Usage</h1>
<p>The chapter contains some examples of the OCCT Boolean Component usage. The usage is possible on two levels: C++ and Tcl.</p>
<h2><a class="anchor" id="occt_algorithms_11b_1"></a>
Package BRepAlgoAPI</h2>
<p>The package <em>BRepAlgoAPI</em> provides the Application Programming Interface of the Boolean Component.</p>
<p>The package consists of the following classes:</p><ul>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___algo.html">BRepAlgoAPI_Algo</a></em> &ndash; the root class that provides the interface for algorithms.</li>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___builder_algo.html">BRepAlgoAPI_BuilderAlgo</a></em> &ndash; the class API level of General Fuse algorithm.</li>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___boolean_operation.html">BRepAlgoAPI_BooleanOperation</a></em> &ndash; the root class for the classes <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___fuse.html">BRepAlgoAPI_Fuse</a></em>. <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___common.html">BRepAlgoAPI_Common</a></em>, <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___cut.html">BRepAlgoAPI_Cut</a></em> and <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___section.html">BRepAlgoAPI_Section</a></em>.</li>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___fuse.html">BRepAlgoAPI_Fuse</a></em> &ndash; the class provides Boolean fusion operation.</li>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___common.html">BRepAlgoAPI_Common</a></em> &ndash; the class provides Boolean common operation.</li>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___cut.html">BRepAlgoAPI_Cut</a></em> &ndash; the class provides Boolean cut operation.</li>
<li><em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_rep_algo_a_p_i___section.html">BRepAlgoAPI_Section</a></em> &ndash; the class provides Boolean section operation.</li>
</ul>
<div class="image">
<img src="operations_image065.svg" alt="operations_image065.svg"/>
<div class="caption">
Diagram of BRepAlgoAPI package</div></div>
<p>The detailed description of the classes can be found in the corresponding .hxx files. The examples are below in this chapter.</p>
<h2><a class="anchor" id="occt_algorithms_11b_2"></a>
Package BOPTest</h2>
<p>The package <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_test.html">BOPTest</a></em> provides the usage of the Boolean Component on Tcl level. The method <em><a class="elRef" doxygen="D:/install/CR0-OCCT7_CR0-OCCT7/Windows-64-VC10-opt/OCCT/doc/refman/OCCT.tag:../../refman/html/" href="../../refman/html/class_b_o_p_test.html#a4c7258de9652281389994a8d4464f81f">BOPTest::APICommands</a></em> contains corresponding Tcl commands:</p>
<ul>
<li><em>bapibuild</em> &ndash; for General Fuse Operator;</li>
<li><em>bapibop</em> &ndash; for Boolean Operator and Section Operator.</li>
</ul>
<p>The examples of how to use the commands are below in this chapter.</p>
<h3><a class="anchor" id="occt_algorithms_11b_2_1"></a>
Case 1 General Fuse operation</h3>
<p>The following example illustrates how to use General Fuse operator:</p>
<h4>C++ Level</h4>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;TopoDS_Shape.hxx&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;TopTools_ListOfShape.hxx&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt;BRepAlgoAPI_BuilderAlgo.hxx&gt;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; {…</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  Standard_Boolean bRunParallel;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  Standard_Integer iErr;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  Standard_Real aFuzzyValue;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  BRepAlgoAPI_BuilderAlgo aBuilder;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  //</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // prepare the arguments</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  TopTools_ListOfShape&amp; aLS=…;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  //</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  bRunParallel=Standard_True;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  aFuzzyValue=2.1e-5;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  //</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  // set the arguments  </div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  aBuilder.SetArguments(aLS);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  // set parallel processing mode </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  // if  bRunParallel= Standard_True :  the parallel processing is switched on</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  // if  bRunParallel= Standard_False :  the parallel processing is switched off</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  aBuilder.SetRunParallel(bRunParallel);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  //</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  // set Fuzzy value</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  // if aFuzzyValue=0.: the Fuzzy option is off</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  //  if aFuzzyValue&gt;0.: the Fuzzy option is on</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  aBuilder.SetFuzzyValue(aFuzzyValue);</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  //</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  // run the algorithm </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  aBuilder.Build(); </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  iErr=aBuilder.ErrorStatus();</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  if (iErr) {</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    // an error treatment</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    return;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  }</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;  //</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  // result of the operation aR</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  const TopoDS_Shape&amp; aR=aBuilder.Shape();</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;…</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;}</div>
</div><!-- fragment --><h4>Tcl Level</h4>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# prepare the arguments</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;box b1 10 10 10 </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;box b2 3 4 5 10 10 10 </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;box b3 5 6 7 10 10 10 </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;#</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;# clear inner contents</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;bclearobjects; bcleartools;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;#</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;# set the arguments</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;baddobjects b1 b2 b3</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;# set parallel processing mode</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;# 1:  the parallel processing is switched on</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;# 0:  the parallel processing is switched off</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;brunparallel 1 </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;# set Fuzzy value</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;# 0.    : the Fuzzy option is off</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;# &gt;0. : the Fuzzy option is on</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;bfuzzyvalue 0.</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;#</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;# run the algorithm</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;# r is the result of the operation</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;bapibuild r </div>
</div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_11b_2_2"></a>
Case 2. Common operation</h3>
<p>The following example illustrates how to use Common operation:</p>
<h4>C++ Level</h4>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;TopoDS_Shape.hxx&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;TopTools_ListOfShape.hxx&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt; BRepAlgoAPI_Common.hxx&gt;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; {…</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  Standard_Boolean bRunParallel;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  Standard_Integer iErr;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  Standard_Real aFuzzyValue;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  BRepAlgoAPI_Common aBuilder;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // perpare the arguments</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  TopTools_ListOfShape&amp; aLS=…;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  TopTools_ListOfShape&amp; aLT=…;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  //</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  bRunParallel=Standard_True;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  aFuzzyValue=2.1e-5;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  //</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  // set the arguments  </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  aBuilder.SetArguments(aLS);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  aBuilder.SetTools(aLT);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  //    </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  // set parallel processing mode </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  // if  bRunParallel= Standard_True :  the parallel processing is switched on</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  // if  bRunParallel= Standard_False :  the parallel processing is switched off</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  aBuilder.SetRunParallel(bRunParallel);</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  //</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  // set Fuzzy value</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  // if aFuzzyValue=0.: the Fuzzy option is off</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  //  if aFuzzyValue&gt;0.: the Fuzzy option is on</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  aBuilder.SetFuzzyValue(aFuzzyValue);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  //</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  // run the algorithm </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  aBuilder.Build(); </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  iErr=aBuilder.ErrorStatus();</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  if (iErr) {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    // an error treatment</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    return;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  }</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  //</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  // result of the operation aR</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  const TopoDS_Shape&amp; aR=aBuilder.Shape();</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;…</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;}</div>
</div><!-- fragment --><h4>Tcl Level</h4>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# prepare the arguments</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;box b1 10 10 10 </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;box b2 7 0 4 10 10 10 </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;box b3 14 0 0 10 10 10 </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;#</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;# clear inner contents</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;bclearobjects; bcleartools;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;#</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;# set the arguments</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;baddobjects b1 b3</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;baddtools b2</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;#</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;# set parallel processing mode</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;# 1:  the parallel processing is switched on</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;# 0:  the parallel processing is switched off</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;brunparallel 1</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;#</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;# set Fuzzy value</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;# 0.    : the Fuzzy option is off</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;# &gt;0. : the Fuzzy option is on</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;bfuzzyvalue 0.</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;#</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;# run the algorithm</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;# r is the result of the operation</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;# 0 means Common operation</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;bapibop r 0</div>
</div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_11b_2_3"></a>
Case 3. Fuse operation</h3>
<p>The following example illustrates how to use Fuse operation:</p>
<h4>C++ Level</h4>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;TopoDS_Shape.hxx&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;TopTools_ListOfShape.hxx&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt; BRepAlgoAPI_Fuse.hxx&gt;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; {…</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  Standard_Boolean bRunParallel;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  Standard_Integer iErr;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  Standard_Real aFuzzyValue;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  BRepAlgoAPI_Fuse aBuilder;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // perpare the arguments</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  TopTools_ListOfShape&amp; aLS=…;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  TopTools_ListOfShape&amp; aLT=…;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  //</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  bRunParallel=Standard_True;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  aFuzzyValue=2.1e-5;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  //</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  // set the arguments  </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  aBuilder.SetArguments(aLS);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  aBuilder.SetTools(aLT);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  //    </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  // set parallel processing mode </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  // if  bRunParallel= Standard_True :  the parallel processing is switched on</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  // if  bRunParallel= Standard_False :  the parallel processing is switched off</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  aBuilder.SetRunParallel(bRunParallel);</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  //</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  // set Fuzzy value</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  // if aFuzzyValue=0.: the Fuzzy option is off</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  //  if aFuzzyValue&gt;0.: the Fuzzy option is on</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  aBuilder.SetFuzzyValue(aFuzzyValue);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  //</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  // run the algorithm </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  aBuilder.Build(); </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  iErr=aBuilder.ErrorStatus();</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  if (iErr) {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    // an error treatment</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    return;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  }</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  //</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  // result of the operation aR</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  const TopoDS_Shape&amp; aR=aBuilder.Shape();</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;…</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;}</div>
</div><!-- fragment --><h4>Tcl Level</h4>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# prepare the arguments</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;box b1 10 10 10 </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;box b2 7 0 4 10 10 10 </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;box b3 14 0 0 10 10 10 </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;#</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;# clear inner contents</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;bclearobjects; bcleartools;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;#</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;# set the arguments</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;baddobjects b1 b3</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;baddtools b2</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;#</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;# set parallel processing mode</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;# 1:  the parallel processing is switched on</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;# 0:  the parallel processing is switched off</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;brunparallel 1</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;#</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;# set Fuzzy value</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;# 0.    : the Fuzzy option is off</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;# &gt;0. : the Fuzzy option is on</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;bfuzzyvalue 0.</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;#</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;# run the algorithm</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;# r is the result of the operation</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;# 1 means Fuse operation</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;bapibop r 1</div>
</div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_11b_2_4"></a>
Case 4. Cut operation</h3>
<p>The following example illustrates how to use Cut operation:</p>
<h4>C++ Level</h4>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;TopoDS_Shape.hxx&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;TopTools_ListOfShape.hxx&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt; BRepAlgoAPI_Cut.hxx&gt;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; {…</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  Standard_Boolean bRunParallel;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  Standard_Integer iErr;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  Standard_Real aFuzzyValue;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  BRepAlgoAPI_Cut aBuilder;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // perpare the arguments</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  TopTools_ListOfShape&amp; aLS=…;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  TopTools_ListOfShape&amp; aLT=…;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  //</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  bRunParallel=Standard_True;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  aFuzzyValue=2.1e-5;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  //</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  // set the arguments  </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  aBuilder.SetArguments(aLS);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  aBuilder.SetTools(aLT);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  //    </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  // set parallel processing mode </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  // if  bRunParallel= Standard_True :  the parallel processing is switched on</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  // if  bRunParallel= Standard_False :  the parallel processing is switched off</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  aBuilder.SetRunParallel(bRunParallel);</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  //</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  // set Fuzzy value</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  // if aFuzzyValue=0.: the Fuzzy option is off</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  //  if aFuzzyValue&gt;0.: the Fuzzy option is on</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  aBuilder.SetFuzzyValue(aFuzzyValue);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  //</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  // run the algorithm </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  aBuilder.Build(); </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  iErr=aBuilder.ErrorStatus();</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  if (iErr) {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    // an error treatment</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    return;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  }</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  //</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  // result of the operation aR</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  const TopoDS_Shape&amp; aR=aBuilder.Shape();</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;…</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;}</div>
</div><!-- fragment --><h4>Tcl Level</h4>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# prepare the arguments</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;box b1 10 10 10 </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;box b2 7 0 4 10 10 10 </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;box b3 14 0 0 10 10 10 </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;#</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;# clear inner contents</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;bclearobjects; bcleartools;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;#</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;# set the arguments</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;baddobjects b1 b3</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;baddtools b2</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;#</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;# set parallel processing mode</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;# 1:  the parallel processing is switched on</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;# 0:  the parallel processing is switched off</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;brunparallel 1</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;#</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;# set Fuzzy value</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;# 0.    : the Fuzzy option is off</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;# &gt;0. : the Fuzzy option is on</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;bfuzzyvalue 0.</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;#</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;# run the algorithm</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;# r is the result of the operation</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;# 2 means Cut operation</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;bapibop r 2</div>
</div><!-- fragment --><h3><a class="anchor" id="occt_algorithms_11b_2_5"></a>
Case 5. Section operation</h3>
<p>The following example illustrates how to use Section operation:</p>
<h4>C++ Level</h4>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;TopoDS_Shape.hxx&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#include &lt;TopTools_ListOfShape.hxx&gt;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#include &lt; BRepAlgoAPI_Section.hxx&gt;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; {…</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  Standard_Boolean bRunParallel;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  Standard_Integer iErr;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  Standard_Real aFuzzyValue;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  BRepAlgoAPI_Section aBuilder;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  // perpare the arguments</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  TopTools_ListOfShape&amp; aLS=…;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  TopTools_ListOfShape&amp; aLT=…;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  //</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  bRunParallel=Standard_True;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  aFuzzyValue=2.1e-5;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  //</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  // set the arguments  </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  aBuilder.SetArguments(aLS);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  aBuilder.SetTools(aLT);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  //    </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  // set parallel processing mode </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  // if  bRunParallel= Standard_True :  the parallel processing is switched on</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  // if  bRunParallel= Standard_False :  the parallel processing is switched off</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  aBuilder.SetRunParallel(bRunParallel);</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  //</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  // set Fuzzy value</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  // if aFuzzyValue=0.: the Fuzzy option is off</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  //  if aFuzzyValue&gt;0.: the Fuzzy option is on</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;  aBuilder.SetFuzzyValue(aFuzzyValue);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;  //</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  // run the algorithm </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;  aBuilder.Build(); </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;  iErr=aBuilder.ErrorStatus();</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  if (iErr) {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    // an error treatment</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    return;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  }</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  //</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  // result of the operation aR</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  const TopoDS_Shape&amp; aR=aBuilder.Shape();</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;…</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;}</div>
</div><!-- fragment --><h4>Tcl Level</h4>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# prepare the arguments</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;box b1 10 10 10 </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;box b2 3 4 5 10 10 10 </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;box b3 5 6 7 10 10 10 </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;#</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;# clear inner contents</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;bclearobjects; bcleartools;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;#</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;# set the arguments</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;baddobjects b1 b3</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;baddtools b2</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;#</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;# set parallel processing mode</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;# 1:  the parallel processing is switched on</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;# 0:  the parallel processing is switched off</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;brunparallel 1</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;#</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;# set Fuzzy value</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;# 0.    : the Fuzzy option is off</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;# &gt;0. : the Fuzzy option is on</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;bfuzzyvalue 0.</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;#</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;# run the algorithm</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;# r is the result of the operation</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;# 4 means Section operation</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;bapibop r 4</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Apr 4 2016 21:57:45 for Open CASCADE Technology by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
