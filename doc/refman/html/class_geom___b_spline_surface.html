<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Open CASCADE Technology: Geom_BSplineSurface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open CASCADE Technology
   &#160;<span id="projectnumber">7.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Open CASCADE Technology</a></li><li class="navelem"><a class="el" href="module_modelingdata.html">Module ModelingData</a></li><li class="navelem"><a class="el" href="toolkit_tkg3d.html">Toolkit TKG3d</a></li>    <li class="navelem"><a class="el" href="package_geom.html">Package Geom </a>      </li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Geom_BSplineSurface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Describes a BSpline surface. In each parametric direction, a BSpline surface can be:  
 <a href="class_geom___b_spline_surface.html#details">More...</a></p>

<p><code>#include &lt;Geom_BSplineSurface.hxx&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Geom_BSplineSurface:</div>
<div class="dyncontent">
<div class="center"><img src="class_geom___b_spline_surface__inherit__graph.png" border="0" usemap="#_geom___b_spline_surface_inherit__map" alt="Inheritance graph"/></div>
<map name="_geom___b_spline_surface_inherit__map" id="_geom___b_spline_surface_inherit__map">
<area shape="rect" id="node2" href="class_geom___bounded_surface.html" title="The root class for bounded surfaces in 3D space. A bounded surface is defined by a rectangle in its 2..." alt="" coords="5,304,163,331"/>
<area shape="rect" id="node3" href="class_geom___surface.html" title="Describes the common behavior of surfaces in 3D space. The Geom package provides many implementations..." alt="" coords="30,229,137,256"/>
<area shape="rect" id="node4" href="class_geom___geometry.html" title="The abstract class Geometry for 3D space is the root class of all geometric objects from the Geom pac..." alt="" coords="23,155,144,181"/>
<area shape="rect" id="node5" href="class_m_mgt___t_shared.html" title="Intermediate class between Standard_Transient and descendants. The abstract class TShared is the root..." alt="" coords="29,80,139,107"/>
<area shape="rect" id="node6" href="class_standard___transient.html" title="Abstract class which forms the root of the entire Transient class hierarchy. " alt="" coords="17,5,151,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2cceaf7bab6ce3a234166ebbd9671f6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a2cceaf7bab6ce3a234166ebbd9671f6e">Geom_BSplineSurface</a> (const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#adfdc3203cd2dec875aa768e9e1c3ff47">Poles</a>, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#a06c429414907d5140650449b484b789e">UKnots</a>, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#a888f7a33d3d1c16d8ac559e85ec62b59">VKnots</a>, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;UMults, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;VMults, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#ac6eb9060f51268c20fa5c8590a284f41">UDegree</a>, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#a8bcab7b412c71bd546127941c3821d91">VDegree</a>, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> UPeriodic=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> VPeriodic=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>)</td></tr>
<tr class="memdesc:a2cceaf7bab6ce3a234166ebbd9671f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a non-rational b-spline surface (weights default value is 1.). The following conditions must be verified. 0 &lt; UDegree &lt;= MaxDegree. UKnots.Length() == UMults.Length() &gt;= 2 UKnots(i) &lt; UKnots(i+1) (Knots are increasing) 1 &lt;= UMults(i) &lt;= UDegree On a non uperiodic surface the first and last umultiplicities may be UDegree+1 (this is even recommanded if you want the curve to start and finish on the first and last pole). On a uperiodic surface the first and the last umultiplicities must be the same. on non-uperiodic surfaces Poles.ColLength() == Sum(UMults(i)) - UDegree - 1 &gt;= 2 on uperiodic surfaces Poles.ColLength() == Sum(UMults(i)) except the first or last The previous conditions for U holds also for V, with the RowLength of the poles.  <a href="#a2cceaf7bab6ce3a234166ebbd9671f6e">More...</a><br /></td></tr>
<tr class="separator:a2cceaf7bab6ce3a234166ebbd9671f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccceccdf053e7164b6a6ac38251b709"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4ccceccdf053e7164b6a6ac38251b709">Geom_BSplineSurface</a> (const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#adfdc3203cd2dec875aa768e9e1c3ff47">Poles</a>, const <a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#a4902acf8e043a038e9cc09f71268b16e">Weights</a>, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#a06c429414907d5140650449b484b789e">UKnots</a>, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;<a class="el" href="class_geom___b_spline_surface.html#a888f7a33d3d1c16d8ac559e85ec62b59">VKnots</a>, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;UMults, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;VMults, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#ac6eb9060f51268c20fa5c8590a284f41">UDegree</a>, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#a8bcab7b412c71bd546127941c3821d91">VDegree</a>, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> UPeriodic=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> VPeriodic=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>)</td></tr>
<tr class="memdesc:a4ccceccdf053e7164b6a6ac38251b709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a non-rational b-spline surface (weights default value is 1.).  <a href="#a4ccceccdf053e7164b6a6ac38251b709">More...</a><br /></td></tr>
<tr class="separator:a4ccceccdf053e7164b6a6ac38251b709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa7cb8c9a667e9afa729fa388b0f6c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aafa7cb8c9a667e9afa729fa388b0f6c6">ExchangeUV</a> ()</td></tr>
<tr class="memdesc:aafa7cb8c9a667e9afa729fa388b0f6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the u and v parametric directions on this BSpline surface. As a consequence:  <a href="#aafa7cb8c9a667e9afa729fa388b0f6c6">More...</a><br /></td></tr>
<tr class="separator:aafa7cb8c9a667e9afa729fa388b0f6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b39ea036cefa180705348855e68e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aa0b39ea036cefa180705348855e68e78">SetUPeriodic</a> ()</td></tr>
<tr class="memdesc:aa0b39ea036cefa180705348855e68e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the surface U periodic. Modifies this surface to be periodic in the U parametric direction. To become periodic in a given parametric direction a surface must be closed in that parametric direction, and the knot sequence relative to that direction must be periodic. To generate this periodic sequence of knots, the functions FirstUKnotIndex and LastUKnotIndex are used to compute I1 and I2. These are the indexes, in the knot array associated with the given parametric direction, of the knots that correspond to the first and last parameters of this BSpline surface in the given parametric direction. Hence the period is: Knots(I1) - Knots(I2) As a result, the knots and poles tables are modified. Exceptions Standard_ConstructionError if the surface is not closed in the given parametric direction.  <a href="#aa0b39ea036cefa180705348855e68e78">More...</a><br /></td></tr>
<tr class="separator:aa0b39ea036cefa180705348855e68e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1376ba80d7503a1519c35ee8fadfa2c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1376ba80d7503a1519c35ee8fadfa2c2">SetVPeriodic</a> ()</td></tr>
<tr class="memdesc:a1376ba80d7503a1519c35ee8fadfa2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the surface V periodic. Modifies this surface to be periodic in the V parametric direction. To become periodic in a given parametric direction a surface must be closed in that parametric direction, and the knot sequence relative to that direction must be periodic. To generate this periodic sequence of knots, the functions FirstVKnotIndex and LastVKnotIndex are used to compute I1 and I2. These are the indexes, in the knot array associated with the given parametric direction, of the knots that correspond to the first and last parameters of this BSpline surface in the given parametric direction. Hence the period is: Knots(I1) - Knots(I2) As a result, the knots and poles tables are modified. Exceptions Standard_ConstructionError if the surface is not closed in the given parametric direction.  <a href="#a1376ba80d7503a1519c35ee8fadfa2c2">More...</a><br /></td></tr>
<tr class="separator:a1376ba80d7503a1519c35ee8fadfa2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc80213dbcdd0c5d7633372014043f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a2fc80213dbcdd0c5d7633372014043f8">PeriodicNormalization</a> (<a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;U, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;V) const </td></tr>
<tr class="memdesc:a2fc80213dbcdd0c5d7633372014043f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the parameter normalized within the period if the surface is periodic : otherwise does not do anything  <a href="#a2fc80213dbcdd0c5d7633372014043f8">More...</a><br /></td></tr>
<tr class="separator:a2fc80213dbcdd0c5d7633372014043f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb456214cd15f2d60c1937fcd67bb967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#adb456214cd15f2d60c1937fcd67bb967">SetUOrigin</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Index)</td></tr>
<tr class="memdesc:adb456214cd15f2d60c1937fcd67bb967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the knot of index Index in the knots table in the corresponding parametric direction to be the origin of this periodic BSpline surface. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this BSpline surface is not periodic in the given parametric direction. Standard_DomainError if Index is outside the bounds of the knots table in the given parametric direction.  <a href="#adb456214cd15f2d60c1937fcd67bb967">More...</a><br /></td></tr>
<tr class="separator:adb456214cd15f2d60c1937fcd67bb967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5ff76aa0fb4ea90203db02da110fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ade5ff76aa0fb4ea90203db02da110fc2">SetVOrigin</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Index)</td></tr>
<tr class="memdesc:ade5ff76aa0fb4ea90203db02da110fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the knot of index Index in the knots table in the corresponding parametric direction to be the origin of this periodic BSpline surface. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this BSpline surface is not periodic in the given parametric direction. Standard_DomainError if Index is outside the bounds of the knots table in the given parametric direction.  <a href="#ade5ff76aa0fb4ea90203db02da110fc2">More...</a><br /></td></tr>
<tr class="separator:ade5ff76aa0fb4ea90203db02da110fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90ee06d28faf0e7992b4745ff6afbb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ac90ee06d28faf0e7992b4745ff6afbb0">SetUNotPeriodic</a> ()</td></tr>
<tr class="memdesc:ac90ee06d28faf0e7992b4745ff6afbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the surface U not periodic. Changes this BSpline surface into a non-periodic surface along U direction. If this surface is already non-periodic, it is not modified. Note: the poles and knots tables are modified.  <a href="#ac90ee06d28faf0e7992b4745ff6afbb0">More...</a><br /></td></tr>
<tr class="separator:ac90ee06d28faf0e7992b4745ff6afbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af335087f0d79b4fbaf141b50f6e46f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#af335087f0d79b4fbaf141b50f6e46f2b">SetVNotPeriodic</a> ()</td></tr>
<tr class="memdesc:af335087f0d79b4fbaf141b50f6e46f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the surface V not periodic. Changes this BSpline surface into a non-periodic surface along V direction. If this surface is already non-periodic, it is not modified. Note: the poles and knots tables are modified.  <a href="#af335087f0d79b4fbaf141b50f6e46f2b">More...</a><br /></td></tr>
<tr class="separator:af335087f0d79b4fbaf141b50f6e46f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0fcef877230439568db763810a1a28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aee0fcef877230439568db763810a1a28">UReverse</a> () override</td></tr>
<tr class="memdesc:aee0fcef877230439568db763810a1a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the orientation of this BSpline surface in the U parametric direction. The bounds of the surface are not changed but the given parametric direction is reversed. Hence the orientation of the surface is reversed. The knots and poles tables are modified.  <a href="#aee0fcef877230439568db763810a1a28">More...</a><br /></td></tr>
<tr class="separator:aee0fcef877230439568db763810a1a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba4946263dde87c57e9aa6329625767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aeba4946263dde87c57e9aa6329625767">VReverse</a> () override</td></tr>
<tr class="memdesc:aeba4946263dde87c57e9aa6329625767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the orientation of this BSpline surface in the V parametric direction. The bounds of the surface are not changed but the given parametric direction is reversed. Hence the orientation of the surface is reversed. The knots and poles tables are modified.  <a href="#aeba4946263dde87c57e9aa6329625767">More...</a><br /></td></tr>
<tr class="separator:aeba4946263dde87c57e9aa6329625767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422cbc544eb9024d69e7ca5a1d70a044"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a422cbc544eb9024d69e7ca5a1d70a044">UReversedParameter</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U) const  override</td></tr>
<tr class="memdesc:a422cbc544eb9024d69e7ca5a1d70a044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the u parameter on the modified surface, produced by reversing its U parametric direction, for the point of u parameter U, on this BSpline surface. For a BSpline surface, these functions return respectively:  <a href="#a422cbc544eb9024d69e7ca5a1d70a044">More...</a><br /></td></tr>
<tr class="separator:a422cbc544eb9024d69e7ca5a1d70a044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0b8ad3c9632364a387f82334ac658a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a2c0b8ad3c9632364a387f82334ac658a">VReversedParameter</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V) const  override</td></tr>
<tr class="memdesc:a2c0b8ad3c9632364a387f82334ac658a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the v parameter on the modified surface, produced by reversing its V parametric direction, for the point of v parameter V on this BSpline surface. For a BSpline surface, these functions return respectively:  <a href="#a2c0b8ad3c9632364a387f82334ac658a">More...</a><br /></td></tr>
<tr class="separator:a2c0b8ad3c9632364a387f82334ac658a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1518b83991ee2eea82617ffcb61b6125"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1518b83991ee2eea82617ffcb61b6125">IncreaseDegree</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#ac6eb9060f51268c20fa5c8590a284f41">UDegree</a>, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> <a class="el" href="class_geom___b_spline_surface.html#a8bcab7b412c71bd546127941c3821d91">VDegree</a>)</td></tr>
<tr class="memdesc:a1518b83991ee2eea82617ffcb61b6125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the degrees of this BSpline surface to UDegree and VDegree in the u and v parametric directions respectively. As a result, the tables of poles, weights and multiplicities are modified. The tables of knots is not changed. Note: Nothing is done if the given degree is less than or equal to the current degree in the corresponding parametric direction. Exceptions Standard_ConstructionError if UDegree or VDegree is greater than <a class="el" href="class_geom___b_spline_surface.html#ac1496de7ea0d7268ee94ba738c61dd0e" title="Returns the value of the maximum degree of the normalized B-spline basis functions in the u and v dir...">Geom_BSplineSurface::MaxDegree()</a>.  <a href="#a1518b83991ee2eea82617ffcb61b6125">More...</a><br /></td></tr>
<tr class="separator:a1518b83991ee2eea82617ffcb61b6125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eabcf868d4a08c60eeac5913b96095"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a99eabcf868d4a08c60eeac5913b96095">InsertUKnots</a> (const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Knots, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;Mults, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance=0.0, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Add=<a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a>)</td></tr>
<tr class="memdesc:a99eabcf868d4a08c60eeac5913b96095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts into the knots table for the U parametric direction of this BSpline surface:  <a href="#a99eabcf868d4a08c60eeac5913b96095">More...</a><br /></td></tr>
<tr class="separator:a99eabcf868d4a08c60eeac5913b96095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cec108eb6a0e03fc0548be17fd0692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ab0cec108eb6a0e03fc0548be17fd0692">InsertVKnots</a> (const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Knots, const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;Mults, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance=0.0, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Add=<a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a>)</td></tr>
<tr class="memdesc:ab0cec108eb6a0e03fc0548be17fd0692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts into the knots table for the V parametric direction of this BSpline surface:  <a href="#ab0cec108eb6a0e03fc0548be17fd0692">More...</a><br /></td></tr>
<tr class="separator:ab0cec108eb6a0e03fc0548be17fd0692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392ae7d2d902abef64aa61e4a04d0b63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a392ae7d2d902abef64aa61e4a04d0b63">RemoveUKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Index, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Tolerance)</td></tr>
<tr class="memdesc:a392ae7d2d902abef64aa61e4a04d0b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces to M the multiplicity of the knot of index Index in the U parametric direction. If M is 0, the knot is removed. With a modification of this type, the table of poles is also modified. Two different algorithms are used systematically to compute the new poles of the surface. For each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is checked. If this distance is less than Tolerance it ensures that the surface is not modified by more than Tolerance. Under these conditions, the function returns true; otherwise, it returns false. A low tolerance prevents modification of the surface. A high tolerance "smoothes" the surface. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of this BSpline surface.  <a href="#a392ae7d2d902abef64aa61e4a04d0b63">More...</a><br /></td></tr>
<tr class="separator:a392ae7d2d902abef64aa61e4a04d0b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba2001d928b071ceb0b5847ea56e74c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#abba2001d928b071ceb0b5847ea56e74c">RemoveVKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Index, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Tolerance)</td></tr>
<tr class="memdesc:abba2001d928b071ceb0b5847ea56e74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces to M the multiplicity of the knot of index Index in the V parametric direction. If M is 0, the knot is removed. With a modification of this type, the table of poles is also modified. Two different algorithms are used systematically to compute the new poles of the surface. For each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is checked. If this distance is less than Tolerance it ensures that the surface is not modified by more than Tolerance. Under these conditions, the function returns true; otherwise, it returns false. A low tolerance prevents modification of the surface. A high tolerance "smoothes" the surface. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of this BSpline surface.  <a href="#abba2001d928b071ceb0b5847ea56e74c">More...</a><br /></td></tr>
<tr class="separator:abba2001d928b071ceb0b5847ea56e74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f7df653df09054582143a163655682"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a89f7df653df09054582143a163655682">IncreaseUMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:a89f7df653df09054582143a163655682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the multiplicity of the knot of range UIndex in the UKnots sequence. M is the new multiplicity. M must be greater than the previous multiplicity and lower or equal to the degree of the surface in the U parametric direction. Raised if M is not in the range [1, UDegree].  <a href="#a89f7df653df09054582143a163655682">More...</a><br /></td></tr>
<tr class="separator:a89f7df653df09054582143a163655682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1bace85d54741492dfbeb8620d87b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a2e1bace85d54741492dfbeb8620d87b3">IncreaseUMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromI1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToI2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:a2e1bace85d54741492dfbeb8620d87b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases until order M the multiplicity of the set of knots FromI1,...., ToI2 in the U direction. This method can be used to make a B_spline surface into a PiecewiseBezier B_spline surface. If &lt;me&gt; was uniform, it can become non uniform.  <a href="#a2e1bace85d54741492dfbeb8620d87b3">More...</a><br /></td></tr>
<tr class="separator:a2e1bace85d54741492dfbeb8620d87b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53653996a730f05b0d43429646555f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a53653996a730f05b0d43429646555f71">IncrementUMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromI1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToI2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Step)</td></tr>
<tr class="memdesc:a53653996a730f05b0d43429646555f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the multiplicity of the consecutives uknots FromI1..ToI2 by step. The multiplicity of each knot FromI1,.....,ToI2 must be lower or equal to the UDegree of the B_spline.  <a href="#a53653996a730f05b0d43429646555f71">More...</a><br /></td></tr>
<tr class="separator:a53653996a730f05b0d43429646555f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0038875c69a1f5d9cea7a1658b50960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ac0038875c69a1f5d9cea7a1658b50960">IncreaseVMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:ac0038875c69a1f5d9cea7a1658b50960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the multiplicity of a knot in the V direction. M is the new multiplicity.  <a href="#ac0038875c69a1f5d9cea7a1658b50960">More...</a><br /></td></tr>
<tr class="separator:ac0038875c69a1f5d9cea7a1658b50960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265fe70c543a2126a9a6a8e9e0f599c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a265fe70c543a2126a9a6a8e9e0f599c4">IncreaseVMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromI1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToI2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:a265fe70c543a2126a9a6a8e9e0f599c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases until order M the multiplicity of the set of knots FromI1,...., ToI2 in the V direction. This method can be used to make a BSplineSurface into a PiecewiseBezier B_spline surface. If &lt;me&gt; was uniform, it can become non-uniform.  <a href="#a265fe70c543a2126a9a6a8e9e0f599c4">More...</a><br /></td></tr>
<tr class="separator:a265fe70c543a2126a9a6a8e9e0f599c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90604191893bb2dc3bca30b3447aa8bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a90604191893bb2dc3bca30b3447aa8bb">IncrementVMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromI1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToI2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Step)</td></tr>
<tr class="memdesc:a90604191893bb2dc3bca30b3447aa8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the multiplicity of the consecutives vknots FromI1..ToI2 by step. The multiplicity of each knot FromI1,.....,ToI2 must be lower or equal to the VDegree of the B_spline.  <a href="#a90604191893bb2dc3bca30b3447aa8bb">More...</a><br /></td></tr>
<tr class="separator:a90604191893bb2dc3bca30b3447aa8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4b07416d5e8d9a87f447e41cb477fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#abd4b07416d5e8d9a87f447e41cb477fb">InsertUKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Add=<a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a>)</td></tr>
<tr class="memdesc:abd4b07416d5e8d9a87f447e41cb477fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a knot value in the sequence of UKnots. If U is a knot value this method increases the multiplicity of the knot if the previous multiplicity was lower than M else it does nothing. The tolerance criterion is ParametricTolerance. ParametricTolerance should be greater or equal than Resolution from package gp.  <a href="#abd4b07416d5e8d9a87f447e41cb477fb">More...</a><br /></td></tr>
<tr class="separator:abd4b07416d5e8d9a87f447e41cb477fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1695d16dec722f5ee1cef55b980e95a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1695d16dec722f5ee1cef55b980e95a1">InsertVKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Add=<a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a>)</td></tr>
<tr class="memdesc:a1695d16dec722f5ee1cef55b980e95a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a knot value in the sequence of VKnots. If V is a knot value this method increases the multiplicity of the knot if the previous multiplicity was lower than M otherwise it does nothing. The tolerance criterion is ParametricTolerance. ParametricTolerance should be greater or equal than Resolution from package gp.  <a href="#a1695d16dec722f5ee1cef55b980e95a1">More...</a><br /></td></tr>
<tr class="separator:a1695d16dec722f5ee1cef55b980e95a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5fd0e3f825bd9ee2f39b5fd6c0d0b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a0d5fd0e3f825bd9ee2f39b5fd6c0d0b1">Segment</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U2, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V2)</td></tr>
<tr class="memdesc:a0d5fd0e3f825bd9ee2f39b5fd6c0d0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction. The control points are modified, the first and the last point are not the same. Warnings : Even if &lt;me&gt; is not closed it can become closed after the segmentation for example if U1 or U2 are out of the bounds of the surface &lt;me&gt; or if the surface makes loop. raises if U2 &lt; U1 or V2 &lt; V1. Standard_DomainError if U2 - U1 exceeds the uperiod for uperiodic surfaces. i.e. ((U2 - U1) - UPeriod) &gt; <a class="el" href="class_precision.html#a7430591942a5dd09f285176145f3236c" title="Used to test distances in parametric space on a default curve. ">Precision::PConfusion()</a>. Standard_DomainError if V2 - V1 exceeds the vperiod for vperiodic surfaces. i.e. ((V2 - V1) - VPeriod) &gt; <a class="el" href="class_precision.html#a7430591942a5dd09f285176145f3236c" title="Used to test distances in parametric space on a default curve. ">Precision::PConfusion()</a>).  <a href="#a0d5fd0e3f825bd9ee2f39b5fd6c0d0b1">More...</a><br /></td></tr>
<tr class="separator:a0d5fd0e3f825bd9ee2f39b5fd6c0d0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ea3f1c71d8ff14f5bf6dcdde40f318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a40ea3f1c71d8ff14f5bf6dcdde40f318">CheckAndSegment</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U2, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V2)</td></tr>
<tr class="memdesc:a40ea3f1c71d8ff14f5bf6dcdde40f318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction.  <a href="#a40ea3f1c71d8ff14f5bf6dcdde40f318">More...</a><br /></td></tr>
<tr class="separator:a40ea3f1c71d8ff14f5bf6dcdde40f318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad798e54698ffb43903d5716ae0cee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#abad798e54698ffb43903d5716ae0cee6">SetUKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> K)</td></tr>
<tr class="memdesc:abad798e54698ffb43903d5716ae0cee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the UKnots of range UIndex with K.  <a href="#abad798e54698ffb43903d5716ae0cee6">More...</a><br /></td></tr>
<tr class="separator:abad798e54698ffb43903d5716ae0cee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e744c1a00c58eed3f992caba7d1668a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a7e744c1a00c58eed3f992caba7d1668a">SetUKnots</a> (const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;UK)</td></tr>
<tr class="memdesc:a7e744c1a00c58eed3f992caba7d1668a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes all the U-knots of the surface. The multiplicity of the knots are not modified.  <a href="#a7e744c1a00c58eed3f992caba7d1668a">More...</a><br /></td></tr>
<tr class="separator:a7e744c1a00c58eed3f992caba7d1668a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739cf8b82973158284e38f9ab75fdfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a739cf8b82973158284e38f9ab75fdfce">SetUKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> K, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:a739cf8b82973158284e38f9ab75fdfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the value of the UKnots of range UIndex and increases its multiplicity.  <a href="#a739cf8b82973158284e38f9ab75fdfce">More...</a><br /></td></tr>
<tr class="separator:a739cf8b82973158284e38f9ab75fdfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5f7237bcab9e4186b958668f951913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#afe5f7237bcab9e4186b958668f951913">SetVKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> K)</td></tr>
<tr class="memdesc:afe5f7237bcab9e4186b958668f951913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the VKnots of range VIndex with K.  <a href="#afe5f7237bcab9e4186b958668f951913">More...</a><br /></td></tr>
<tr class="separator:afe5f7237bcab9e4186b958668f951913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e3a15de8c8c282b6e264122a829e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a84e3a15de8c8c282b6e264122a829e0c">SetVKnots</a> (const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;VK)</td></tr>
<tr class="memdesc:a84e3a15de8c8c282b6e264122a829e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes all the V-knots of the surface. The multiplicity of the knots are not modified.  <a href="#a84e3a15de8c8c282b6e264122a829e0c">More...</a><br /></td></tr>
<tr class="separator:a84e3a15de8c8c282b6e264122a829e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e4111066ef4b2a33a62d345934a1ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a54e4111066ef4b2a33a62d345934a1ea">SetVKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> K, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> M)</td></tr>
<tr class="memdesc:a54e4111066ef4b2a33a62d345934a1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the value of the VKnots of range VIndex and increases its multiplicity.  <a href="#a54e4111066ef4b2a33a62d345934a1ea">More...</a><br /></td></tr>
<tr class="separator:a54e4111066ef4b2a33a62d345934a1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7346d087526994dded6db66f291395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aeb7346d087526994dded6db66f291395">LocateU</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;I1, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;I2, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> WithKnotRepetition=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>) const </td></tr>
<tr class="memdesc:aeb7346d087526994dded6db66f291395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the parametric value U in the sequence of UKnots. If "WithKnotRepetition" is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. UKnots (I1) &lt;= U &lt;= UKnots (I2) . if I1 = I2 U is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 &lt; 1 =&gt; U &lt; UKnots(1) - Abs(ParametricTolerance) . if I2 &gt; NbUKnots =&gt; U &gt; UKnots(NbUKnots)+Abs(ParametricTolerance)  <a href="#aeb7346d087526994dded6db66f291395">More...</a><br /></td></tr>
<tr class="separator:aeb7346d087526994dded6db66f291395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb16e5ceee47bf6c56920a7ff9b30df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#acdb16e5ceee47bf6c56920a7ff9b30df">LocateV</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> ParametricTolerance, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;I1, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;I2, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> WithKnotRepetition=<a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a>) const </td></tr>
<tr class="memdesc:acdb16e5ceee47bf6c56920a7ff9b30df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates the parametric value V in the sequence of knots. If "WithKnotRepetition" is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. VKnots (I1) &lt;= V &lt;= VKnots (I2) . if I1 = I2 V is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 &lt; 1 =&gt; V &lt; VKnots(1) - Abs(ParametricTolerance) . if I2 &gt; NbVKnots =&gt; V &gt; VKnots(NbVKnots)+Abs(ParametricTolerance) poles insertion and removing The following methods are available only if the surface is Uniform or QuasiUniform in the considered direction The knot repartition is modified.  <a href="#acdb16e5ceee47bf6c56920a7ff9b30df">More...</a><br /></td></tr>
<tr class="separator:acdb16e5ceee47bf6c56920a7ff9b30df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d65634d8c16cf435ca655cba8a7c50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a25d65634d8c16cf435ca655cba8a7c50">SetPole</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P)</td></tr>
<tr class="memdesc:a25d65634d8c16cf435ca655cba8a7c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the pole of range (UIndex, VIndex) with P. If the surface is rational the weight of range (UIndex, VIndex) is not modified.  <a href="#a25d65634d8c16cf435ca655cba8a7c50">More...</a><br /></td></tr>
<tr class="separator:a25d65634d8c16cf435ca655cba8a7c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f15b262382cf0993d3f68e006a2475c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4f15b262382cf0993d3f68e006a2475c">SetPole</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="el" href="class_geom___b_spline_surface.html#a9a7bfe42269d26c41cb199ff70108467">Weight</a>)</td></tr>
<tr class="memdesc:a4f15b262382cf0993d3f68e006a2475c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes the pole and the weight of range (UIndex, VIndex) with P and W.  <a href="#a4f15b262382cf0993d3f68e006a2475c">More...</a><br /></td></tr>
<tr class="separator:a4f15b262382cf0993d3f68e006a2475c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf9582ad0b35728f241da3a05240501"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aacf9582ad0b35728f241da3a05240501">SetPoleCol</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;CPoles)</td></tr>
<tr class="memdesc:aacf9582ad0b35728f241da3a05240501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a column of poles or a part of this column. Raised if Vindex &lt; 1 or VIndex &gt; NbVPoles.  <a href="#aacf9582ad0b35728f241da3a05240501">More...</a><br /></td></tr>
<tr class="separator:aacf9582ad0b35728f241da3a05240501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f72b47dc1ef861bc0d8181dfcfa3295"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4f72b47dc1ef861bc0d8181dfcfa3295">SetPoleCol</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;CPoles, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;CPoleWeights)</td></tr>
<tr class="memdesc:a4f72b47dc1ef861bc0d8181dfcfa3295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a column of poles or a part of this column with the corresponding weights. If the surface was rational it can become non rational. If the surface was non rational it can become rational. Raised if Vindex &lt; 1 or VIndex &gt; NbVPoles.  <a href="#a4f72b47dc1ef861bc0d8181dfcfa3295">More...</a><br /></td></tr>
<tr class="separator:a4f72b47dc1ef861bc0d8181dfcfa3295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f66596b553b9f191350b8e4d700323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a93f66596b553b9f191350b8e4d700323">SetPoleRow</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;CPoles, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;CPoleWeights)</td></tr>
<tr class="memdesc:a93f66596b553b9f191350b8e4d700323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a row of poles or a part of this row with the corresponding weights. If the surface was rational it can become non rational. If the surface was non rational it can become rational. Raised if Uindex &lt; 1 or UIndex &gt; NbUPoles.  <a href="#a93f66596b553b9f191350b8e4d700323">More...</a><br /></td></tr>
<tr class="separator:a93f66596b553b9f191350b8e4d700323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1784d238248031bb52c51bdd46a5cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aff1784d238248031bb52c51bdd46a5cf">SetPoleRow</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;CPoles)</td></tr>
<tr class="memdesc:aff1784d238248031bb52c51bdd46a5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a row of poles or a part of this row. Raised if Uindex &lt; 1 or UIndex &gt; NbUPoles.  <a href="#aff1784d238248031bb52c51bdd46a5cf">More...</a><br /></td></tr>
<tr class="separator:aff1784d238248031bb52c51bdd46a5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387528d50fb7fe2abeef279e7a8aae86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a387528d50fb7fe2abeef279e7a8aae86">SetWeight</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> <a class="el" href="class_geom___b_spline_surface.html#a9a7bfe42269d26c41cb199ff70108467">Weight</a>)</td></tr>
<tr class="memdesc:a387528d50fb7fe2abeef279e7a8aae86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the weight of the pole of range UIndex, VIndex. If the surface was non rational it can become rational. If the surface was rational it can become non rational.  <a href="#a387528d50fb7fe2abeef279e7a8aae86">More...</a><br /></td></tr>
<tr class="separator:a387528d50fb7fe2abeef279e7a8aae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921397a82aed03feae72dd0f73dc823e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a921397a82aed03feae72dd0f73dc823e">SetWeightCol</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;CPoleWeights)</td></tr>
<tr class="memdesc:a921397a82aed03feae72dd0f73dc823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a column of weights of a part of this column.  <a href="#a921397a82aed03feae72dd0f73dc823e">More...</a><br /></td></tr>
<tr class="separator:a921397a82aed03feae72dd0f73dc823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9e2900caa95bf15c02124b1d4f115b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1d9e2900caa95bf15c02124b1d4f115b">SetWeightRow</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;CPoleWeights)</td></tr>
<tr class="memdesc:a1d9e2900caa95bf15c02124b1d4f115b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a row of weights or a part of this row.  <a href="#a1d9e2900caa95bf15c02124b1d4f115b">More...</a><br /></td></tr>
<tr class="separator:a1d9e2900caa95bf15c02124b1d4f115b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914512eca1f25878577aee7499a2583b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a914512eca1f25878577aee7499a2583b">MovePoint</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex2, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;UFirstIndex, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;ULastIndex, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;VFirstIndex, <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;VLastIndex)</td></tr>
<tr class="memdesc:a914512eca1f25878577aee7499a2583b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a point with parameter U and V to P. given u,v as parameters) to reach a new position UIndex1, UIndex2, VIndex1, VIndex2: indicates the poles which can be moved if Problem in BSplineBasis calculation, no change for the curve and UFirstIndex, VLastIndex = 0 VFirstIndex, VLastIndex = 0.  <a href="#a914512eca1f25878577aee7499a2583b">More...</a><br /></td></tr>
<tr class="separator:a914512eca1f25878577aee7499a2583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bb4e2240063d5c2e17716b40210159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a78bb4e2240063d5c2e17716b40210159">IsUClosed</a> () const  override</td></tr>
<tr class="memdesc:a78bb4e2240063d5c2e17716b40210159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first control points row and the last control points row are identical. The tolerance criterion is Resolution from package gp.  <a href="#a78bb4e2240063d5c2e17716b40210159">More...</a><br /></td></tr>
<tr class="separator:a78bb4e2240063d5c2e17716b40210159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d98ef8c666ada0afdb6f3cb0869c17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a00d98ef8c666ada0afdb6f3cb0869c17">IsVClosed</a> () const  override</td></tr>
<tr class="memdesc:a00d98ef8c666ada0afdb6f3cb0869c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the first control points column and the last last control points column are identical. The tolerance criterion is Resolution from package gp.  <a href="#a00d98ef8c666ada0afdb6f3cb0869c17">More...</a><br /></td></tr>
<tr class="separator:a00d98ef8c666ada0afdb6f3cb0869c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19931558c0e3ca544f3424bb177a2dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a19931558c0e3ca544f3424bb177a2dec">IsCNu</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> N) const  override</td></tr>
<tr class="memdesc:a19931558c0e3ca544f3424bb177a2dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if the order of continuity of the surface in the U direction is N. Raised if N &lt; 0.  <a href="#a19931558c0e3ca544f3424bb177a2dec">More...</a><br /></td></tr>
<tr class="separator:a19931558c0e3ca544f3424bb177a2dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf09c7bf5c62d9f9e4438f61ed89fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a6cf09c7bf5c62d9f9e4438f61ed89fed">IsCNv</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> N) const  override</td></tr>
<tr class="memdesc:a6cf09c7bf5c62d9f9e4438f61ed89fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if the order of continuity of the surface in the V direction is N. Raised if N &lt; 0.  <a href="#a6cf09c7bf5c62d9f9e4438f61ed89fed">More...</a><br /></td></tr>
<tr class="separator:a6cf09c7bf5c62d9f9e4438f61ed89fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c8c127ddd2cc219a823fe307bffafd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a58c8c127ddd2cc219a823fe307bffafd">IsUPeriodic</a> () const  override</td></tr>
<tr class="memdesc:a58c8c127ddd2cc219a823fe307bffafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if the surface is closed in the U direction and if the B-spline has been turned into a periodic surface using the function SetUPeriodic.  <a href="#a58c8c127ddd2cc219a823fe307bffafd">More...</a><br /></td></tr>
<tr class="separator:a58c8c127ddd2cc219a823fe307bffafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0759e88bef79d3ae98ed8d869f642e12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a0759e88bef79d3ae98ed8d869f642e12">IsURational</a> () const </td></tr>
<tr class="memdesc:a0759e88bef79d3ae98ed8d869f642e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns False if for each row of weights all the weights are identical. The tolerance criterion is resolution from package gp. Example : |1.0, 1.0, 1.0| if Weights = |0.5, 0.5, 0.5| returns False |2.0, 2.0, 2.0|.  <a href="#a0759e88bef79d3ae98ed8d869f642e12">More...</a><br /></td></tr>
<tr class="separator:a0759e88bef79d3ae98ed8d869f642e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b11a0862f6316db6dea691af2070063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a9b11a0862f6316db6dea691af2070063">IsVPeriodic</a> () const  override</td></tr>
<tr class="memdesc:a9b11a0862f6316db6dea691af2070063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if the surface is closed in the V direction and if the B-spline has been turned into a periodic surface using the function SetVPeriodic.  <a href="#a9b11a0862f6316db6dea691af2070063">More...</a><br /></td></tr>
<tr class="separator:a9b11a0862f6316db6dea691af2070063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bed2e62428bf9cb12b6d2caff5ea4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ab9bed2e62428bf9cb12b6d2caff5ea4b">IsVRational</a> () const </td></tr>
<tr class="memdesc:ab9bed2e62428bf9cb12b6d2caff5ea4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns False if for each column of weights all the weights are identical. The tolerance criterion is resolution from package gp. Examples : |1.0, 2.0, 0.5| if Weights = |1.0, 2.0, 0.5| returns False |1.0, 2.0, 0.5|.  <a href="#ab9bed2e62428bf9cb12b6d2caff5ea4b">More...</a><br /></td></tr>
<tr class="separator:ab9bed2e62428bf9cb12b6d2caff5ea4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb0b0bf1d999dea11fbc683087aec7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a9eb0b0bf1d999dea11fbc683087aec7c">Bounds</a> (<a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;U1, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;U2, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;V1, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;V2) const  override</td></tr>
<tr class="memdesc:a9eb0b0bf1d999dea11fbc683087aec7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parametric bounds of the surface. Warnings : These parametric values are the bounds of the array of knots UKnots and VKnots only if the first knots and the last knots have a multiplicity equal to UDegree + 1 or VDegree + 1.  <a href="#a9eb0b0bf1d999dea11fbc683087aec7c">More...</a><br /></td></tr>
<tr class="separator:a9eb0b0bf1d999dea11fbc683087aec7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ced26d2801bdfb2bb115f6e26fa0a3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_geom_abs___shape_8hxx.html#a943632453b69386bece6c091156b1ed5">GeomAbs_Shape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a6ced26d2801bdfb2bb115f6e26fa0a3c">Continuity</a> () const  override</td></tr>
<tr class="memdesc:a6ced26d2801bdfb2bb115f6e26fa0a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the continuity of the surface : C0 : only geometric continuity, C1 : continuity of the first derivative all along the Surface, C2 : continuity of the second derivative all along the Surface, C3 : continuity of the third derivative all along the Surface, CN : the order of continuity is infinite. A B-spline surface is infinitely continuously differentiable for the couple of parameters U, V such thats U != UKnots(i) and V != VKnots(i). The continuity of the surface at a knot value depends on the multiplicity of this knot. Example : If the surface is C1 in the V direction and C2 in the U direction this function returns Shape = C1.  <a href="#a6ced26d2801bdfb2bb115f6e26fa0a3c">More...</a><br /></td></tr>
<tr class="separator:a6ced26d2801bdfb2bb115f6e26fa0a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c4d423141477924b73938556f53596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a44c4d423141477924b73938556f53596">FirstUKnotIndex</a> () const </td></tr>
<tr class="memdesc:a44c4d423141477924b73938556f53596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Index of the UKnots which gives the first parametric value of the surface in the U direction. The UIso curve corresponding to this value is a boundary curve of the surface.  <a href="#a44c4d423141477924b73938556f53596">More...</a><br /></td></tr>
<tr class="separator:a44c4d423141477924b73938556f53596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d4a01b16526da24136ecac16ddf00b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ae1d4a01b16526da24136ecac16ddf00b">FirstVKnotIndex</a> () const </td></tr>
<tr class="memdesc:ae1d4a01b16526da24136ecac16ddf00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Index of the VKnots which gives the first parametric value of the surface in the V direction. The VIso curve corresponding to this knot is a boundary curve of the surface.  <a href="#ae1d4a01b16526da24136ecac16ddf00b">More...</a><br /></td></tr>
<tr class="separator:ae1d4a01b16526da24136ecac16ddf00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ac323d40ede2be6373579b3ab26145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a11ac323d40ede2be6373579b3ab26145">LastUKnotIndex</a> () const </td></tr>
<tr class="memdesc:a11ac323d40ede2be6373579b3ab26145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Index of the UKnots which gives the last parametric value of the surface in the U direction. The UIso curve corresponding to this knot is a boundary curve of the surface.  <a href="#a11ac323d40ede2be6373579b3ab26145">More...</a><br /></td></tr>
<tr class="separator:a11ac323d40ede2be6373579b3ab26145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3730f82b694e480a3654ebbf295f1e8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a3730f82b694e480a3654ebbf295f1e8f">LastVKnotIndex</a> () const </td></tr>
<tr class="memdesc:a3730f82b694e480a3654ebbf295f1e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Index of the VKnots which gives the last parametric value of the surface in the V direction. The VIso curve corresponding to this knot is a boundary curve of the surface.  <a href="#a3730f82b694e480a3654ebbf295f1e8f">More...</a><br /></td></tr>
<tr class="separator:a3730f82b694e480a3654ebbf295f1e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fda529f08492ee9dd128bc2d2feeed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4fda529f08492ee9dd128bc2d2feeed9">NbUKnots</a> () const </td></tr>
<tr class="memdesc:a4fda529f08492ee9dd128bc2d2feeed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of knots in the U direction.  <a href="#a4fda529f08492ee9dd128bc2d2feeed9">More...</a><br /></td></tr>
<tr class="separator:a4fda529f08492ee9dd128bc2d2feeed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c623b7d762afd5deae229509ed34a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a0c623b7d762afd5deae229509ed34a25">NbUPoles</a> () const </td></tr>
<tr class="memdesc:a0c623b7d762afd5deae229509ed34a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of poles in the U direction.  <a href="#a0c623b7d762afd5deae229509ed34a25">More...</a><br /></td></tr>
<tr class="separator:a0c623b7d762afd5deae229509ed34a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf551a12004b19b070eee96d7e70173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#abdf551a12004b19b070eee96d7e70173">NbVKnots</a> () const </td></tr>
<tr class="memdesc:abdf551a12004b19b070eee96d7e70173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of knots in the V direction.  <a href="#abdf551a12004b19b070eee96d7e70173">More...</a><br /></td></tr>
<tr class="separator:abdf551a12004b19b070eee96d7e70173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bf93fe24a03bc5a41be3351f8f7453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ab9bf93fe24a03bc5a41be3351f8f7453">NbVPoles</a> () const </td></tr>
<tr class="memdesc:ab9bf93fe24a03bc5a41be3351f8f7453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of poles in the V direction.  <a href="#ab9bf93fe24a03bc5a41be3351f8f7453">More...</a><br /></td></tr>
<tr class="separator:ab9bf93fe24a03bc5a41be3351f8f7453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb26726d77b7d4819d3281f79f15220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgp___pnt.html">gp_Pnt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a5fb26726d77b7d4819d3281f79f15220">Pole</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex) const </td></tr>
<tr class="memdesc:a5fb26726d77b7d4819d3281f79f15220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pole of range (UIndex, VIndex).  <a href="#a5fb26726d77b7d4819d3281f79f15220">More...</a><br /></td></tr>
<tr class="separator:a5fb26726d77b7d4819d3281f79f15220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdc3203cd2dec875aa768e9e1c3ff47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#adfdc3203cd2dec875aa768e9e1c3ff47">Poles</a> (<a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;P) const </td></tr>
<tr class="memdesc:adfdc3203cd2dec875aa768e9e1c3ff47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the poles of the B-spline surface.  <a href="#adfdc3203cd2dec875aa768e9e1c3ff47">More...</a><br /></td></tr>
<tr class="separator:adfdc3203cd2dec875aa768e9e1c3ff47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee1b58eae821cf9f037403c7d543733"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aeee1b58eae821cf9f037403c7d543733">Poles</a> () const </td></tr>
<tr class="memdesc:aeee1b58eae821cf9f037403c7d543733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the poles of the B-spline surface.  <a href="#aeee1b58eae821cf9f037403c7d543733">More...</a><br /></td></tr>
<tr class="separator:aeee1b58eae821cf9f037403c7d543733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eb9060f51268c20fa5c8590a284f41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ac6eb9060f51268c20fa5c8590a284f41">UDegree</a> () const </td></tr>
<tr class="memdesc:ac6eb9060f51268c20fa5c8590a284f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the degree of the normalized B-splines Ni,n in the U direction.  <a href="#ac6eb9060f51268c20fa5c8590a284f41">More...</a><br /></td></tr>
<tr class="separator:ac6eb9060f51268c20fa5c8590a284f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5190b5a7d8f5fad084605d39973d371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aa5190b5a7d8f5fad084605d39973d371">UKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex) const </td></tr>
<tr class="memdesc:aa5190b5a7d8f5fad084605d39973d371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Knot value of range UIndex. Raised if UIndex &lt; 1 or UIndex &gt; NbUKnots.  <a href="#aa5190b5a7d8f5fad084605d39973d371">More...</a><br /></td></tr>
<tr class="separator:aa5190b5a7d8f5fad084605d39973d371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f4c334713e5114d8035b70ec4dc346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_geom_abs___b_spl_knot_distribution_8hxx.html#a07138acc09f2b0c0b28245bb079c825d">GeomAbs_BSplKnotDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a87f4c334713e5114d8035b70ec4dc346">UKnotDistribution</a> () const </td></tr>
<tr class="memdesc:a87f4c334713e5114d8035b70ec4dc346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot in the U direction the B-spline surface can be :  <a href="#a87f4c334713e5114d8035b70ec4dc346">More...</a><br /></td></tr>
<tr class="separator:a87f4c334713e5114d8035b70ec4dc346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c429414907d5140650449b484b789e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a06c429414907d5140650449b484b789e">UKnots</a> (<a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Ku) const </td></tr>
<tr class="memdesc:a06c429414907d5140650449b484b789e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the knots in the U direction.  <a href="#a06c429414907d5140650449b484b789e">More...</a><br /></td></tr>
<tr class="separator:a06c429414907d5140650449b484b789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55db9e9628b79bc93f595d5ef4c490b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aa55db9e9628b79bc93f595d5ef4c490b">UKnots</a> () const </td></tr>
<tr class="memdesc:aa55db9e9628b79bc93f595d5ef4c490b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the knots in the U direction.  <a href="#aa55db9e9628b79bc93f595d5ef4c490b">More...</a><br /></td></tr>
<tr class="separator:aa55db9e9628b79bc93f595d5ef4c490b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c432fc6d24e8ab4c35546a4a89a9922"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a0c432fc6d24e8ab4c35546a4a89a9922">UKnotSequence</a> (<a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Ku) const </td></tr>
<tr class="memdesc:a0c432fc6d24e8ab4c35546a4a89a9922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}.  <a href="#a0c432fc6d24e8ab4c35546a4a89a9922">More...</a><br /></td></tr>
<tr class="separator:a0c432fc6d24e8ab4c35546a4a89a9922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71ddb06ff50f4bc750a22cb7027cbd7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ab71ddb06ff50f4bc750a22cb7027cbd7">UKnotSequence</a> () const </td></tr>
<tr class="memdesc:ab71ddb06ff50f4bc750a22cb7027cbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}.  <a href="#ab71ddb06ff50f4bc750a22cb7027cbd7">More...</a><br /></td></tr>
<tr class="separator:ab71ddb06ff50f4bc750a22cb7027cbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fa5337b5b7aed234237187c2c332d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a00fa5337b5b7aed234237187c2c332d0">UMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex) const </td></tr>
<tr class="memdesc:a00fa5337b5b7aed234237187c2c332d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicity value of knot of range UIndex in the u direction. Raised if UIndex &lt; 1 or UIndex &gt; NbUKnots.  <a href="#a00fa5337b5b7aed234237187c2c332d0">More...</a><br /></td></tr>
<tr class="separator:a00fa5337b5b7aed234237187c2c332d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba09e9712333bd0bf3a3135854f7c9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aba09e9712333bd0bf3a3135854f7c9e2">UMultiplicities</a> (<a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;Mu) const </td></tr>
<tr class="memdesc:aba09e9712333bd0bf3a3135854f7c9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicities of the knots in the U direction.  <a href="#aba09e9712333bd0bf3a3135854f7c9e2">More...</a><br /></td></tr>
<tr class="separator:aba09e9712333bd0bf3a3135854f7c9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061fd82f0f9f959250a7b37bbd50b1fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a061fd82f0f9f959250a7b37bbd50b1fa">UMultiplicities</a> () const </td></tr>
<tr class="memdesc:a061fd82f0f9f959250a7b37bbd50b1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicities of the knots in the U direction.  <a href="#a061fd82f0f9f959250a7b37bbd50b1fa">More...</a><br /></td></tr>
<tr class="separator:a061fd82f0f9f959250a7b37bbd50b1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcab7b412c71bd546127941c3821d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a8bcab7b412c71bd546127941c3821d91">VDegree</a> () const </td></tr>
<tr class="memdesc:a8bcab7b412c71bd546127941c3821d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the degree of the normalized B-splines Ni,d in the V direction.  <a href="#a8bcab7b412c71bd546127941c3821d91">More...</a><br /></td></tr>
<tr class="separator:a8bcab7b412c71bd546127941c3821d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c98b1703f60efe3e16aff888d959b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a8c98b1703f60efe3e16aff888d959b59">VKnot</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex) const </td></tr>
<tr class="memdesc:a8c98b1703f60efe3e16aff888d959b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Knot value of range VIndex. Raised if VIndex &lt; 1 or VIndex &gt; NbVKnots.  <a href="#a8c98b1703f60efe3e16aff888d959b59">More...</a><br /></td></tr>
<tr class="separator:a8c98b1703f60efe3e16aff888d959b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c7cac0d083656d3c83dbe17bc3fda2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_geom_abs___b_spl_knot_distribution_8hxx.html#a07138acc09f2b0c0b28245bb079c825d">GeomAbs_BSplKnotDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ab7c7cac0d083656d3c83dbe17bc3fda2">VKnotDistribution</a> () const </td></tr>
<tr class="memdesc:ab7c7cac0d083656d3c83dbe17bc3fda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot in the V direction the B-spline surface can be :  <a href="#ab7c7cac0d083656d3c83dbe17bc3fda2">More...</a><br /></td></tr>
<tr class="separator:ab7c7cac0d083656d3c83dbe17bc3fda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888f7a33d3d1c16d8ac559e85ec62b59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a888f7a33d3d1c16d8ac559e85ec62b59">VKnots</a> (<a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Kv) const </td></tr>
<tr class="memdesc:a888f7a33d3d1c16d8ac559e85ec62b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the knots in the V direction.  <a href="#a888f7a33d3d1c16d8ac559e85ec62b59">More...</a><br /></td></tr>
<tr class="separator:a888f7a33d3d1c16d8ac559e85ec62b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25120b626c4ae2fe6699978bef67e9e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ab25120b626c4ae2fe6699978bef67e9e">VKnots</a> () const </td></tr>
<tr class="memdesc:ab25120b626c4ae2fe6699978bef67e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the knots in the V direction.  <a href="#ab25120b626c4ae2fe6699978bef67e9e">More...</a><br /></td></tr>
<tr class="separator:ab25120b626c4ae2fe6699978bef67e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9c38221762c3e09618df920a5841b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a0f9c38221762c3e09618df920a5841b0">VKnotSequence</a> (<a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;Kv) const </td></tr>
<tr class="memdesc:a0f9c38221762c3e09618df920a5841b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Kv = {k1, k1, k1, k2, k3, k3, k4, k4, k4}.  <a href="#a0f9c38221762c3e09618df920a5841b0">More...</a><br /></td></tr>
<tr class="separator:a0f9c38221762c3e09618df920a5841b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35cc121170a4f0c31ae18bdc10a0667"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ae35cc121170a4f0c31ae18bdc10a0667">VKnotSequence</a> () const </td></tr>
<tr class="memdesc:ae35cc121170a4f0c31ae18bdc10a0667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}.  <a href="#ae35cc121170a4f0c31ae18bdc10a0667">More...</a><br /></td></tr>
<tr class="separator:ae35cc121170a4f0c31ae18bdc10a0667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aa91e2726f2bf5122222e9e0474d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a15aa91e2726f2bf5122222e9e0474d40">VMultiplicity</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex) const </td></tr>
<tr class="memdesc:a15aa91e2726f2bf5122222e9e0474d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicity value of knot of range VIndex in the v direction. Raised if VIndex &lt; 1 or VIndex &gt; NbVKnots.  <a href="#a15aa91e2726f2bf5122222e9e0474d40">More...</a><br /></td></tr>
<tr class="separator:a15aa91e2726f2bf5122222e9e0474d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbca5fe88b07f43ffdf63c9003c68bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a8dbca5fe88b07f43ffdf63c9003c68bf">VMultiplicities</a> (<a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;Mv) const </td></tr>
<tr class="memdesc:a8dbca5fe88b07f43ffdf63c9003c68bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicities of the knots in the V direction.  <a href="#a8dbca5fe88b07f43ffdf63c9003c68bf">More...</a><br /></td></tr>
<tr class="separator:a8dbca5fe88b07f43ffdf63c9003c68bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61806d01e38a1a7e17890c013538ea4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ae61806d01e38a1a7e17890c013538ea4">VMultiplicities</a> () const </td></tr>
<tr class="memdesc:ae61806d01e38a1a7e17890c013538ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicities of the knots in the V direction.  <a href="#ae61806d01e38a1a7e17890c013538ea4">More...</a><br /></td></tr>
<tr class="separator:ae61806d01e38a1a7e17890c013538ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7bfe42269d26c41cb199ff70108467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a9a7bfe42269d26c41cb199ff70108467">Weight</a> (const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> UIndex, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> VIndex) const </td></tr>
<tr class="memdesc:a9a7bfe42269d26c41cb199ff70108467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weight value of range UIndex, VIndex.  <a href="#a9a7bfe42269d26c41cb199ff70108467">More...</a><br /></td></tr>
<tr class="separator:a9a7bfe42269d26c41cb199ff70108467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4902acf8e043a038e9cc09f71268b16e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a4902acf8e043a038e9cc09f71268b16e">Weights</a> (<a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a> &amp;W) const </td></tr>
<tr class="memdesc:a4902acf8e043a038e9cc09f71268b16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weights of the B-spline surface.  <a href="#a4902acf8e043a038e9cc09f71268b16e">More...</a><br /></td></tr>
<tr class="separator:a4902acf8e043a038e9cc09f71268b16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f59a7654187ef68e5980d988a60b2a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a02f59a7654187ef68e5980d988a60b2a">Weights</a> () const </td></tr>
<tr class="memdesc:a02f59a7654187ef68e5980d988a60b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weights of the B-spline surface. value and derivatives computation.  <a href="#a02f59a7654187ef68e5980d988a60b2a">More...</a><br /></td></tr>
<tr class="separator:a02f59a7654187ef68e5980d988a60b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2f90a91d005198f9c48be4419cd4bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a8d2f90a91d005198f9c48be4419cd4bc">D0</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P) const  override</td></tr>
<tr class="memdesc:a8d2f90a91d005198f9c48be4419cd4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point of parameter U,V on the surface.  <a href="#a8d2f90a91d005198f9c48be4419cd4bc">More...</a><br /></td></tr>
<tr class="separator:a8d2f90a91d005198f9c48be4419cd4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6859aee1031a20e7c3f5728c61d39a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a0c6859aee1031a20e7c3f5728c61d39a">D1</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V) const  override</td></tr>
<tr class="memdesc:a0c6859aee1031a20e7c3f5728c61d39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the continuity of the surface is not C1.  <a href="#a0c6859aee1031a20e7c3f5728c61d39a">More...</a><br /></td></tr>
<tr class="separator:a0c6859aee1031a20e7c3f5728c61d39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f025ad0472ba9347a348d12a346547b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a5f025ad0472ba9347a348d12a346547b">D2</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2UV) const  override</td></tr>
<tr class="memdesc:a5f025ad0472ba9347a348d12a346547b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the continuity of the surface is not C2.  <a href="#a5f025ad0472ba9347a348d12a346547b">More...</a><br /></td></tr>
<tr class="separator:a5f025ad0472ba9347a348d12a346547b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436b4769ce0890e9c102f50fc63f5531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a436b4769ce0890e9c102f50fc63f5531">D3</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2UV, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3UUV, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3UVV) const  override</td></tr>
<tr class="memdesc:a436b4769ce0890e9c102f50fc63f5531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the continuity of the surface is not C3.  <a href="#a436b4769ce0890e9c102f50fc63f5531">More...</a><br /></td></tr>
<tr class="separator:a436b4769ce0890e9c102f50fc63f5531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c134df6633a4ec31098a9daae348dd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgp___vec.html">gp_Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a1c134df6633a4ec31098a9daae348dd6">DN</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nu, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nv) const  override</td></tr>
<tr class="memdesc:a1c134df6633a4ec31098a9daae348dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nu is the order of derivation in the U parametric direction and Nv is the order of derivation in the V parametric direction.  <a href="#a1c134df6633a4ec31098a9daae348dd6">More...</a><br /></td></tr>
<tr class="separator:a1c134df6633a4ec31098a9daae348dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5f82e7e1f1691083df1e0de6fe0b3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a7d5f82e7e1f1691083df1e0de6fe0b3c">LocalD0</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P) const </td></tr>
<tr class="memdesc:a7d5f82e7e1f1691083df1e0de6fe0b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#a7d5f82e7e1f1691083df1e0de6fe0b3c">More...</a><br /></td></tr>
<tr class="separator:a7d5f82e7e1f1691083df1e0de6fe0b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfd752e4802fb1d268f4443d263120c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a2dfd752e4802fb1d268f4443d263120c">LocalD1</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V) const </td></tr>
<tr class="memdesc:a2dfd752e4802fb1d268f4443d263120c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the local continuity of the surface is not C1 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#a2dfd752e4802fb1d268f4443d263120c">More...</a><br /></td></tr>
<tr class="separator:a2dfd752e4802fb1d268f4443d263120c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf64a41ca9fa3014955339b26d44940"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a2bf64a41ca9fa3014955339b26d44940">LocalD2</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2UV) const </td></tr>
<tr class="memdesc:a2bf64a41ca9fa3014955339b26d44940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the local continuity of the surface is not C2 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#a2bf64a41ca9fa3014955339b26d44940">More...</a><br /></td></tr>
<tr class="separator:a2bf64a41ca9fa3014955339b26d44940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fa5a57d280cebcf52ecbf262d29dbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a36fa5a57d280cebcf52ecbf262d29dbb">LocalD3</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2, <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D1V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D2UV, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3U, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3V, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3UUV, <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;D3UVV) const </td></tr>
<tr class="memdesc:a36fa5a57d280cebcf52ecbf262d29dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the local continuity of the surface is not C3 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#a36fa5a57d280cebcf52ecbf262d29dbb">More...</a><br /></td></tr>
<tr class="separator:a36fa5a57d280cebcf52ecbf262d29dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cdf679e30e20f545361126d2697c0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgp___vec.html">gp_Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a02cdf679e30e20f545361126d2697c0b">LocalDN</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nu, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Nv) const </td></tr>
<tr class="memdesc:a02cdf679e30e20f545361126d2697c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if the local continuity of the surface is not CNu between the knots FromUK1, ToUK2 and CNv between the knots FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#a02cdf679e30e20f545361126d2697c0b">More...</a><br /></td></tr>
<tr class="separator:a02cdf679e30e20f545361126d2697c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1b04a9ced3c467c97ee62797abeb7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgp___pnt.html">gp_Pnt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#abd1b04a9ced3c467c97ee62797abeb7f">LocalValue</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromUK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToUK2, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> FromVK1, const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> ToVK2) const </td></tr>
<tr class="memdesc:abd1b04a9ced3c467c97ee62797abeb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point of parameter U, V on the BSpline surface patch defines between the knots UK1 UK2, VK1, VK2. U can be out of the bounds [Knot UK1, Knot UK2] and V can be outof the bounds [Knot VK1, Knot VK2] but for the computation we only use the definition of the surface between these knot values. Raises if FromUK1 = ToUK2 or FromVK1 = ToVK2.  <a href="#abd1b04a9ced3c467c97ee62797abeb7f">More...</a><br /></td></tr>
<tr class="separator:abd1b04a9ced3c467c97ee62797abeb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b22f80346b0cdd5bd730d3994b404e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a62b22f80346b0cdd5bd730d3994b404e">UIso</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U) const  override</td></tr>
<tr class="memdesc:a62b22f80346b0cdd5bd730d3994b404e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the U isoparametric curve. A B-spline curve is returned.  <a href="#a62b22f80346b0cdd5bd730d3994b404e">More...</a><br /></td></tr>
<tr class="separator:a62b22f80346b0cdd5bd730d3994b404e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcef9e159a1ac29910919587583d5ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#afcef9e159a1ac29910919587583d5ccc">VIso</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V) const  override</td></tr>
<tr class="memdesc:afcef9e159a1ac29910919587583d5ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the V isoparametric curve. A B-spline curve is returned.  <a href="#afcef9e159a1ac29910919587583d5ccc">More...</a><br /></td></tr>
<tr class="separator:afcef9e159a1ac29910919587583d5ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b57d6e1bc6b848997655e2f1d811fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a3b57d6e1bc6b848997655e2f1d811fa7">UIso</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> CheckRational) const </td></tr>
<tr class="memdesc:a3b57d6e1bc6b848997655e2f1d811fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the U isoparametric curve. If CheckRational=False, no try to make it non-rational. A B-spline curve is returned.  <a href="#a3b57d6e1bc6b848997655e2f1d811fa7">More...</a><br /></td></tr>
<tr class="separator:a3b57d6e1bc6b848997655e2f1d811fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec90a5e14c6455e945ef61c81d4d16a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#afec90a5e14c6455e945ef61c81d4d16a">VIso</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V, const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> CheckRational) const </td></tr>
<tr class="memdesc:afec90a5e14c6455e945ef61c81d4d16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the V isoparametric curve. If CheckRational=False, no try to make it non-rational. A B-spline curve is returned. transformations.  <a href="#afec90a5e14c6455e945ef61c81d4d16a">More...</a><br /></td></tr>
<tr class="separator:afec90a5e14c6455e945ef61c81d4d16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d26b8258d892130a39c05f119401fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a8d26b8258d892130a39c05f119401fea">Transform</a> (const <a class="el" href="classgp___trsf.html">gp_Trsf</a> &amp;T) override</td></tr>
<tr class="memdesc:a8d26b8258d892130a39c05f119401fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the transformation T to this BSpline surface.  <a href="#a8d26b8258d892130a39c05f119401fea">More...</a><br /></td></tr>
<tr class="separator:a8d26b8258d892130a39c05f119401fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e184acbeca9bf93faf8ed888d37e1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#a86e184acbeca9bf93faf8ed888d37e1e">Resolution</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Tolerance3D, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;UTolerance, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;VTolerance)</td></tr>
<tr class="memdesc:a86e184acbeca9bf93faf8ed888d37e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes two tolerance values for this BSpline surface, based on the given tolerance in 3D space Tolerance3D. The tolerances computed are:  <a href="#a86e184acbeca9bf93faf8ed888d37e1e">More...</a><br /></td></tr>
<tr class="separator:a86e184acbeca9bf93faf8ed888d37e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c5f7695f47b095a35da1583ffb24a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#aa1c5f7695f47b095a35da1583ffb24a2">Copy</a> () const  override</td></tr>
<tr class="memdesc:aa1c5f7695f47b095a35da1583ffb24a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object which is a copy of this BSpline surface.  <a href="#aa1c5f7695f47b095a35da1583ffb24a2">More...</a><br /></td></tr>
<tr class="separator:aa1c5f7695f47b095a35da1583ffb24a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_geom___surface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_geom___surface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_geom___surface.html">Geom_Surface</a></td></tr>
<tr class="memitem:ae1150256680b3796a4f3a8b9e66db9d6 inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___surface.html">Geom_Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#ae1150256680b3796a4f3a8b9e66db9d6">UReversed</a> () const </td></tr>
<tr class="memdesc:ae1150256680b3796a4f3a8b9e66db9d6 inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the U direction of parametrization of &lt;me&gt;. The bounds of the surface are not modified. A copy of &lt;me&gt; is returned.  <a href="#ae1150256680b3796a4f3a8b9e66db9d6">More...</a><br /></td></tr>
<tr class="separator:ae1150256680b3796a4f3a8b9e66db9d6 inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a99aad06118c6415ad05cd168078eb inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___surface.html">Geom_Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#aa9a99aad06118c6415ad05cd168078eb">VReversed</a> () const </td></tr>
<tr class="memdesc:aa9a99aad06118c6415ad05cd168078eb inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the V direction of parametrization of &lt;me&gt;. The bounds of the surface are not modified. A copy of &lt;me&gt; is returned.  <a href="#aa9a99aad06118c6415ad05cd168078eb">More...</a><br /></td></tr>
<tr class="separator:aa9a99aad06118c6415ad05cd168078eb inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b14d895cdc502a72ba5dd575d55b6f inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#ae6b14d895cdc502a72ba5dd575d55b6f">TransformParameters</a> (<a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;U, <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;V, const <a class="el" href="classgp___trsf.html">gp_Trsf</a> &amp;T) const </td></tr>
<tr class="memdesc:ae6b14d895cdc502a72ba5dd575d55b6f inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the parameters on the transformed surface for the transform of the point of parameters U,V on &lt;me&gt;.  <a href="#ae6b14d895cdc502a72ba5dd575d55b6f">More...</a><br /></td></tr>
<tr class="separator:ae6b14d895cdc502a72ba5dd575d55b6f inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5852d24185f4c5ea001a6bbcbbe82394 inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgp___g_trsf2d.html">gp_GTrsf2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#a5852d24185f4c5ea001a6bbcbbe82394">ParametricTransformation</a> (const <a class="el" href="classgp___trsf.html">gp_Trsf</a> &amp;T) const </td></tr>
<tr class="memdesc:a5852d24185f4c5ea001a6bbcbbe82394 inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 2d transformation used to find the new parameters of a point on the transformed surface.  <a href="#a5852d24185f4c5ea001a6bbcbbe82394">More...</a><br /></td></tr>
<tr class="separator:a5852d24185f4c5ea001a6bbcbbe82394 inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0a83f757be969d5eb7086e6b155251 inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#a8e0a83f757be969d5eb7086e6b155251">UPeriod</a> () const </td></tr>
<tr class="memdesc:a8e0a83f757be969d5eb7086e6b155251 inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the period of this surface in the u parametric direction. raises if the surface is not uperiodic.  <a href="#a8e0a83f757be969d5eb7086e6b155251">More...</a><br /></td></tr>
<tr class="separator:a8e0a83f757be969d5eb7086e6b155251 inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20ac5418ba6fd630851130038fb9de0 inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#ad20ac5418ba6fd630851130038fb9de0">VPeriod</a> () const </td></tr>
<tr class="memdesc:ad20ac5418ba6fd630851130038fb9de0 inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the period of this surface in the v parametric direction. raises if the surface is not vperiodic.  <a href="#ad20ac5418ba6fd630851130038fb9de0">More...</a><br /></td></tr>
<tr class="separator:ad20ac5418ba6fd630851130038fb9de0 inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8748d91761aabbfc79508fc4213f985 inherit pub_methods_class_geom___surface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgp___pnt.html">gp_Pnt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___surface.html#ac8748d91761aabbfc79508fc4213f985">Value</a> (const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> U, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> V) const </td></tr>
<tr class="memdesc:ac8748d91761aabbfc79508fc4213f985 inherit pub_methods_class_geom___surface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the point of parameter U on the surface.  <a href="#ac8748d91761aabbfc79508fc4213f985">More...</a><br /></td></tr>
<tr class="separator:ac8748d91761aabbfc79508fc4213f985 inherit pub_methods_class_geom___surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_geom___geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_geom___geometry')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_geom___geometry.html">Geom_Geometry</a></td></tr>
<tr class="memitem:a5534b9918fc2e64ab2b3cdc48d14e603 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a5534b9918fc2e64ab2b3cdc48d14e603">Mirror</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P)</td></tr>
<tr class="memdesc:a5534b9918fc2e64ab2b3cdc48d14e603 inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the symmetrical transformation of a Geometry with respect to the point P which is the center of the symmetry.  <a href="#a5534b9918fc2e64ab2b3cdc48d14e603">More...</a><br /></td></tr>
<tr class="separator:a5534b9918fc2e64ab2b3cdc48d14e603 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2186df0fea82f372c81cf9416019e8 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a9f2186df0fea82f372c81cf9416019e8">Mirror</a> (const <a class="el" href="classgp___ax1.html">gp_Ax1</a> &amp;A1)</td></tr>
<tr class="memdesc:a9f2186df0fea82f372c81cf9416019e8 inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the symmetrical transformation of a Geometry with respect to an axis placement which is the axis of the symmetry.  <a href="#a9f2186df0fea82f372c81cf9416019e8">More...</a><br /></td></tr>
<tr class="separator:a9f2186df0fea82f372c81cf9416019e8 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57306578533b91fbec9001ece88d845f inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a57306578533b91fbec9001ece88d845f">Mirror</a> (const <a class="el" href="classgp___ax2.html">gp_Ax2</a> &amp;A2)</td></tr>
<tr class="memdesc:a57306578533b91fbec9001ece88d845f inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the symmetrical transformation of a Geometry with respect to a plane. The axis placement A2 locates the plane of the symmetry : (Location, XDirection, YDirection).  <a href="#a57306578533b91fbec9001ece88d845f">More...</a><br /></td></tr>
<tr class="separator:a57306578533b91fbec9001ece88d845f inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dda3db34908b9aed5812911c8f75799 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a7dda3db34908b9aed5812911c8f75799">Rotate</a> (const <a class="el" href="classgp___ax1.html">gp_Ax1</a> &amp;A1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Ang)</td></tr>
<tr class="memdesc:a7dda3db34908b9aed5812911c8f75799 inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates a Geometry. A1 is the axis of the rotation. Ang is the angular value of the rotation in radians.  <a href="#a7dda3db34908b9aed5812911c8f75799">More...</a><br /></td></tr>
<tr class="separator:a7dda3db34908b9aed5812911c8f75799 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0328beeef84f5d820e3432627fc8110 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#ae0328beeef84f5d820e3432627fc8110">Scale</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> S)</td></tr>
<tr class="memdesc:ae0328beeef84f5d820e3432627fc8110 inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a Geometry. S is the scaling value.  <a href="#ae0328beeef84f5d820e3432627fc8110">More...</a><br /></td></tr>
<tr class="separator:ae0328beeef84f5d820e3432627fc8110 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9847ae89540ce9efac6d428dd9f5d2 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a7b9847ae89540ce9efac6d428dd9f5d2">Translate</a> (const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;V)</td></tr>
<tr class="memdesc:a7b9847ae89540ce9efac6d428dd9f5d2 inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a Geometry. V is the vector of the tanslation.  <a href="#a7b9847ae89540ce9efac6d428dd9f5d2">More...</a><br /></td></tr>
<tr class="separator:a7b9847ae89540ce9efac6d428dd9f5d2 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669eb0869256860f74d1c496b7a4e1dd inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a669eb0869256860f74d1c496b7a4e1dd">Translate</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P1, const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P2)</td></tr>
<tr class="memdesc:a669eb0869256860f74d1c496b7a4e1dd inherit pub_methods_class_geom___geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a Geometry from the point P1 to the point P2.  <a href="#a669eb0869256860f74d1c496b7a4e1dd">More...</a><br /></td></tr>
<tr class="separator:a669eb0869256860f74d1c496b7a4e1dd inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4748846dca2b5d90593a98f189b166 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#aea4748846dca2b5d90593a98f189b166">Mirrored</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P) const </td></tr>
<tr class="separator:aea4748846dca2b5d90593a98f189b166 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a63702ef2ab7c129e8e078cf32edf1a inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a6a63702ef2ab7c129e8e078cf32edf1a">Mirrored</a> (const <a class="el" href="classgp___ax1.html">gp_Ax1</a> &amp;A1) const </td></tr>
<tr class="separator:a6a63702ef2ab7c129e8e078cf32edf1a inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaca1c4cff5493566316c96133f8af0a inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#aaaca1c4cff5493566316c96133f8af0a">Mirrored</a> (const <a class="el" href="classgp___ax2.html">gp_Ax2</a> &amp;A2) const </td></tr>
<tr class="separator:aaaca1c4cff5493566316c96133f8af0a inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3b20968b15743f847f3f434241dd41 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#aff3b20968b15743f847f3f434241dd41">Rotated</a> (const <a class="el" href="classgp___ax1.html">gp_Ax1</a> &amp;A1, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Ang) const </td></tr>
<tr class="separator:aff3b20968b15743f847f3f434241dd41 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6007dcfc8b5588ba4ef0e4b1bac3a5 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a0b6007dcfc8b5588ba4ef0e4b1bac3a5">Scaled</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P, const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> S) const </td></tr>
<tr class="separator:a0b6007dcfc8b5588ba4ef0e4b1bac3a5 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab49b2c0de489374f6793b34f93b3b5 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a5ab49b2c0de489374f6793b34f93b3b5">Transformed</a> (const <a class="el" href="classgp___trsf.html">gp_Trsf</a> &amp;T) const </td></tr>
<tr class="separator:a5ab49b2c0de489374f6793b34f93b3b5 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9214cd3d98aeb7ac8bbfc18063ac02 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#a5f9214cd3d98aeb7ac8bbfc18063ac02">Translated</a> (const <a class="el" href="classgp___vec.html">gp_Vec</a> &amp;V) const </td></tr>
<tr class="separator:a5f9214cd3d98aeb7ac8bbfc18063ac02 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2df4641c6babcc7102085378c08dd1 inherit pub_methods_class_geom___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___geometry.html#acd2df4641c6babcc7102085378c08dd1">Translated</a> (const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P1, const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;P2) const </td></tr>
<tr class="separator:acd2df4641c6babcc7102085378c08dd1 inherit pub_methods_class_geom___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_m_mgt___t_shared"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_m_mgt___t_shared')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_m_mgt___t_shared.html">MMgt_TShared</a></td></tr>
<tr class="memitem:ad06a82d94ee81a242fff530ca31e50ec inherit pub_methods_class_m_mgt___t_shared"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_mgt___t_shared.html#ad06a82d94ee81a242fff530ca31e50ec">Delete</a> () const  override</td></tr>
<tr class="memdesc:ad06a82d94ee81a242fff530ca31e50ec inherit pub_methods_class_m_mgt___t_shared"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory deallocator for transient classes.  <a href="#ad06a82d94ee81a242fff530ca31e50ec">More...</a><br /></td></tr>
<tr class="separator:ad06a82d94ee81a242fff530ca31e50ec inherit pub_methods_class_m_mgt___t_shared"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_standard___transient"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_standard___transient')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_standard___transient.html">Standard_Transient</a></td></tr>
<tr class="memitem:a28c37998a6ef973851f456840b34de64 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a28c37998a6ef973851f456840b34de64">Standard_Transient</a> ()</td></tr>
<tr class="memdesc:a28c37998a6ef973851f456840b34de64 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="#a28c37998a6ef973851f456840b34de64">More...</a><br /></td></tr>
<tr class="separator:a28c37998a6ef973851f456840b34de64 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857f1ada543829be61dbd804ae47c52f inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a857f1ada543829be61dbd804ae47c52f">Standard_Transient</a> (const <a class="el" href="class_standard___transient.html">Standard_Transient</a> &amp;)</td></tr>
<tr class="memdesc:a857f1ada543829be61dbd804ae47c52f inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor &ndash; does nothing.  <a href="#a857f1ada543829be61dbd804ae47c52f">More...</a><br /></td></tr>
<tr class="separator:a857f1ada543829be61dbd804ae47c52f inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16b65e2f6a1922f42ce51f6b67c3c33 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_standard___transient.html">Standard_Transient</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#ad16b65e2f6a1922f42ce51f6b67c3c33">operator=</a> (const <a class="el" href="class_standard___transient.html">Standard_Transient</a> &amp;)</td></tr>
<tr class="memdesc:ad16b65e2f6a1922f42ce51f6b67c3c33 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator, needed to avoid copying reference counter.  <a href="#ad16b65e2f6a1922f42ce51f6b67c3c33">More...</a><br /></td></tr>
<tr class="separator:ad16b65e2f6a1922f42ce51f6b67c3c33 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534846a08f64eaba4d764ec84b0e7728 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a534846a08f64eaba4d764ec84b0e7728">~Standard_Transient</a> ()</td></tr>
<tr class="memdesc:a534846a08f64eaba4d764ec84b0e7728 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor must be virtual.  <a href="#a534846a08f64eaba4d764ec84b0e7728">More...</a><br /></td></tr>
<tr class="separator:a534846a08f64eaba4d764ec84b0e7728 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0bdbc9fa9c54e3f21311b38a3bee5d inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; <a class="el" href="class_standard___type.html">Standard_Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#acd0bdbc9fa9c54e3f21311b38a3bee5d">DynamicType</a> () const </td></tr>
<tr class="memdesc:acd0bdbc9fa9c54e3f21311b38a3bee5d inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type descriptor about this object.  <a href="#acd0bdbc9fa9c54e3f21311b38a3bee5d">More...</a><br /></td></tr>
<tr class="separator:acd0bdbc9fa9c54e3f21311b38a3bee5d inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626f2da69d2a4e374d1866ab32ba44f6 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a626f2da69d2a4e374d1866ab32ba44f6">IsInstance</a> (const <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; <a class="el" href="class_standard___type.html">Standard_Type</a> &gt; &amp;theType) const </td></tr>
<tr class="memdesc:a626f2da69d2a4e374d1866ab32ba44f6 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a true value if this is an instance of Type.  <a href="#a626f2da69d2a4e374d1866ab32ba44f6">More...</a><br /></td></tr>
<tr class="separator:a626f2da69d2a4e374d1866ab32ba44f6 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880932595df48d187c2caad05ebd5904 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a880932595df48d187c2caad05ebd5904">IsInstance</a> (const <a class="el" href="_standard___type_def_8hxx.html#afe390e6ed87845e0029a5a5e887a9d5c">Standard_CString</a> theTypeName) const </td></tr>
<tr class="memdesc:a880932595df48d187c2caad05ebd5904 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a true value if this is an instance of TypeName.  <a href="#a880932595df48d187c2caad05ebd5904">More...</a><br /></td></tr>
<tr class="separator:a880932595df48d187c2caad05ebd5904 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6495565f4f20702ffc67fd05e8f35e43 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a6495565f4f20702ffc67fd05e8f35e43">IsKind</a> (const <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; <a class="el" href="class_standard___type.html">Standard_Type</a> &gt; &amp;theType) const </td></tr>
<tr class="memdesc:a6495565f4f20702ffc67fd05e8f35e43 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is an instance of Type or an instance of any class that inherits from Type. Note that multiple inheritance is not supported by OCCT RTTI mechanism.  <a href="#a6495565f4f20702ffc67fd05e8f35e43">More...</a><br /></td></tr>
<tr class="separator:a6495565f4f20702ffc67fd05e8f35e43 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60872f2521bad04a386d4b70fb3c3d32 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a60872f2521bad04a386d4b70fb3c3d32">IsKind</a> (const <a class="el" href="_standard___type_def_8hxx.html#afe390e6ed87845e0029a5a5e887a9d5c">Standard_CString</a> theTypeName) const </td></tr>
<tr class="memdesc:a60872f2521bad04a386d4b70fb3c3d32 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is an instance of TypeName or an instance of any class that inherits from TypeName. Note that multiple inheritance is not supported by OCCT RTTI mechanism.  <a href="#a60872f2521bad04a386d4b70fb3c3d32">More...</a><br /></td></tr>
<tr class="separator:a60872f2521bad04a386d4b70fb3c3d32 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedefc14e8356eb52c1553477d3d750c3 inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_standard___transient.html">Standard_Transient</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#aedefc14e8356eb52c1553477d3d750c3">This</a> () const </td></tr>
<tr class="memdesc:aedefc14e8356eb52c1553477d3d750c3 inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-const pointer to this object (like const_cast). For protection against creating handle to objects allocated in stack or call from constructor, it will raise exception Standard_ProgramError if reference counter is zero.  <a href="#aedefc14e8356eb52c1553477d3d750c3">More...</a><br /></td></tr>
<tr class="separator:aedefc14e8356eb52c1553477d3d750c3 inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a9af026a2e7f9b7901a1efd52bfb0a inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a04a9af026a2e7f9b7901a1efd52bfb0a">GetRefCount</a> () const </td></tr>
<tr class="memdesc:a04a9af026a2e7f9b7901a1efd52bfb0a inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference counter of this object.  <a href="#a04a9af026a2e7f9b7901a1efd52bfb0a">More...</a><br /></td></tr>
<tr class="separator:a04a9af026a2e7f9b7901a1efd52bfb0a inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9389a6d0e2e190e1b60dc10d106718f inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#ae9389a6d0e2e190e1b60dc10d106718f">IncrementRefCounter</a> () const </td></tr>
<tr class="memdesc:ae9389a6d0e2e190e1b60dc10d106718f inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the reference counter of this object.  <a href="#ae9389a6d0e2e190e1b60dc10d106718f">More...</a><br /></td></tr>
<tr class="separator:ae9389a6d0e2e190e1b60dc10d106718f inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514dd1f84b25329de5dedc48025d92ef inherit pub_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a514dd1f84b25329de5dedc48025d92ef">DecrementRefCounter</a> () const </td></tr>
<tr class="memdesc:a514dd1f84b25329de5dedc48025d92ef inherit pub_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the reference counter of this object; returns the decremented value.  <a href="#a514dd1f84b25329de5dedc48025d92ef">More...</a><br /></td></tr>
<tr class="separator:a514dd1f84b25329de5dedc48025d92ef inherit pub_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac1496de7ea0d7268ee94ba738c61dd0e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geom___b_spline_surface.html#ac1496de7ea0d7268ee94ba738c61dd0e">MaxDegree</a> ()</td></tr>
<tr class="memdesc:ac1496de7ea0d7268ee94ba738c61dd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the maximum degree of the normalized B-spline basis functions in the u and v directions.  <a href="#ac1496de7ea0d7268ee94ba738c61dd0e">More...</a><br /></td></tr>
<tr class="separator:ac1496de7ea0d7268ee94ba738c61dd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_standard___transient"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_standard___transient')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_standard___transient.html">Standard_Transient</a></td></tr>
<tr class="memitem:a0f5a2b0f378a5a58ca42d50092ae637a inherit pub_static_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a0f5a2b0f378a5a58ca42d50092ae637a">get_type_name</a> ()</td></tr>
<tr class="memdesc:a0f5a2b0f378a5a58ca42d50092ae637a inherit pub_static_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type descriptor about this object.  <a href="#a0f5a2b0f378a5a58ca42d50092ae637a">More...</a><br /></td></tr>
<tr class="separator:a0f5a2b0f378a5a58ca42d50092ae637a inherit pub_static_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7d7949596235d35c1a5b7a4bbd77f2 inherit pub_static_methods_class_standard___transient"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classopencascade_1_1handle.html">opencascade::handle</a>&lt; <a class="el" href="class_standard___type.html">Standard_Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a7b7d7949596235d35c1a5b7a4bbd77f2">get_type_descriptor</a> ()</td></tr>
<tr class="memdesc:a7b7d7949596235d35c1a5b7a4bbd77f2 inherit pub_static_methods_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type descriptor of <a class="el" href="class_standard___transient.html" title="Abstract class which forms the root of the entire Transient class hierarchy. ">Standard_Transient</a> class.  <a href="#a7b7d7949596235d35c1a5b7a4bbd77f2">More...</a><br /></td></tr>
<tr class="separator:a7b7d7949596235d35c1a5b7a4bbd77f2 inherit pub_static_methods_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_standard___transient"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_standard___transient')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_standard___transient.html">Standard_Transient</a></td></tr>
<tr class="memitem:a6cdf8e1478fba7bae45bcbc8c4e4ebb9 inherit pub_types_class_standard___transient"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_standard___transient.html#a6cdf8e1478fba7bae45bcbc8c4e4ebb9">base_type</a></td></tr>
<tr class="memdesc:a6cdf8e1478fba7bae45bcbc8c4e4ebb9 inherit pub_types_class_standard___transient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type descriptor about this object.  <a href="#a6cdf8e1478fba7bae45bcbc8c4e4ebb9">More...</a><br /></td></tr>
<tr class="separator:a6cdf8e1478fba7bae45bcbc8c4e4ebb9 inherit pub_types_class_standard___transient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Describes a BSpline surface. In each parametric direction, a BSpline surface can be: </p>
<ul>
<li>uniform or non-uniform,</li>
<li>rational or non-rational,</li>
<li>periodic or non-periodic. A BSpline surface is defined by:</li>
<li>its degrees, in the u and v parametric directions,</li>
<li>its periodic characteristic, in the u and v parametric directions,</li>
<li>a table of poles, also called control points (together with the associated weights if the surface is rational), and</li>
<li>a table of knots, together with the associated multiplicities. The degree of a <a class="el" href="class_geom___b_spline_surface.html" title="Describes a BSpline surface. In each parametric direction, a BSpline surface can be: ...">Geom_BSplineSurface</a> is limited to a value (25) which is defined and controlled by the system. This value is returned by the function MaxDegree. Poles and Weights Poles and Weights are manipulated using two associative double arrays:</li>
<li>the poles table, which is a double array of <a class="el" href="classgp___pnt.html" title="Defines a 3D cartesian point. ">gp_Pnt</a> points, and</li>
<li>the weights table, which is a double array of reals. The bounds of the poles and weights arrays are:</li>
<li>1 and NbUPoles for the row bounds (provided that the BSpline surface is not periodic in the u parametric direction), where NbUPoles is the number of poles of the surface in the u parametric direction, and</li>
<li>1 and NbVPoles for the column bounds (provided that the BSpline surface is not periodic in the v parametric direction), where NbVPoles is the number of poles of the surface in the v parametric direction. The poles of the surface are the points used to shape and reshape the surface. They comprise a rectangular network. If the surface is not periodic:</li>
<li>The points (1, 1), (NbUPoles, 1), (1, NbVPoles), and (NbUPoles, NbVPoles) are the four parametric "corners" of the surface.</li>
<li>The first column of poles and the last column of poles define two BSpline curves which delimit the surface in the v parametric direction. These are the v isoparametric curves corresponding to the two bounds of the v parameter.</li>
<li>The first row of poles and the last row of poles define two BSpline curves which delimit the surface in the u parametric direction. These are the u isoparametric curves corresponding to the two bounds of the u parameter. If the surface is periodic, these geometric properties are not verified. It is more difficult to define a geometrical significance for the weights. However they are useful for representing a quadric surface precisely. Moreover, if the weights of all the poles are equal, the surface has a polynomial equation, and hence is a "non-rational surface". The non-rational surface is a special, but frequently used, case, where all poles have identical weights. The weights are defined and used only in the case of a rational surface. The rational characteristic is defined in each parametric direction. A surface can be rational in the u parametric direction, and non-rational in the v parametric direction. Knots and Multiplicities For a <a class="el" href="class_geom___b_spline_surface.html" title="Describes a BSpline surface. In each parametric direction, a BSpline surface can be: ...">Geom_BSplineSurface</a> the table of knots is made up of two increasing sequences of reals, without repetition, one for each parametric direction. The multiplicities define the repetition of the knots. A BSpline surface comprises multiple contiguous patches, which are themselves polynomial or rational surfaces. The knots are the parameters of the isoparametric curves which limit these contiguous patches. The multiplicity of a knot on a BSpline surface (in a given parametric direction) is related to the degree of continuity of the surface at that knot in that parametric direction: Degree of continuity at knot(i) = Degree - Multi(i) where:</li>
<li>Degree is the degree of the BSpline surface in the given parametric direction, and</li>
<li>Multi(i) is the multiplicity of knot number i in the given parametric direction. There are some special cases, where the knots are regularly spaced in one parametric direction (i.e. the difference between two consecutive knots is a constant).</li>
<li>"Uniform": all the multiplicities are equal to 1.</li>
<li>"Quasi-uniform": all the multiplicities are equal to 1, except for the first and last knots in this parametric direction, and these are equal to Degree + 1.</li>
<li>"Piecewise Bezier": all the multiplicities are equal to Degree except for the first and last knots, which are equal to Degree + 1. This surface is a concatenation of Bezier patches in the given parametric direction. If the BSpline surface is not periodic in a given parametric direction, the bounds of the knots and multiplicities tables are 1 and NbKnots, where NbKnots is the number of knots of the BSpline surface in that parametric direction. If the BSpline surface is periodic in a given parametric direction, and there are k periodic knots and p periodic poles in that parametric direction:</li>
<li>the period is such that: period = Knot(k+1) - Knot(1), and</li>
<li>the poles and knots tables in that parametric direction can be considered as infinite tables, such that: Knot(i+k) = Knot(i) + period, and Pole(i+p) = Pole(i) Note: The data structure tables for a periodic BSpline surface are more complex than those of a non-periodic one. References : . A survey of curve and surface methods in CADG Wolfgang BOHM CAGD 1 (1984) . On de Boor-like algorithms and blossoming Wolfgang BOEHM cagd 5 (1988) . Blossoming and knot insertion algorithms for B-spline curves Ronald N. GOLDMAN . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA . Curves and Surfaces for Computer Aided Geometric Design, a practical guide Gerald Farin </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2cceaf7bab6ce3a234166ebbd9671f6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Geom_BSplineSurface::Geom_BSplineSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>Poles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>UKnots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>VKnots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>UMults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>VMults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>UPeriodic</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>VPeriodic</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a non-rational b-spline surface (weights default value is 1.). The following conditions must be verified. 0 &lt; UDegree &lt;= MaxDegree. UKnots.Length() == UMults.Length() &gt;= 2 UKnots(i) &lt; UKnots(i+1) (Knots are increasing) 1 &lt;= UMults(i) &lt;= UDegree On a non uperiodic surface the first and last umultiplicities may be UDegree+1 (this is even recommanded if you want the curve to start and finish on the first and last pole). On a uperiodic surface the first and the last umultiplicities must be the same. on non-uperiodic surfaces Poles.ColLength() == Sum(UMults(i)) - UDegree - 1 &gt;= 2 on uperiodic surfaces Poles.ColLength() == Sum(UMults(i)) except the first or last The previous conditions for U holds also for V, with the RowLength of the poles. </p>

</div>
</div>
<a class="anchor" id="a4ccceccdf053e7164b6a6ac38251b709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Geom_BSplineSurface::Geom_BSplineSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>Poles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>UKnots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>VKnots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>UMults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>VMults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>UPeriodic</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>VPeriodic</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a non-rational b-spline surface (weights default value is 1.). </p>
<p>The following conditions must be verified. 0 &lt; UDegree &lt;= MaxDegree.</p>
<p>UKnots.Length() == UMults.Length() &gt;= 2</p>
<p>UKnots(i) &lt; UKnots(i+1) (Knots are increasing) 1 &lt;= UMults(i) &lt;= UDegree</p>
<p>On a non uperiodic surface the first and last umultiplicities may be UDegree+1 (this is even recommanded if you want the curve to start and finish on the first and last pole).</p>
<p>On a uperiodic surface the first and the last umultiplicities must be the same.</p>
<p>on non-uperiodic surfaces</p>
<p>Poles.ColLength() == Sum(UMults(i)) - UDegree - 1 &gt;= 2</p>
<p>on uperiodic surfaces</p>
<p>Poles.ColLength() == Sum(UMults(i)) except the first or last</p>
<p>The previous conditions for U holds also for V, with the RowLength of the poles. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9eb0b0bf1d999dea11fbc683087aec7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>V2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parametric bounds of the surface. Warnings : These parametric values are the bounds of the array of knots UKnots and VKnots only if the first knots and the last knots have a multiplicity equal to UDegree + 1 or VDegree + 1. </p>

<p>Implements <a class="el" href="class_geom___surface.html#af20854abf6916a75e63f19307a01bba9">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a40ea3f1c71d8ff14f5bf6dcdde40f318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::CheckAndSegment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction. </p>
<p>same as <a class="el" href="struct_segment.html">Segment</a> but do nothing if U1 and U2 (resp. V1 and V2) are equal to the bounds in U (resp. in V) of &lt;me&gt;. For example, if &lt;me&gt; is periodic in V, it will be always periodic in V after the segmentation if the bounds in V are unchanged</p>
<p>Warnings : Even if &lt;me&gt; is not closed it can become closed after the segmentation for example if U1 or U2 are out of the bounds of the surface &lt;me&gt; or if the surface makes loop. raises if U2 &lt; U1 or V2 &lt; V1. Standard_DomainError if U2 - U1 exceeds the uperiod for uperiodic surfaces. i.e. ((U2 - U1) - UPeriod) &gt; <a class="el" href="class_precision.html#a7430591942a5dd09f285176145f3236c" title="Used to test distances in parametric space on a default curve. ">Precision::PConfusion()</a>. Standard_DomainError if V2 - V1 exceeds the vperiod for vperiodic surfaces. i.e. ((V2 - V1) - VPeriod) &gt; <a class="el" href="class_precision.html#a7430591942a5dd09f285176145f3236c" title="Used to test distances in parametric space on a default curve. ">Precision::PConfusion()</a>). </p>

</div>
</div>
<a class="anchor" id="a6ced26d2801bdfb2bb115f6e26fa0a3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_geom_abs___shape_8hxx.html#a943632453b69386bece6c091156b1ed5">GeomAbs_Shape</a> Geom_BSplineSurface::Continuity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the continuity of the surface : C0 : only geometric continuity, C1 : continuity of the first derivative all along the Surface, C2 : continuity of the second derivative all along the Surface, C3 : continuity of the third derivative all along the Surface, CN : the order of continuity is infinite. A B-spline surface is infinitely continuously differentiable for the couple of parameters U, V such thats U != UKnots(i) and V != VKnots(i). The continuity of the surface at a knot value depends on the multiplicity of this knot. Example : If the surface is C1 in the V direction and C2 in the U direction this function returns Shape = C1. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a6dd10e7febac86783e100f9d17258d94">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="aa1c5f7695f47b095a35da1583ffb24a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___geometry.html">Geom_Geometry</a> &gt; Geom_BSplineSurface::Copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object which is a copy of this BSpline surface. </p>

<p>Implements <a class="el" href="class_geom___geometry.html#a812ed684034272f3ba06d5d45439d6a0">Geom_Geometry</a>.</p>

</div>
</div>
<a class="anchor" id="a8d2f90a91d005198f9c48be4419cd4bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::D0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the point of parameter U,V on the surface. </p>
<p>Raised only for an "OffsetSurface" if it is not possible to compute the current point. </p>

<p>Implements <a class="el" href="class_geom___surface.html#ab0f3bbc39c8a14b7a8e6458b894bc3e9">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a0c6859aee1031a20e7c3f5728c61d39a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::D1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raised if the continuity of the surface is not C1. </p>

<p>Implements <a class="el" href="class_geom___surface.html#ae25d8cd91d287fe73b7d12a15f0de1c4">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a5f025ad0472ba9347a348d12a346547b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::D2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2UV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raised if the continuity of the surface is not C2. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a5c9541712e7bae573ea26a37136d7a09">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a436b4769ce0890e9c102f50fc63f5531"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::D3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3UUV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3UVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raised if the continuity of the surface is not C3. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a9e1ced3dbc60fddf8301d94216c4cff5">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a1c134df6633a4ec31098a9daae348dd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgp___vec.html">gp_Vec</a> Geom_BSplineSurface::DN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nu is the order of derivation in the U parametric direction and Nv is the order of derivation in the V parametric direction. </p>
<p>Raised if the continuity of the surface is not CNu in the U direction and CNv in the V direction.</p>
<p>Raised if Nu + Nv &lt; 1 or Nu &lt; 0 or Nv &lt; 0.</p>
<p>The following functions computes the point for the parametric values (U, V) and the derivatives at this point on the B-spline surface patch delimited with the knots FromUK1, FromVK1 and the knots ToUK2, ToVK2. (U, V) can be out of these parametric bounds but for the computation we only use the definition of the surface between these knots. This method is useful to compute local derivative, if the order of continuity of the whole surface is not greater enough. Inside the parametric knot's domain previously defined the evaluations are the same as if we consider the whole definition of the surface. Of course the evaluations are different outside this parametric domain. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a8f7813e70495f5f9a3342dac84bc3795">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="aafa7cb8c9a667e9afa729fa388b0f6c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::ExchangeUV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the u and v parametric directions on this BSpline surface. As a consequence: </p>
<ul>
<li>the poles and weights tables are transposed,</li>
<li>the knots and multiplicities tables are exchanged,</li>
<li>degrees of continuity, and rational, periodic and uniform characteristics are exchanged, and</li>
<li>the orientation of the surface is inverted. </li>
</ul>

</div>
</div>
<a class="anchor" id="a44c4d423141477924b73938556f53596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::FirstUKnotIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Index of the UKnots which gives the first parametric value of the surface in the U direction. The UIso curve corresponding to this value is a boundary curve of the surface. </p>

</div>
</div>
<a class="anchor" id="ae1d4a01b16526da24136ecac16ddf00b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::FirstVKnotIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Index of the VKnots which gives the first parametric value of the surface in the V direction. The VIso curve corresponding to this knot is a boundary curve of the surface. </p>

</div>
</div>
<a class="anchor" id="a1518b83991ee2eea82617ffcb61b6125"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncreaseDegree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VDegree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the degrees of this BSpline surface to UDegree and VDegree in the u and v parametric directions respectively. As a result, the tables of poles, weights and multiplicities are modified. The tables of knots is not changed. Note: Nothing is done if the given degree is less than or equal to the current degree in the corresponding parametric direction. Exceptions Standard_ConstructionError if UDegree or VDegree is greater than <a class="el" href="class_geom___b_spline_surface.html#ac1496de7ea0d7268ee94ba738c61dd0e" title="Returns the value of the maximum degree of the normalized B-spline basis functions in the u and v dir...">Geom_BSplineSurface::MaxDegree()</a>. </p>

</div>
</div>
<a class="anchor" id="a89f7df653df09054582143a163655682"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncreaseUMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the multiplicity of the knot of range UIndex in the UKnots sequence. M is the new multiplicity. M must be greater than the previous multiplicity and lower or equal to the degree of the surface in the U parametric direction. Raised if M is not in the range [1, UDegree]. </p>
<p>Raised if UIndex is not in the range [FirstUKnotIndex, LastUKnotIndex] given by the methods with the same name. </p>

</div>
</div>
<a class="anchor" id="a2e1bace85d54741492dfbeb8620d87b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncreaseUMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToI2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases until order M the multiplicity of the set of knots FromI1,...., ToI2 in the U direction. This method can be used to make a B_spline surface into a PiecewiseBezier B_spline surface. If &lt;me&gt; was uniform, it can become non uniform. </p>
<p>Raised if FromI1 or ToI2 is out of the range [FirstUKnotIndex, LastUKnotIndex].</p>
<p>M should be greater than the previous multiplicity of the all the knots FromI1,..., ToI2 and lower or equal to the Degree of the surface in the U parametric direction. </p>

</div>
</div>
<a class="anchor" id="ac0038875c69a1f5d9cea7a1658b50960"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncreaseVMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the multiplicity of a knot in the V direction. M is the new multiplicity. </p>
<p>M should be greater than the previous multiplicity and lower than the degree of the surface in the V parametric direction.</p>
<p>Raised if VIndex is not in the range [FirstVKnotIndex, LastVKnotIndex] given by the methods with the same name. </p>

</div>
</div>
<a class="anchor" id="a265fe70c543a2126a9a6a8e9e0f599c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncreaseVMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToI2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases until order M the multiplicity of the set of knots FromI1,...., ToI2 in the V direction. This method can be used to make a BSplineSurface into a PiecewiseBezier B_spline surface. If &lt;me&gt; was uniform, it can become non-uniform. </p>
<p>Raised if FromI1 or ToI2 is out of the range [FirstVKnotIndex, LastVKnotIndex] given by the methods with the same name.</p>
<p>M should be greater than the previous multiplicity of the all the knots FromI1,..., ToI2 and lower or equal to the Degree of the surface in the V parametric direction. </p>

</div>
</div>
<a class="anchor" id="a53653996a730f05b0d43429646555f71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncrementUMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToI2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the multiplicity of the consecutives uknots FromI1..ToI2 by step. The multiplicity of each knot FromI1,.....,ToI2 must be lower or equal to the UDegree of the B_spline. </p>
<p>Raised if FromI1 or ToI2 is not in the range [FirstUKnotIndex, LastUKnotIndex]</p>
<p>Raised if one knot has a multiplicity greater than UDegree. </p>

</div>
</div>
<a class="anchor" id="a90604191893bb2dc3bca30b3447aa8bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::IncrementVMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromI1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToI2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the multiplicity of the consecutives vknots FromI1..ToI2 by step. The multiplicity of each knot FromI1,.....,ToI2 must be lower or equal to the VDegree of the B_spline. </p>
<p>Raised if FromI1 or ToI2 is not in the range [FirstVKnotIndex, LastVKnotIndex]</p>
<p>Raised if one knot has a multiplicity greater than VDegree. </p>

</div>
</div>
<a class="anchor" id="abd4b07416d5e8d9a87f447e41cb477fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::InsertUKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>Add</em> = <code><a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a knot value in the sequence of UKnots. If U is a knot value this method increases the multiplicity of the knot if the previous multiplicity was lower than M else it does nothing. The tolerance criterion is ParametricTolerance. ParametricTolerance should be greater or equal than Resolution from package gp. </p>
<p>Raised if U is out of the bounds [U1, U2] given by the methods Bounds, the criterion ParametricTolerance is used. Raised if M is not in the range [1, UDegree]. </p>

</div>
</div>
<a class="anchor" id="a99eabcf868d4a08c60eeac5913b96095"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::InsertUKnots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>Mults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>Add</em> = <code><a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts into the knots table for the U parametric direction of this BSpline surface: </p>
<ul>
<li>the values of the array Knots, with their respective multiplicities, Mults. If the knot value to insert already exists in the table, its multiplicity is:</li>
<li>increased by M, if Add is true (the default), or</li>
<li>increased to M, if Add is false. The tolerance criterion used to check the equality of the knots is the larger of the values ParametricTolerance and Standard_Real::Epsilon(val), where val is the knot value to be inserted. Warning</li>
<li>If a given multiplicity coefficient is null, or negative, nothing is done.</li>
<li>The new multiplicity of a knot is limited to the degree of this BSpline surface in the corresponding parametric direction. Exceptions Standard_ConstructionError if a knot value to insert is outside the bounds of this BSpline surface in the specified parametric direction. The comparison uses the precision criterion ParametricTolerance. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1695d16dec722f5ee1cef55b980e95a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::InsertVKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>Add</em> = <code><a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a knot value in the sequence of VKnots. If V is a knot value this method increases the multiplicity of the knot if the previous multiplicity was lower than M otherwise it does nothing. The tolerance criterion is ParametricTolerance. ParametricTolerance should be greater or equal than Resolution from package gp. </p>
<p>raises if V is out of the Bounds [V1, V2] given by the methods Bounds, the criterion ParametricTolerance is used. raises if M is not in the range [1, VDegree]. </p>

</div>
</div>
<a class="anchor" id="ab0cec108eb6a0e03fc0548be17fd0692"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::InsertVKnots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>Mults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>Add</em> = <code><a class="el" href="_standard___type_def_8hxx.html#adaca7d05402b898f825597e547a03d00">Standard_True</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts into the knots table for the V parametric direction of this BSpline surface: </p>
<ul>
<li>the values of the array Knots, with their respective multiplicities, Mults. If the knot value to insert already exists in the table, its multiplicity is:</li>
<li>increased by M, if Add is true (the default), or</li>
<li>increased to M, if Add is false. The tolerance criterion used to check the equality of the knots is the larger of the values ParametricTolerance and Standard_Real::Epsilon(val), where val is the knot value to be inserted. Warning</li>
<li>If a given multiplicity coefficient is null, or negative, nothing is done.</li>
<li>The new multiplicity of a knot is limited to the degree of this BSpline surface in the corresponding parametric direction. Exceptions Standard_ConstructionError if a knot value to insert is outside the bounds of this BSpline surface in the specified parametric direction. The comparison uses the precision criterion ParametricTolerance. </li>
</ul>

</div>
</div>
<a class="anchor" id="a19931558c0e3ca544f3424bb177a2dec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Geom_BSplineSurface::IsCNu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if the order of continuity of the surface in the U direction is N. Raised if N &lt; 0. </p>

<p>Implements <a class="el" href="class_geom___surface.html#ad3ada7652acf2271c9ed3030c9d75472">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a6cf09c7bf5c62d9f9e4438f61ed89fed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Geom_BSplineSurface::IsCNv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if the order of continuity of the surface in the V direction is N. Raised if N &lt; 0. </p>

<p>Implements <a class="el" href="class_geom___surface.html#ab47736618f77f93f59d77033af53e5c8">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a78bb4e2240063d5c2e17716b40210159"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Geom_BSplineSurface::IsUClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the first control points row and the last control points row are identical. The tolerance criterion is Resolution from package gp. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a77dfb59d93a4b4777bcee9322418516b">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a58c8c127ddd2cc219a823fe307bffafd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Geom_BSplineSurface::IsUPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if the surface is closed in the U direction and if the B-spline has been turned into a periodic surface using the function SetUPeriodic. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a0cbe144d4fae277da8dea60b156b547d">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a0759e88bef79d3ae98ed8d869f642e12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Geom_BSplineSurface::IsURational </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns False if for each row of weights all the weights are identical. The tolerance criterion is resolution from package gp. Example : |1.0, 1.0, 1.0| if Weights = |0.5, 0.5, 0.5| returns False |2.0, 2.0, 2.0|. </p>

</div>
</div>
<a class="anchor" id="a00d98ef8c666ada0afdb6f3cb0869c17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Geom_BSplineSurface::IsVClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the first control points column and the last last control points column are identical. The tolerance criterion is Resolution from package gp. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a78e08179fd018332e68dece6be8fe6b9">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a9b11a0862f6316db6dea691af2070063"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Geom_BSplineSurface::IsVPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if the surface is closed in the V direction and if the B-spline has been turned into a periodic surface using the function SetVPeriodic. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a6e7e0be648e6bcbb1bd6f8a9651b9aef">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="ab9bed2e62428bf9cb12b6d2caff5ea4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Geom_BSplineSurface::IsVRational </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns False if for each column of weights all the weights are identical. The tolerance criterion is resolution from package gp. Examples : |1.0, 2.0, 0.5| if Weights = |1.0, 2.0, 0.5| returns False |1.0, 2.0, 0.5|. </p>

</div>
</div>
<a class="anchor" id="a11ac323d40ede2be6373579b3ab26145"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::LastUKnotIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Index of the UKnots which gives the last parametric value of the surface in the U direction. The UIso curve corresponding to this knot is a boundary curve of the surface. </p>

</div>
</div>
<a class="anchor" id="a3730f82b694e480a3654ebbf295f1e8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::LastVKnotIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Index of the VKnots which gives the last parametric value of the surface in the V direction. The VIso curve corresponding to this knot is a boundary curve of the surface. </p>

</div>
</div>
<a class="anchor" id="a7d5f82e7e1f1691083df1e0de6fe0b3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocalD0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a class="anchor" id="a2dfd752e4802fb1d268f4443d263120c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocalD1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised if the local continuity of the surface is not C1 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a class="anchor" id="a2bf64a41ca9fa3014955339b26d44940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocalD2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2UV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised if the local continuity of the surface is not C2 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a class="anchor" id="a36fa5a57d280cebcf52ecbf262d29dbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocalD3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D1V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D2UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3UUV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgp___vec.html">gp_Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>D3UVV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised if the local continuity of the surface is not C3 between the knots FromUK1, ToUK2 and FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a class="anchor" id="a02cdf679e30e20f545361126d2697c0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgp___vec.html">gp_Vec</a> Geom_BSplineSurface::LocalDN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Nv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raised if the local continuity of the surface is not CNu between the knots FromUK1, ToUK2 and CNv between the knots FromVK1, ToVK2. Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a class="anchor" id="abd1b04a9ced3c467c97ee62797abeb7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgp___pnt.html">gp_Pnt</a> Geom_BSplineSurface::LocalValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromUK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToUK2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>FromVK1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>ToVK2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the point of parameter U, V on the BSpline surface patch defines between the knots UK1 UK2, VK1, VK2. U can be out of the bounds [Knot UK1, Knot UK2] and V can be outof the bounds [Knot VK1, Knot VK2] but for the computation we only use the definition of the surface between these knot values. Raises if FromUK1 = ToUK2 or FromVK1 = ToVK2. </p>

</div>
</div>
<a class="anchor" id="aeb7346d087526994dded6db66f291395"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocateU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>I1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>I2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>WithKnotRepetition</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates the parametric value U in the sequence of UKnots. If "WithKnotRepetition" is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. UKnots (I1) &lt;= U &lt;= UKnots (I2) . if I1 = I2 U is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 &lt; 1 =&gt; U &lt; UKnots(1) - Abs(ParametricTolerance) . if I2 &gt; NbUKnots =&gt; U &gt; UKnots(NbUKnots)+Abs(ParametricTolerance) </p>

</div>
</div>
<a class="anchor" id="acdb16e5ceee47bf6c56920a7ff9b30df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::LocateV </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>ParametricTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>I1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>I2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>WithKnotRepetition</em> = <code><a class="el" href="_standard___type_def_8hxx.html#a7b6e608c3535f709d07e1ad1c933ae20">Standard_False</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates the parametric value V in the sequence of knots. If "WithKnotRepetition" is True we consider the knot's representation with repetition of multiple knot value, otherwise we consider the knot's representation with no repetition of multiple knot values. VKnots (I1) &lt;= V &lt;= VKnots (I2) . if I1 = I2 V is a knot value (the tolerance criterion ParametricTolerance is used). . if I1 &lt; 1 =&gt; V &lt; VKnots(1) - Abs(ParametricTolerance) . if I2 &gt; NbVKnots =&gt; V &gt; VKnots(NbVKnots)+Abs(ParametricTolerance) poles insertion and removing The following methods are available only if the surface is Uniform or QuasiUniform in the considered direction The knot repartition is modified. </p>

</div>
</div>
<a class="anchor" id="ac1496de7ea0d7268ee94ba738c61dd0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::MaxDegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the maximum degree of the normalized B-spline basis functions in the u and v directions. </p>

</div>
</div>
<a class="anchor" id="a914512eca1f25878577aee7499a2583b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::MovePoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>UFirstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>ULastIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>VFirstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>VLastIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a point with parameter U and V to P. given u,v as parameters) to reach a new position UIndex1, UIndex2, VIndex1, VIndex2: indicates the poles which can be moved if Problem in BSplineBasis calculation, no change for the curve and UFirstIndex, VLastIndex = 0 VFirstIndex, VLastIndex = 0. </p>
<p>Raised if UIndex1 &lt; UIndex2 or VIndex1 &lt; VIndex2 or UIndex1 &lt; 1 || UIndex1 &gt; NbUPoles or UIndex2 &lt; 1 || UIndex2 &gt; NbUPoles VIndex1 &lt; 1 || VIndex1 &gt; NbVPoles or VIndex2 &lt; 1 || VIndex2 &gt; NbVPoles characteristics of the surface </p>

</div>
</div>
<a class="anchor" id="a4fda529f08492ee9dd128bc2d2feeed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::NbUKnots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of knots in the U direction. </p>

</div>
</div>
<a class="anchor" id="a0c623b7d762afd5deae229509ed34a25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::NbUPoles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of poles in the U direction. </p>

</div>
</div>
<a class="anchor" id="abdf551a12004b19b070eee96d7e70173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::NbVKnots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of knots in the V direction. </p>

</div>
</div>
<a class="anchor" id="ab9bf93fe24a03bc5a41be3351f8f7453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::NbVPoles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of poles in the V direction. </p>

</div>
</div>
<a class="anchor" id="a2fc80213dbcdd0c5d7633372014043f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::PeriodicNormalization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the parameter normalized within the period if the surface is periodic : otherwise does not do anything </p>

</div>
</div>
<a class="anchor" id="a5fb26726d77b7d4819d3281f79f15220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgp___pnt.html">gp_Pnt</a> Geom_BSplineSurface::Pole </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the pole of range (UIndex, VIndex). </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles or VIndex &lt; 1 or VIndex &gt; NbVPoles. </p>

</div>
</div>
<a class="anchor" id="adfdc3203cd2dec875aa768e9e1c3ff47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Poles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the poles of the B-spline surface. </p>
<p>Raised if the length of P in the U and V direction is not equal to NbUpoles and NbVPoles. </p>

</div>
</div>
<a class="anchor" id="aeee1b58eae821cf9f037403c7d543733"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_colgp___array2_of_pnt_8hxx.html#a01b2a6c4c0dde665a5a6a2a4392e12f4">TColgp_Array2OfPnt</a>&amp; Geom_BSplineSurface::Poles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the poles of the B-spline surface. </p>

</div>
</div>
<a class="anchor" id="a392ae7d2d902abef64aa61e4a04d0b63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Geom_BSplineSurface::RemoveUKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces to M the multiplicity of the knot of index Index in the U parametric direction. If M is 0, the knot is removed. With a modification of this type, the table of poles is also modified. Two different algorithms are used systematically to compute the new poles of the surface. For each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is checked. If this distance is less than Tolerance it ensures that the surface is not modified by more than Tolerance. Under these conditions, the function returns true; otherwise, it returns false. A low tolerance prevents modification of the surface. A high tolerance "smoothes" the surface. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of this BSpline surface. </p>

</div>
</div>
<a class="anchor" id="abba2001d928b071ceb0b5847ea56e74c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a> Geom_BSplineSurface::RemoveVKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces to M the multiplicity of the knot of index Index in the V parametric direction. If M is 0, the knot is removed. With a modification of this type, the table of poles is also modified. Two different algorithms are used systematically to compute the new poles of the surface. For each pole, the distance between the pole calculated using the first algorithm and the same pole calculated using the second algorithm, is checked. If this distance is less than Tolerance it ensures that the surface is not modified by more than Tolerance. Under these conditions, the function returns true; otherwise, it returns false. A low tolerance prevents modification of the surface. A high tolerance "smoothes" the surface. Exceptions Standard_OutOfRange if Index is outside the bounds of the knots table of this BSpline surface. </p>

</div>
</div>
<a class="anchor" id="a86e184acbeca9bf93faf8ed888d37e1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Resolution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Tolerance3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>UTolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> &amp;&#160;</td>
          <td class="paramname"><em>VTolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes two tolerance values for this BSpline surface, based on the given tolerance in 3D space Tolerance3D. The tolerances computed are: </p>
<ul>
<li>UTolerance in the u parametric direction, and</li>
<li>VTolerance in the v parametric direction. If f(u,v) is the equation of this BSpline surface, UTolerance and VTolerance guarantee that : | u1 - u0 | &lt; UTolerance and | v1 - v0 | &lt; VTolerance ====&gt; |f (u1,v1) - f (u0,v0)| &lt; Tolerance3D </li>
</ul>

</div>
</div>
<a class="anchor" id="a0d5fd0e3f825bd9ee2f39b5fd6c0d0b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segments the surface between U1 and U2 in the U-Direction. between V1 and V2 in the V-Direction. The control points are modified, the first and the last point are not the same. Warnings : Even if &lt;me&gt; is not closed it can become closed after the segmentation for example if U1 or U2 are out of the bounds of the surface &lt;me&gt; or if the surface makes loop. raises if U2 &lt; U1 or V2 &lt; V1. Standard_DomainError if U2 - U1 exceeds the uperiod for uperiodic surfaces. i.e. ((U2 - U1) - UPeriod) &gt; <a class="el" href="class_precision.html#a7430591942a5dd09f285176145f3236c" title="Used to test distances in parametric space on a default curve. ">Precision::PConfusion()</a>. Standard_DomainError if V2 - V1 exceeds the vperiod for vperiodic surfaces. i.e. ((V2 - V1) - VPeriod) &gt; <a class="el" href="class_precision.html#a7430591942a5dd09f285176145f3236c" title="Used to test distances in parametric space on a default curve. ">Precision::PConfusion()</a>). </p>

</div>
</div>
<a class="anchor" id="a25d65634d8c16cf435ca655cba8a7c50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPole </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes the pole of range (UIndex, VIndex) with P. If the surface is rational the weight of range (UIndex, VIndex) is not modified. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles or VIndex &lt; 1 or VIndex &gt; NbVPoles. </p>

</div>
</div>
<a class="anchor" id="a4f15b262382cf0993d3f68e006a2475c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPole </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgp___pnt.html">gp_Pnt</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes the pole and the weight of range (UIndex, VIndex) with P and W. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles or VIndex &lt; 1 or VIndex &gt; NbVPoles. Raised if Weight &lt;= Resolution from package gp. </p>

</div>
</div>
<a class="anchor" id="aacf9582ad0b35728f241da3a05240501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPoleCol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a column of poles or a part of this column. Raised if Vindex &lt; 1 or VIndex &gt; NbVPoles. </p>
<p>Raised if CPoles.Lower() &lt; 1 or CPoles.Upper() &gt; NbUPoles. </p>

</div>
</div>
<a class="anchor" id="a4f72b47dc1ef861bc0d8181dfcfa3295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPoleCol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoleWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a column of poles or a part of this column with the corresponding weights. If the surface was rational it can become non rational. If the surface was non rational it can become rational. Raised if Vindex &lt; 1 or VIndex &gt; NbVPoles. </p>
<p>Raised if CPoles.Lower() &lt; 1 or CPoles.Upper() &gt; NbUPoles Raised if the bounds of CPoleWeights are not the same as the bounds of CPoles. Raised if one of the weight value of CPoleWeights is lower or equal to Resolution from package gp. </p>

</div>
</div>
<a class="anchor" id="a93f66596b553b9f191350b8e4d700323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPoleRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoleWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a row of poles or a part of this row with the corresponding weights. If the surface was rational it can become non rational. If the surface was non rational it can become rational. Raised if Uindex &lt; 1 or UIndex &gt; NbUPoles. </p>
<p>Raised if CPoles.Lower() &lt; 1 or CPoles.Upper() &gt; NbVPoles raises if the bounds of CPoleWeights are not the same as the bounds of CPoles. Raised if one of the weight value of CPoleWeights is lower or equal to Resolution from package gp. </p>

</div>
</div>
<a class="anchor" id="aff1784d238248031bb52c51bdd46a5cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetPoleRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_colgp___array1_of_pnt_8hxx.html#aea2b43cb69026cbf0931b64f5c8e1012">TColgp_Array1OfPnt</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a row of poles or a part of this row. Raised if Uindex &lt; 1 or UIndex &gt; NbUPoles. </p>
<p>Raised if CPoles.Lower() &lt; 1 or CPoles.Upper() &gt; NbVPoles. </p>

</div>
</div>
<a class="anchor" id="abad798e54698ffb43903d5716ae0cee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes the UKnots of range UIndex with K. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUKnots</p>
<p>Raised if K &gt;= UKnots(UIndex+1) or K &lt;= UKnots(UIndex-1) </p>

</div>
</div>
<a class="anchor" id="a739cf8b82973158284e38f9ab75fdfce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the value of the UKnots of range UIndex and increases its multiplicity. </p>
<p>Raised if UIndex is not in the range [FirstUKnotIndex, LastUKnotIndex] given by the methods with the same name.</p>
<p>Raised if K &gt;= UKnots(UIndex+1) or K &lt;= UKnots(UIndex-1) M must be lower than UDegree and greater than the previous multiplicity of the knot of range UIndex. </p>

</div>
</div>
<a class="anchor" id="a7e744c1a00c58eed3f992caba7d1668a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUKnots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>UK</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes all the U-knots of the surface. The multiplicity of the knots are not modified. </p>
<p>Raised if there is an index such that UK (Index+1) &lt;= UK (Index).</p>
<p>Raised if UK.Lower() &lt; 1 or UK.Upper() &gt; NbUKnots </p>

</div>
</div>
<a class="anchor" id="ac90ee06d28faf0e7992b4745ff6afbb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUNotPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the surface U not periodic. Changes this BSpline surface into a non-periodic surface along U direction. If this surface is already non-periodic, it is not modified. Note: the poles and knots tables are modified. </p>

</div>
</div>
<a class="anchor" id="adb456214cd15f2d60c1937fcd67bb967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the knot of index Index in the knots table in the corresponding parametric direction to be the origin of this periodic BSpline surface. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this BSpline surface is not periodic in the given parametric direction. Standard_DomainError if Index is outside the bounds of the knots table in the given parametric direction. </p>

</div>
</div>
<a class="anchor" id="aa0b39ea036cefa180705348855e68e78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetUPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the surface U periodic. Modifies this surface to be periodic in the U parametric direction. To become periodic in a given parametric direction a surface must be closed in that parametric direction, and the knot sequence relative to that direction must be periodic. To generate this periodic sequence of knots, the functions FirstUKnotIndex and LastUKnotIndex are used to compute I1 and I2. These are the indexes, in the knot array associated with the given parametric direction, of the knots that correspond to the first and last parameters of this BSpline surface in the given parametric direction. Hence the period is: Knots(I1) - Knots(I2) As a result, the knots and poles tables are modified. Exceptions Standard_ConstructionError if the surface is not closed in the given parametric direction. </p>

</div>
</div>
<a class="anchor" id="afe5f7237bcab9e4186b958668f951913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes the VKnots of range VIndex with K. </p>
<p>Raised if VIndex &lt; 1 or VIndex &gt; NbVKnots</p>
<p>Raised if K &gt;= VKnots(VIndex+1) or K &lt;= VKnots(VIndex-1) </p>

</div>
</div>
<a class="anchor" id="a54e4111066ef4b2a33a62d345934a1ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the value of the VKnots of range VIndex and increases its multiplicity. </p>
<p>Raised if VIndex is not in the range [FirstVKnotIndex, LastVKnotIndex] given by the methods with the same name.</p>
<p>Raised if K &gt;= VKnots(VIndex+1) or K &lt;= VKnots(VIndex-1) M must be lower than VDegree and greater than the previous multiplicity of the knot of range VIndex. </p>

</div>
</div>
<a class="anchor" id="a84e3a15de8c8c282b6e264122a829e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVKnots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>VK</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes all the V-knots of the surface. The multiplicity of the knots are not modified. </p>
<p>Raised if there is an index such that VK (Index+1) &lt;= VK (Index).</p>
<p>Raised if VK.Lower() &lt; 1 or VK.Upper() &gt; NbVKnots </p>

</div>
</div>
<a class="anchor" id="af335087f0d79b4fbaf141b50f6e46f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVNotPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the surface V not periodic. Changes this BSpline surface into a non-periodic surface along V direction. If this surface is already non-periodic, it is not modified. Note: the poles and knots tables are modified. </p>

</div>
</div>
<a class="anchor" id="ade5ff76aa0fb4ea90203db02da110fc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the knot of index Index in the knots table in the corresponding parametric direction to be the origin of this periodic BSpline surface. As a consequence, the knots and poles tables are modified. Exceptions Standard_NoSuchObject if this BSpline surface is not periodic in the given parametric direction. Standard_DomainError if Index is outside the bounds of the knots table in the given parametric direction. </p>

</div>
</div>
<a class="anchor" id="a1376ba80d7503a1519c35ee8fadfa2c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetVPeriodic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the surface V periodic. Modifies this surface to be periodic in the V parametric direction. To become periodic in a given parametric direction a surface must be closed in that parametric direction, and the knot sequence relative to that direction must be periodic. To generate this periodic sequence of knots, the functions FirstVKnotIndex and LastVKnotIndex are used to compute I1 and I2. These are the indexes, in the knot array associated with the given parametric direction, of the knots that correspond to the first and last parameters of this BSpline surface in the given parametric direction. Hence the period is: Knots(I1) - Knots(I2) As a result, the knots and poles tables are modified. Exceptions Standard_ConstructionError if the surface is not closed in the given parametric direction. </p>

</div>
</div>
<a class="anchor" id="a387528d50fb7fe2abeef279e7a8aae86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetWeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>Weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the weight of the pole of range UIndex, VIndex. If the surface was non rational it can become rational. If the surface was rational it can become non rational. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles or VIndex &lt; 1 or VIndex &gt; NbVPoles</p>
<p>Raised if weight is lower or equal to Resolution from package gp </p>

</div>
</div>
<a class="anchor" id="a921397a82aed03feae72dd0f73dc823e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetWeightCol </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoleWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a column of weights of a part of this column. </p>
<p>Raised if VIndex &lt; 1 or VIndex &gt; NbVPoles</p>
<p>Raised if CPoleWeights.Lower() &lt; 1 or CPoleWeights.Upper() &gt; NbUPoles. Raised if a weight value is lower or equal to Resolution from package gp. </p>

</div>
</div>
<a class="anchor" id="a1d9e2900caa95bf15c02124b1d4f115b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::SetWeightRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>CPoleWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes a row of weights or a part of this row. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles</p>
<p>Raised if CPoleWeights.Lower() &lt; 1 or CPoleWeights.Upper() &gt; NbVPoles. Raised if a weight value is lower or equal to Resolution from package gp. </p>

</div>
</div>
<a class="anchor" id="a8d26b8258d892130a39c05f119401fea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgp___trsf.html">gp_Trsf</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the transformation T to this BSpline surface. </p>

<p>Implements <a class="el" href="class_geom___geometry.html#a480bcb8e7ce3be50e592e692592f604a">Geom_Geometry</a>.</p>

</div>
</div>
<a class="anchor" id="ac6eb9060f51268c20fa5c8590a284f41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::UDegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the degree of the normalized B-splines Ni,n in the U direction. </p>

</div>
</div>
<a class="anchor" id="a62b22f80346b0cdd5bd730d3994b404e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt; Geom_BSplineSurface::UIso </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the U isoparametric curve. A B-spline curve is returned. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a2d390f1025bccd08d5ce69908b078fe1">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a3b57d6e1bc6b848997655e2f1d811fa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt; Geom_BSplineSurface::UIso </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>CheckRational</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the U isoparametric curve. If CheckRational=False, no try to make it non-rational. A B-spline curve is returned. </p>

</div>
</div>
<a class="anchor" id="aa5190b5a7d8f5fad084605d39973d371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Geom_BSplineSurface::UKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Knot value of range UIndex. Raised if UIndex &lt; 1 or UIndex &gt; NbUKnots. </p>

</div>
</div>
<a class="anchor" id="a87f4c334713e5114d8035b70ec4dc346"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_geom_abs___b_spl_knot_distribution_8hxx.html#a07138acc09f2b0c0b28245bb079c825d">GeomAbs_BSplKnotDistribution</a> Geom_BSplineSurface::UKnotDistribution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot in the U direction the B-spline surface can be : </p>
<ul>
<li>Uniform if all the knots are of multiplicity 1,</li>
<li>QuasiUniform if all the knots are of multiplicity 1 except for the first and last knot which are of multiplicity Degree + 1,</li>
<li>PiecewiseBezier if the first and last knots have multiplicity Degree + 1 and if interior knots have multiplicity Degree otherwise the surface is non uniform in the U direction The tolerance criterion is Resolution from package gp. </li>
</ul>

</div>
</div>
<a class="anchor" id="a06c429414907d5140650449b484b789e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::UKnots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Ku</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the knots in the U direction. </p>
<p>Raised if the length of Ku is not equal to the number of knots in the U direction. </p>

</div>
</div>
<a class="anchor" id="aa55db9e9628b79bc93f595d5ef4c490b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a>&amp; Geom_BSplineSurface::UKnots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the knots in the U direction. </p>

</div>
</div>
<a class="anchor" id="a0c432fc6d24e8ab4c35546a4a89a9922"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::UKnotSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Ku</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}. </p>
<p>Raised if the length of Ku is not equal to NbUPoles + UDegree + 1 </p>

</div>
</div>
<a class="anchor" id="ab71ddb06ff50f4bc750a22cb7027cbd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a>&amp; Geom_BSplineSurface::UKnotSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the uknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}. </p>

</div>
</div>
<a class="anchor" id="aba09e9712333bd0bf3a3135854f7c9e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::UMultiplicities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>Mu</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicities of the knots in the U direction. </p>
<p>Raised if the length of Mu is not equal to the number of knots in the U direction. </p>

</div>
</div>
<a class="anchor" id="a061fd82f0f9f959250a7b37bbd50b1fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a>&amp; Geom_BSplineSurface::UMultiplicities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicities of the knots in the U direction. </p>

</div>
</div>
<a class="anchor" id="a00fa5337b5b7aed234237187c2c332d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::UMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicity value of knot of range UIndex in the u direction. Raised if UIndex &lt; 1 or UIndex &gt; NbUKnots. </p>

</div>
</div>
<a class="anchor" id="aee0fcef877230439568db763810a1a28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::UReverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the orientation of this BSpline surface in the U parametric direction. The bounds of the surface are not changed but the given parametric direction is reversed. Hence the orientation of the surface is reversed. The knots and poles tables are modified. </p>

<p>Implements <a class="el" href="class_geom___surface.html#a72049f8a81936e5d981c14cccb4504f5">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a422cbc544eb9024d69e7ca5a1d70a044"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Geom_BSplineSurface::UReversedParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>U</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the u parameter on the modified surface, produced by reversing its U parametric direction, for the point of u parameter U, on this BSpline surface. For a BSpline surface, these functions return respectively: </p>
<ul>
<li>UFirst + ULast - U, where UFirst, ULast are the values of the first and last parameters of this BSpline surface, in the u parametric directions. </li>
</ul>

<p>Implements <a class="el" href="class_geom___surface.html#a1d933d74d5e2037c655f26d2699bdc80">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a8bcab7b412c71bd546127941c3821d91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::VDegree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the degree of the normalized B-splines Ni,d in the V direction. </p>

</div>
</div>
<a class="anchor" id="afcef9e159a1ac29910919587583d5ccc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt; Geom_BSplineSurface::VIso </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the V isoparametric curve. A B-spline curve is returned. </p>

<p>Implements <a class="el" href="class_geom___surface.html#abcfc97c472a7ef09532dbe2845aa25da">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="afec90a5e14c6455e945ef61c81d4d16a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___handle_8hxx.html#a464f2f86d5d805f03f4e3c9beb007e40">Handle</a>&lt; <a class="el" href="class_geom___curve.html">Geom_Curve</a> &gt; Geom_BSplineSurface::VIso </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a0460dcc686a90e4ee5447e8bbcf0d9cd">Standard_Boolean</a>&#160;</td>
          <td class="paramname"><em>CheckRational</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the V isoparametric curve. If CheckRational=False, no try to make it non-rational. A B-spline curve is returned. transformations. </p>

</div>
</div>
<a class="anchor" id="a8c98b1703f60efe3e16aff888d959b59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Geom_BSplineSurface::VKnot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Knot value of range VIndex. Raised if VIndex &lt; 1 or VIndex &gt; NbVKnots. </p>

</div>
</div>
<a class="anchor" id="ab7c7cac0d083656d3c83dbe17bc3fda2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_geom_abs___b_spl_knot_distribution_8hxx.html#a07138acc09f2b0c0b28245bb079c825d">GeomAbs_BSplKnotDistribution</a> Geom_BSplineSurface::VKnotDistribution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier. If all the knots differ by a positive constant from the preceding knot in the V direction the B-spline surface can be : </p>
<ul>
<li>Uniform if all the knots are of multiplicity 1,</li>
<li>QuasiUniform if all the knots are of multiplicity 1 except for the first and last knot which are of multiplicity Degree + 1,</li>
<li>PiecewiseBezier if the first and last knots have multiplicity Degree + 1 and if interior knots have multiplicity Degree otherwise the surface is non uniform in the V direction. The tolerance criterion is Resolution from package gp. </li>
</ul>

</div>
</div>
<a class="anchor" id="a888f7a33d3d1c16d8ac559e85ec62b59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::VKnots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Kv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the knots in the V direction. </p>
<p>Raised if the length of Kv is not equal to the number of knots in the V direction. </p>

</div>
</div>
<a class="anchor" id="ab25120b626c4ae2fe6699978bef67e9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a>&amp; Geom_BSplineSurface::VKnots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the knots in the V direction. </p>

</div>
</div>
<a class="anchor" id="a0f9c38221762c3e09618df920a5841b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::VKnotSequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>Kv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Kv = {k1, k1, k1, k2, k3, k3, k4, k4, k4}. </p>
<p>Raised if the length of Kv is not equal to NbVPoles + VDegree + 1 </p>

</div>
</div>
<a class="anchor" id="ae35cc121170a4f0c31ae18bdc10a0667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_real_8hxx.html#a43f7331116a19b839d3e9b79a92d2289">TColStd_Array1OfReal</a>&amp; Geom_BSplineSurface::VKnotSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vknots sequence. In this sequence the knots with a multiplicity greater than 1 are repeated. Example : Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}. </p>

</div>
</div>
<a class="anchor" id="a8dbca5fe88b07f43ffdf63c9003c68bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::VMultiplicities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>Mv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicities of the knots in the V direction. </p>
<p>Raised if the length of Mv is not equal to the number of knots in the V direction. </p>

</div>
</div>
<a class="anchor" id="ae61806d01e38a1a7e17890c013538ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array1_of_integer_8hxx.html#a28bfd1675907baf60add37f006eea83d">TColStd_Array1OfInteger</a>&amp; Geom_BSplineSurface::VMultiplicities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicities of the knots in the V direction. </p>

</div>
</div>
<a class="anchor" id="a15aa91e2726f2bf5122222e9e0474d40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a> Geom_BSplineSurface::VMultiplicity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the multiplicity value of knot of range VIndex in the v direction. Raised if VIndex &lt; 1 or VIndex &gt; NbVKnots. </p>

</div>
</div>
<a class="anchor" id="aeba4946263dde87c57e9aa6329625767"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::VReverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the orientation of this BSpline surface in the V parametric direction. The bounds of the surface are not changed but the given parametric direction is reversed. Hence the orientation of the surface is reversed. The knots and poles tables are modified. </p>

<p>Implements <a class="el" href="class_geom___surface.html#aa2616fd0be00595e1c917a4a3fdbfdbc">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a2c0b8ad3c9632364a387f82334ac658a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Geom_BSplineSurface::VReversedParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a>&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the v parameter on the modified surface, produced by reversing its V parametric direction, for the point of v parameter V on this BSpline surface. For a BSpline surface, these functions return respectively: </p>
<ul>
<li>VFirst + VLast - V, VFirst and VLast are the values of the first and last parameters of this BSpline surface, in the v pametric directions. </li>
</ul>

<p>Implements <a class="el" href="class_geom___surface.html#a9f32c79c60ae1afc8cfa9dd1f8252c19">Geom_Surface</a>.</p>

</div>
</div>
<a class="anchor" id="a9a7bfe42269d26c41cb199ff70108467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_standard___type_def_8hxx.html#aef96be6ca3bae9762e592db2b356bc4c">Standard_Real</a> Geom_BSplineSurface::Weight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>UIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_standard___type_def_8hxx.html#a844729aed1c6f9f5aadd6d4e9ddd5984">Standard_Integer</a>&#160;</td>
          <td class="paramname"><em>VIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weight value of range UIndex, VIndex. </p>
<p>Raised if UIndex &lt; 1 or UIndex &gt; NbUPoles or VIndex &lt; 1 or VIndex &gt; NbVPoles. </p>

</div>
</div>
<a class="anchor" id="a4902acf8e043a038e9cc09f71268b16e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geom_BSplineSurface::Weights </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weights of the B-spline surface. </p>
<p>Raised if the length of W in the U and V direction is not equal to NbUPoles and NbVPoles. </p>

</div>
</div>
<a class="anchor" id="a02f59a7654187ef68e5980d988a60b2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_col_std___array2_of_real_8hxx.html#a2ec89af66e49fb557b4c5ac93b0dc647">TColStd_Array2OfReal</a>* Geom_BSplineSurface::Weights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the weights of the B-spline surface. value and derivatives computation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_geom___b_spline_surface_8hxx.html">Geom_BSplineSurface.hxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

